Chapter One: Primitive and Reference Types
    Lack of classes ->
    Lack of packages (class grouping) ->
    High degrees freedom of organization

    Almost all data in JavaScript is an object OR is accessed via objects
    Functions are represented as objects too - first class Functions

    Objects can be created anytime
    Object properties can be added or removed anytime

    Two primary JavaScript data types:
    1. primitive types
    2. reference types

  What are Types:
    Primitive types: stored as simple data types
    Reference types: stored as objects (references to location in memory)

    Primitive types can be treated like reference types

    JavaScript tracks variables for a particular scope with a "variable object"
      - Primitive values are stored directly on the variable object
      - Reference values are stored as pointers to location in memory in the variable object

    Primitive Types:
      Boolean: true or false
      Number: any integer or floating numeric value
      String: single or sequence of characters delimited by either single or double quotes - no character type
      Null: a primitive type with only one value null
      Undefined: default value of a variable; a primitive type with only one value, undefined

      All primitive types have literal representation of their values
      Literals are values NOT stored in a variable
      A variable assigned with primitive value has its own copy of data

      Identifying Primitive Types:
        Best way to identify primitive types is with typeof operator
        console.log(typeof "Charles");   // "string"
        console.log(typeof 10);           // "number"
        console.log(typeof 10.1);         // "number"
        console.log(typeof true);         // "boolean"
        console.log(typeof undefined);    // "undefined"

        EXCEPTION: null
        console.log(typeof null);         // "object"
        The best way to identify null is by ===
        console.log(value === null);      // return true if value is null

      Primitive Methods:
        Despite having method, primitive values are NOT objects
        null & undefined have no Methods

        string:
          var str = "TokenOne";
          var lowercaseName = str.toLowerCase();    // "tokenone"
          var firstLetter = str.charAt(0);          // "T"
          var middleStr = str.substring(2, 5);      // "ken" (index: 2 - 4)

        number:
          var count = 10;
          var fixedCount = count.toFixed(2);        // convert to "10.00"
          var hexCount = count.toString(16);        // convert to "a", hexdecimal - base 16

        boolean:
          var flag = true;
          var strFlg = flag.toString();             // convert to "true"

    Reference Types:
      Reference type represents objects
      Reference values are instances / objects
      Object is an unordered list of properties (name : value pairs)
      If a property's value is function, the property is a "method"
      Function is reference value

      Creating Objects:
        new operator with a constructor
          - constructor is any function that uses new to create an object
          - constructor begin with a capital letter by convention
          Ex. var object = new Object();
          - When an object is assigned to a varaiable, only the reference / pointer is copied,
            the memory referenced by the pointer is shared among variables
          Ex.
            var obj01 = new Object();
            var obj02 = obj01;

      Dereferencing Objects:
        JavaScript is a garbage-collected language
        Deference a reference by assign the variable to null

      Adding or Removing Properties
        Ex.
          var object1 = new Object();
          var object2 = object1;

          object1.myProperty = "Awsome!";
          console.log(object2.myProperty);  // "Awsome!"

    Instantiating Built-In Types:
      Built-In types:
        Array     - an ordered list of numerically indexed values
        Date      - a date and time
        Error     - a runtime error (with several more specific subtypes)
        Function  - a function
        Object    - a generaic object
        RegExp    - a regular expression

      Instantiation:
        var list  = new Array();
        var now   = new Date();
        var error = new Error("Somthing Wrong");
        var func  = new Function("console.log('log')");
        var object = new Object();
        var re    = new RegExp("\\d+");

      Literal Forms
        Literal:
          syntax that define a reference value
          without explicitly creating an object using "new" operator and constructor

      Object and Array Literals
        object literal syntax:
          define properties of a new object inside braces
          but does NOT call the constructor

        property is made of:
          1. identifier or string
          2. colon
          3. value

        Multiple properties are separated by commas

        Ex. with identifier as property name
          var book = {
            name: "The Principles of Object-Oriented JavaScript",
            year: 2014
          }

        Ex. same object with string literals as property name
          var book = {
            "name": "The Principles of Object-Oriented JavaScript",
            "year": 2014
          }

        Logically Equvilent to
          var book = new Object();
          book.name = "The Principles of Object-Oriented JavaScript";
          book.year = 2014;

        Array literal:
        Ex.
          var colors = [ "red", "white", "blue"];

        Logically Equvilent to
          var colors = new Array("red", "white", "blue");

      Function Literals
        Define function with constructor is discouraged
        Define function with literal form is preferred
        Ex. literal form
          function reflect(value) {
            return value;
          }
        Ex. same function defined by constructor - but hard to debug
          var reflect = new function ("value", "return value;");

      Regular Expression Literals
        The pattern is contained b/t two forward slashes (/)
        Additional options are single characters follow the second forware slash
        Ex. literal form - preferred when constructed dynamically
          var numbers = /\d+/g; // a little easier - no need to escape characters, \d+
        Ex. Identical constructor form
          var numbers = new RegExp("\\d+", "g"); // need to escape backslashes, \\d+

    Property Access
      By dot notation:
        Ex.
          var array = [];
          array.push(12345);
      By bracket notation:
        Ex.
          var array = [];
          array["push"](12345);

      Bracket notation can be used to call method dynamically
      Bracket notation allow use of special characters in property name
      Dot notation is more readable for most

    Identifying Reference Types
      Function is identified via typeof operator
      Ex.
        function reflect(value) {
          return value;
        }
        console.log(typeof reflect);  //"function"

      For all other reference types, keyword typeof returns "object"
      Use "instanceof" to identify these objects
      Ex. instanceof
        var items = [];
        var object = {};

        function reflect(reflect) {
          return value;
        }

        console.log(items instanceof Array);      // return true
        console.log(object instanceof Object);    // return true
        console.log(reflect instanceof Function); // return true

      Use "instanceof" to identify inherited types
      Ex.
        var items = [];
        var object = {};

        function reflect(value) {
          return value;
        }
        console.log(items instanceof Array);
        console.log(items instanceof Object);
        console.log(object instanceof Object);
        console.log(object instanceof Array);     // false
        console.log(reflect instanceof Function);
        console.log(reflect instanceof Object);

    Identifying Arrays
      keyword instanceof can identify array
      Each web page has its own global context
        - its own version of Object, Array and all builtin types
      Array from one frame cannot be identify by instanceof
      ES 5 feature: Array.isArray() - Not supported in IE 8 or eariler
      Ex.
        var items = [];
        console.log(Array.isArray(items));  // true

    Primitive Wrapper Types
      references types exist to make primitive types works like object
        String
        Number
        Boolean
      Ex. String.charAt()
        var name = "Charles";
        var firstChar = name.charAt(0);
        console.log(firstChar);   // "N"

      Actual implementation:
        var name = "Charles";
        var temp = new String(name);  // "Autoboxing": implicit creation of wrapper type
        var firstChar = name.charAt(0);
        temp = null;                  // "Autoboxing": implicit removeal of wrapper type right after wrapper method call
        console.log(firstChar);       // "N"

      Due to automboxing, Wrapper Types can NOT be used like noraml reference types
      Ex. Additional properties wrapper type CANNOT be accessed
        var name = "Charles";
        name.last= "Kuo";

        console.log(name.last); // undefined

      Actucal implementation
        var name = "Charles";
        var temp = new String(name);
        name.last= "Kuo";
        temp = null;

        var temp = new String(name);  // wrapper type created
        console.log(temp.last); // undefined
        temp = null;

      Primitive types cannot be identified as its wrapper types by keyword instanceof
      Ex.
        var name = "Charles";
        console.log(name instanceof String);  // false

      Wrapper types cannot be used as its primitive types
      Ex.
        var found = new Boolean(false);

        if (found) { console.log("Found"); } // found is truthy
      Avoid instantiating primitive wrappers manually

    Summary
      JS: types, not class
      primitive types: string, number, boolean, null, undefined
      all primitive types but "null" can be identified by keyword typeof
      identify "null" by === compare with "null"
      Functions are identified by typeof operator
      primitive wrapper types: String, Number, Boolean

Chapter Two: Functions
  Functions are distinguished from other objects by its internal property [[Call]]
  Internal property cannot be accessed by code
  Functions are identified via "typeof" keyword

  Declarations vs. Expression
    Function Declaration:
      1. "function" keyword
      2. function name
      3. zero or more parameters enclosed in parenthese, saperated by commas
      4. content enclosed in braces
      Ex.
      function add(num1, num2) {
        return num1 + num2;
      }
    Function declarations are hoisted to the top of context
    Ex.
      var result = add(5, 5);

      function add(num1, num2) {
        return num1 + num2;
      }

      ... is actually interpreted by JS engine
      function add(num1, num2) {
        return num1 + num2;
      }

      var result = add(5, 5);

    Function Expression:
      1. "function" keyword
      2. zero or more parameters enclosed in parenthese, saperated by commas
      3. content enclosed in braces

    Function Expression(s) are anonymous
      - usually assigned to a variable or property & ends with semicolon
    Ex.
      var add = function(num1, num2) {
        return num1 + num2;
      };

    Define functions before usage to avoid potential issues

  Function as values
    Functions can be used like other objects, such as:
      - assigned to variables
      - added to objects
      - passed as arguments to other functions
      - returned from other functions

    Ex. assign function to variables
      function sayHi() {
        console.log("Hi!");
      }
      sayHi();  // outputs "Hi!"

      var sayHi2 = sayHi;

      sayHi2(); // outputs "Hi!"

    Ex. pass function as arguments to other functions
    var numbers = [ 1, 5, 8, 4, 7, 10, 2, 6 ];
    numbers.sort(function(first, second) {
      return first - second;
    });

    console.log(numbers); // "[1, 2, 4, 5, 6, 7, 8, 10]"
    numbers.sort();
    console.log(numbers); // "[1, 10, 2, 4, 5, 6, 7, 8]"

    Comparison function (as function expression & anonymous function) is passed into sort()
    numbers.sort(); sorts array as strings

  Parameters

  Overloading
  Object Methods
    The "this" Object
    Changing this
  Summary
    Functions are objects too
    Function has special internal property [[Call]]
    Function declaration
      - function name is right of the "function" keyword
      - Hoisted to top of the context scope
    Function expression
      - other values can also be used
    Function constructor should be avoided






































