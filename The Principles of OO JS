Chapter One: Primitive and Reference Types
    Lack of classes ->
    Lack of packages (class grouping) ->
    High degrees freedom of organization

    Almost all data in JavaScript is an object OR is accessed via objects
    Functions are represented as objects too - first class Functions

    Objects can be created anytime
    Object properties can be added or removed anytime

    Two primary JavaScript data types:
    1. primitive types
    2. reference types

  What are Types:
    Primitive types: stored as simple data types
    Reference types: stored as objects (references to location in memory)

    Primitive types can be treated like reference types

    JavaScript tracks variables for a particular scope with a "variable object"
      - Primitive values are stored directly on the variable object
      - Reference values are stored as pointers to location in memory in the variable object

    Primitive Types:
      Boolean: true or false
      Number: any integer or floating numeric value
      String: single or sequence of characters delimited by either single or double quotes - no character type
      Null: a primitive type with only one value null
      Undefined: default value of a variable; a primitive type with only one value, undefined

      All primitive types have literal representation of their values
      Literals are values NOT stored in a variable
      A variable assigned with primitive value has its own copy of data

      Identifying Primitive Types:
        Best way to identify primitive types is with typeof operator
        console.log(typeof "Charles");   // "string"
        console.log(typeof 10);           // "number"
        console.log(typeof 10.1);         // "number"
        console.log(typeof true);         // "boolean"
        console.log(typeof undefined);    // "undefined"

        EXCEPTION: null
        console.log(typeof null);         // "object"
        The best way to identify null is by ===
        console.log(value === null);      // return true if value is null

      Primitive Methods:
        Despite having method, primitive values are NOT objects
        null & undefined have no Methods

        string:
          var str = "TokenOne";
          var lowercaseName = str.toLowerCase();    // "tokenone"
          var firstLetter = str.charAt(0);          // "T"
          var middleStr = str.substring(2, 5);      // "ken" (index: 2 - 4)

        number:
          var count = 10;
          var fixedCount = count.toFixed(2);        // convert to "10.00"
          var hexCount = count.toString(16);        // convert to "a", hexdecimal - base 16

        boolean:
          var flag = true;
          var strFlg = flag.toString();             // convert to "true"

    Reference Types:
      Reference type represents objects
      Reference values are instances / objects
      Object is an unordered list of properties (name : value pairs)
      If a property's value is function, the property is a "method"
      Function is reference value

      Creating Objects:
        new operator with a constructor
          - constructor is any function that uses new to create an object
          - constructor begin with a capital letter by convention
          Ex. var object = new Object();
          - When an object is assigned to a varaiable, only the reference / pointer is copied,
            the memory referenced by the pointer is shared among variables
          Ex.
            var obj01 = new Object();
            var obj02 = obj01;

      Dereferencing Objects:
        JavaScript is a garbage-collected language
        Deference a reference by assign the variable to null

      Adding or Removing Properties
        Ex.
          var object1 = new Object();
          var object2 = object1;

          object1.myProperty = "Awsome!";
          console.log(object2.myProperty);  // "Awsome!"

    Instantiating Built-In Types:
      Built-In types:
        Array     - an ordered list of numerically indexed values
        Date      - a date and time
        Error     - a runtime error (with several more specific subtypes)
        Function  - a function
        Object    - a generaic object
        RegExp    - a regular expression

      Instantiation:
        var list  = new Array();
        var now   = new Date();
        var error = new Error("Somthing Wrong");
        var func  = new Function("console.log('log')");
        var object = new Object();
        var re    = new RegExp("\\d+");

      Literal Forms
        Literal:
          syntax that define a reference value
          without explicitly creating an object using "new" operator and constructor

      Object and Array Literals
        object literal syntax:
          define properties of a new object inside braces
          but does NOT call the constructor

        property is made of:
          1. identifier or string
          2. colon
          3. value

        Multiple properties are separated by commas

        Ex. with identifier as property name
          var book = {
            name: "The Principles of Object-Oriented JavaScript",
            year: 2014
          }

        Ex. same object with string literals as property name
          var book = {
            "name": "The Principles of Object-Oriented JavaScript",
            "year": 2014
          }

        Logically Equvilent to
          var book = new Object();
          book.name = "The Principles of Object-Oriented JavaScript";
          book.year = 2014;

        Array literal:
        Ex.
          var colors = [ "red", "white", "blue"];

        Logically Equvilent to
          var colors = new Array("red", "white", "blue");

      Function Literals
        Define function with constructor is discouraged
        Define function with literal form is preferred
        Ex. literal form
          function reflect(value) {
            return value;
          }
        Ex. same function defined by constructor - but hard to debug
          var reflect = new function ("value", "return value;");

      Regular Expression Literals
        The pattern is contained b/t two forward slashes (/)
        Additional options are single characters follow the second forware slash
        Ex. literal form - preferred when constructed dynamically
          var numbers = /\d+/g; // a little easier - no need to escape characters, \d+
        Ex. Identical constructor form
          var numbers = new RegExp("\\d+", "g"); // need to escape backslashes, \\d+

    Property Access
      By dot notation:
        Ex.
          var array = [];
          array.push(12345);
      By bracket notation:
        Ex.
          var array = [];
          array["push"](12345);

      Bracket notation can be used to call method dynamically
      Bracket notation allow use of special characters in property name
      Dot notation is more readable for most

    Identifying Reference Types
      Function is identified via typeof operator
      Ex.
        function reflect(value) {
          return value;
        }
        console.log(typeof reflect);  //"function"

      For all other reference types, keyword typeof returns "object"
      Use "instanceof" to identify these objects
      Ex. instanceof
        var items = [];
        var object = {};

        function reflect(reflect) {
          return value;
        }

        console.log(items instanceof Array);      // return true
        console.log(object instanceof Object);    // return true
        console.log(reflect instanceof Function); // return true

      Use "instanceof" to identify inherited types
      Ex.
        var items = [];
        var object = {};

        function reflect(value) {
          return value;
        }
        console.log(items instanceof Array);
        console.log(items instanceof Object);
        console.log(object instanceof Object);
        console.log(object instanceof Array);     // false
        console.log(reflect instanceof Function);
        console.log(reflect instanceof Object);

    Identifying Arrays
      keyword instanceof can identify array
      Each web page has its own global context
        - its own version of Object, Array and all builtin types
      Array from one frame cannot be identify by instanceof
      ES 5 feature: Array.isArray() - Not supported in IE 8 or eariler
      Ex.
        var items = [];
        console.log(Array.isArray(items));  // true

    Primitive Wrapper Types
      references types exist to make primitive types works like object
        String
        Number
        Boolean
      Ex. String.charAt()
        var name = "Charles";
        var firstChar = name.charAt(0);
        console.log(firstChar);   // "N"

      Actual implementation:
        var name = "Charles";
        var temp = new String(name);  // "Autoboxing": implicit creation of wrapper type
        var firstChar = name.charAt(0);
        temp = null;                  // "Autoboxing": implicit removeal of wrapper type right after wrapper method call
        console.log(firstChar);       // "N"

      Due to automboxing, Wrapper Types can NOT be used like noraml reference types
      Ex. Additional properties wrapper type CANNOT be accessed
        var name = "Charles";
        name.last= "Kuo";

        console.log(name.last); // undefined

      Actucal implementation
        var name = "Charles";
        var temp = new String(name);
        name.last= "Kuo";
        temp = null;

        var temp = new String(name);  // wrapper type created
        console.log(temp.last); // undefined
        temp = null;

      Primitive types cannot be identified as its wrapper types by keyword instanceof
      Ex.
        var name = "Charles";
        console.log(name instanceof String);  // false

      Wrapper types cannot be used as its primitive types
      Ex.
        var found = new Boolean(false);

        if (found) { console.log("Found"); } // found is truthy
      Avoid instantiating primitive wrappers manually

    Summary
      JS: types, not class
      primitive types: string, number, boolean, null, undefined
      all primitive types but "null" can be identified by keyword typeof
      identify "null" by === compare with "null"
      Functions are identified by typeof operator
      primitive wrapper types: String, Number, Boolean

Chapter Two: Functions
  Functions are distinguished from other objects by its internal property [[Call]]
  Internal property cannot be accessed by code
  Functions are identified via "typeof" keyword

  Declarations vs. Expression
    Function Declaration:
      1. "function" keyword
      2. function name
      3. zero or more parameters enclosed in parenthese, saperated by commas
      4. content enclosed in braces
      Ex.
      function add(num1, num2) {
        return num1 + num2;
      }
    Function declarations are hoisted to the top of context
    Ex.
      var result = add(5, 5);

      function add(num1, num2) {
        return num1 + num2;
      }

      ... is actually interpreted by JS engine
      function add(num1, num2) {
        return num1 + num2;
      }

      var result = add(5, 5);

    Function Expression:
      1. "function" keyword
      2. zero or more parameters enclosed in parenthese, saperated by commas
      3. content enclosed in braces

    Function Expression(s) are anonymous
      - usually assigned to a variable or property & ends with semicolon
    Ex.
      var add = function(num1, num2) {
        return num1 + num2;
      };

    Define functions before usage to avoid potential issues

  Function as values
    Functions can be used like other objects, such as:
      - assigned to variables
      - added to objects
      - passed as arguments to other functions
      - returned from other functions

    Ex. assign function to variables
      function sayHi() {
        console.log("Hi!");
      }
      sayHi();  // outputs "Hi!"

      var sayHi2 = sayHi;

      sayHi2(); // outputs "Hi!"

    Ex. pass function as arguments to other functions
    var numbers = [ 1, 5, 8, 4, 7, 10, 2, 6 ];
    numbers.sort(function(first, second) {
      return first - second;
    });

    console.log(numbers); // "[1, 2, 4, 5, 6, 7, 8, 10]"
    numbers.sort();
    console.log(numbers); // "[1, 10, 2, 4, 5, 6, 7, 8]"

    Comparison function (as function expression & anonymous function) is passed into sort()
    numbers.sort(); sorts array as strings

  Parameters
    JS function takes any number of parameters without causing error
    "arguments" property of function object:
      automatically available within any function
      store parameters
      reference parameter by numeric index
      "length" property determines (arity) number of expected parameters
      BUT "arguments" is NOT an array -> Array.isArray(arguments) always return false
      Ex.
        // function declaration
        function reflect(value) {
          return value;
        }
        console.log(reflect("Hi"));     // "Hi" - first argument only
        console.log(reflect("Hi", 25)); // "Hi" - first argument only
        console.log(reflect.length);    // 1 - one named parameter

        // function expression
        function = function() {
          return arguments[0];
        };
        console.log(reflect("Hi"));     // "Hi" - first argument only
        console.log(reflect("Hi", 25)); // "Hi" - first argument only
        console.log(reflect.length);    // 0 - no named parameter

      "arguments" is best used when expecting no-fixing number of parameters
      Ex. function sum() {
        var result = 0,
        i = 0,
        len = arguments.length;

        while (i < len) {
          result += arguments[i];
          i++;
        }

        return result;
      }

      console.log(sum(1, 2));   // 3
      console.log(sum());       // 0 - reusult is initialized with zero

  Overloading
    Function overloading is NOT available b/c same function can accept multiple parameters
    Mimic function overloading by arguments object
      Ex.
      function sayMessage(message) {
        // alternatively: if (message === undefined)
        if (arguments.length === 0) {
          message = "Default message";
        }
        console.log(message);   // when function is called with at least one parameter
      }
    Use "typeof" or "instanceof" to check for diffeent data type

  Object Methods
    When object property is a function, the property is considered as method
    Method can be added like property with the same syntax
    Ex.
      var person = {
        name: "Charles",
        sayName: function() {
          console.log(person.name);
        }
      };
      person.sayName(); // outputs: "Charles"

    The "this" Object
      "this" object represents the calling object for the function
      In global scope, "this" represents global object
      In web browser, the global object is "window"
      When function is called while attached to an object, "this" represents the object
    Ex.
      var person = {
        name: "Charles",
        sayName: function() {
          console.log(this.name);  // access object property dynamically for code reuse
        }
      };
      person.sayName(); // outputs: "Charles"
    Ex.
      function sayNameForAll() {
        console.log(this.name);
      }

      var person1 = {
        name: "Jack",
        sayName: sayNameForAll
      };

      var person2 = {
        name: "Charles",
        sayName: sayNameForAll
      };

      var name = "Old Sport"; // global varaiable

      person1.sayName();  // "Jack"
      person2.sayName();  // "Charles"

      sayNameForAll();    // "Old Sport" - global variable is property of global object

    Changing this
      call() method:
        1st parameter: the value to which "this" should be equal when the function is executed
        subsequent parameters will be passed into the function
        Ex.
          function sayNameForAll(label) {
            console.log(label + ":" + this.name);
          }

          var p1 = {name: "Charles"};
          var p2 = {name: "Jack"};

          var name = "Old Sport";

          sayNameForAll.call(this, "global");   // output "global: Old Sport"
          sayNameForAll.call(p1, "person1");    // output "person1: Charles"
          sayNameForAll.call(p2, "person2");    // output "person2: Jack"

      apply() method:
        1st parameter: the value to which "this" should be equal when the function is executed
        subsequent parameters will be passed into the function AS ARRAY
        Ex.
          function sayNameForAll(label) {
            console.log(label + ":" + this.name);
          }

          var p1 = {name: "Charles"};
          var p2 = {name: "Jack"};

          var name = "Old Sport";

          sayNameForAll.apply(this, ["global"]);   // output "global: Old Sport"
          sayNameForAll.apply(p1, ["person1"]);    // output "person1: Charles"
          sayNameForAll.apply(p2, ["person2"]);    // output "person2: Jack"

      bind() method:
        This function is added after ES5; return a new function bind to a given object
        1st parameter: "this" value for the new function
        subsequent parameters will be passed into the function
        Ex.
          function sayNameForAll(label) {
            console.log(label + ":" + this.name);
          }

          var p1 = {name: "Charles"};
          var p2 = {name: "Jack"};

          // create a function just for p1
          var sayNameForPerson1 = sayNameForAll.bind(p1);
          sayNameForPerson1("person1");   // outputs "person1:Charles"

          // create a function just for p2
          var sayNameForPerson2 = sayNameForAll.bind(p2);
          sayNameForPerson2("person2");   // outputs "person2:Jack"

          // attaching a method to an object does not change "this"
          p2.sayName = sayNameForPerson1;
          p2.sayName("person2");    // outputs "person2:Charles"

  Summary
    Functions are objects too
    Function has special internal property [[Call]]
    Function declaration
      - function name is right of the "function" keyword
      - Hoisted to top of the context scope
    Function expression
      - other values can also be used
    Function constructor should be avoided

Chapter Three: Primitive and Reference Types
JS objects are dynamic - can change during execution
  Defining Properties
    Objects (properties) created by programmer are always open for modification unless specified otherwise

    When property first added to object,
    - Internal method [[Put]] specifies initial value & attributes of the property
    - By creating an "own property" on object
      - "Own property" indicate a specific instance of object owns that property
    - All operations on the propery must be performed via its object
    - "Own property" are different from prototype properties

    When new value assigned to an existing property:
    - Internal method [[Set]] replace old value with new

    Ex.
      var person1 = { name: "Charles" };    // [[Put]]name

      person1.age = "Redacted";   // [[Put]]age

      person1.name = "Greg";    // [[Set]]name

  Detecting Properties
    Avoid checking property existence by "truthy" or "falsy" value (in if expression)
      - a valid property can contain falsy values -> causing false negative
    truthy:
      - an object
      - non-empty string
      - non-zero number
      - true
    falsy:
      - null
      - undefined
      - 0
      - NaN
      - empty string

    Detect property existence with "in" operator:
      "in" operator checks for given key exists in hash table
      Ex. ... following previous example
        console.log("name" in person1);   // "true" - person1 holds property "name"
        console.log("age" in person1);    // "true" - person1 holds property "age"
        console.log("title" in person1);  // "false"- No "title" property in person1

    Detect method (function as property) with "in" operator
    Ex.
      var person1 = {
        name: "Charles",
        sayName: function() {
          console.log(this.name);
        }
      };
      console.log("sayName" in person1);    // true

    Detect property with "in" will NOT evaluate value of property
      - this avoid error or performance issue
      - detect own properties AND prototype properties

    Detect ONLY own properties with hasOwnProperty() method
    Ex. following example above
      console.log("toString" in person1);               // true
      console.log(person1.hasOwnProperty("toString"));  // false
      // toString() method is a prototype present on all objects

  Removing Properties
    "delete" operator calls internal operator [[Delete]] to remove key/value pair from hash table
    Upon successful delete, it returns true
    Ex.
      var person1 = {
        name: "Charles"
      };

      console.log("name" in person1);     // true
      console.log(delete person1.name);   // delete property & return true
      console.log("name" in person1);     // false
      console.log(person1.name);          // undefined

  Enumeration
    By default, all properties added are enumerable
    Enumerable properties have internal [[Enumerable]] attributes set to true
    Ex.
      var obj = {a: 1, b: 2, c: 3};
      var prop;
      for (prop in obj) {
        console.log('Name: ' + prop);
        console.log('Value: ' + obj[prop]);
      }
    "for - in" loop return prototype & own properties

    Object.keys(obj) retrive enumerable peoperties from object in parameter
    Ex.
      var obj = {a: 1, b: 2, c: 3};
      var properties = Object.keys(obj);
      // if you want to mimic for-in behavior
      var i, len;
      for (i=0, len=properties.length; i < len; i++){
        console.log("Name: " + properties[i]);
        console.log("Value: " + obj[properties[i]]);
      }
    Object.keys() returns only own / instance properties

    Not all properties are enumerable 
      - most native methods on object have [[Enumerable]] attribute set to false
    Ex.
      

  Type of Properties
  Property Attributes
    Common Attributes
    Data Property Attributes
    Accessor Property Attributes
    Defining Multiple Properties
    Retrieving Property Attributes
  Preventing Object Modification
    Preventing Extensions
    Sealing Objects
    Freezing Objects
  Summary






































