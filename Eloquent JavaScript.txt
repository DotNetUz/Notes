Ch 1 Values, Types, and Operators
    number 13 in bits => 
        1 1 0 1 => 
        1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 =
        8 + 4 + 1 = 13   
    Values: chunks of bits that represnt pieces of information
        6 basic types of value:
            numbers, strings, Boolean, object, functions and undefined values
    Numbers
        A single number is stored in 64 bits - which can represnt 2^64 different numbers 
        Overflow: a number does NOT fit into given amount of bits
        Represent nonwhole number: extra bit to store position of decimal point
        Negative number: one bit for sign of number
        Actual whole number (integer) can be precisely stored: 9 quadrillion 15 zeros   
        Scientific notation by "e", like 2.998e8 => 299,800,000
        Precision: many number lose precision with only 64 bit bits available 
        Treat fractional digits as approximation NOT precise number
        Arithmetic operator precedence: 
            (), 
            %, *, /
            +, -
        Special numbers:
            Infinity & -Infinity: positive and negative infinity 
                Infinity - 1 is still infinity
                Infinity computation is NOT mathmatically solid 
            NaN: a value of number type, but Not-a-Number (NaN)
                Infinity - Infinity = NaN
                0 / 0 = NaN
    Strings
        string is written by enclosing content in single / double quotes
        escaping character with backslash (\)
            ex. \" a quote preceed by backslash will be part of string, instead of end it
                \n newline, \t tab 
        concatenates strings with + operator 
                
    Unary operators operates on one value
        "typeof" operator:
            typeof 3.5; // => "number"
        binary operator takes two values 
        minus operator can be both unary and binary operator 
    
    Boolean values: true & false
        Comparisons as a way to produce Boolean value
        Ex. 3 > 2; // => true
        Uppercase is always "LESS" than Lowercase
        string Comparison is based on Unicode standard (as a sequence of numbers)  
            - Goes over from left to right, one character at a time
        NaN: The only value in JavaScript that does not equal to itself (nonsensical computation)
        Logical operators: AND , OR, NOT
        precedence (low to high):
            || -> && -> comparison operators: >, ==, etc ->  others
        conditional operator / ternary operator: question mark and a colon 
            Ex. 
                console.log(true ? 1: 2);   // => 1
                console.log(false ? 1: 2);  // => 2

    Undefined values: null and undefined
        values without information - possiblely interchangeable?

    Automatic type conversion
        Ex.
            console.log(8 * null);      // => 0 (null becomes zero)
            console.log("5" - 1);       // => 4 ("5" becomes 5)
            console.log("5" + 1);       // => "51" (string concatenation)
            console.log("five" * 2);    // => NaN
            console.log(false == 0);    // => true    
        JS implicitly convert type of value when an operator is applied with values of mismatched type
        - type coercion 
        
        null and undefined 
        When null or undefined occurs on either side of ==
        The expression return true only if both side are null or undefined
        Ex.
            null == undefined;  // true
            null == 0;          // false
        To check if a value is null or undefined, compare it to null with == or !=
        To check for precise false, use !== and ===
        Use !== and === defensively tor prevent unexpected type conversions 

    Short-circuit of logical operator 
        && and || convert left operand to Boolean type
        based on operator and the result of conversion 
        than return either the original left operand value or the right operand value 
        || operator:
            return left operand if it can be converted to true 
            else return value of right operand 
            Ex. 
                null || "user";     // => "user"
                "Karl" || "user";   // => "Karl"
        && operator:
            return left operand if it can be converted to false
            else return value of right operand 
        For both operators, right operand may not be evaluated depend on the result of left operand conversion 
    Summary 
        - to negate number; ! to negate logically 

Ch 2 Program Structure 
    Expressions and statements 
        Expression = fragment of code that produce a value
        Statement can be expression followed by ;
        Statement has side-effect - change internal state of machine that affects other statement afterward 

    Variables: catch and hold values 
        Variable name:
            Not a reserved word 
            Not include space, punctuation other than $ or _
            Not start with digit 
        Variables grasp value, not contain value 
        A program can only access values it still has a hold on 
        Single var keyword can define multiple variables:
            Ex. 
                vra one = 1, two = 2;
                console.log(one + two); // 3

    Keywords and reserved words: some JS environment may allow reserved word as variable name
     
    The environment = 
        collection of variables and their values at a given time,
        conatins variables as part of the language standard 
  
    Functions 
        Function = a piece of grogram wrapped in a value
        Execute (function) is also invokeing, calling or applying (functions)
        Arguments = values given to function
    
    The console.log function
        console.log is an expression that retrives property from value held by the console variable 
        
    Return values 
        Display text or dialog box is a "side-effect"
        Function produces value by returning value 
        Anything produces value is an expression in JavaScript 

    prompt and confirm 
        confirm: 
            user click OK to return true
            user click Cancel to return false 
        prompt: 
            user input text, returned by prompt
                
    Control flow
        Ex. stright control flow
            var theNumber = Number(prompt("pick a number", ""));
            alert("Your number is the square root of " + theNumber * theNumber);
            Number convert string to a number; 
            Similar functions are String and Boolean that convert values to those types 

    Conditional execution - written with if keyword 
			Ex. 
				var theNumber = Number(prompt("Pick a number", ""));
        if (!isNaN(theNumber))
          alert("Your Number is the square root of " + theNumber * theNumber);

    while and do loops 
      Ex. 
        var number = 0;
        while (number <= 12) {
          console.log(number);
          number += 2;
        }
      block = a sequence of statements enclosed in braces

    Indenting Code 
    for loops 
    Breaking Out of a Loop 
    Updating variables succinctly 
    Dispatching on a value with switch 
    Capitalization 
    Comments 
  Summary 
    Exercises 
      Looping a triangle
      var line = "";
      for (var i = 0; i <= 6; ++i) {
        line += "*";
        for (var j = 0; j <= 6; ++j) {
          console.log(line + '\n');
        }
      }

      FizzBuzz    
      for (var i = 0; i <= 100; ++i) {
        if (i % 15 === 0) {
          console.log("FizzBuzz" + "\n");
        } else if (i % 5 === 0) {
          console.log("Buzz" + "\n");
        } else if (i % 3 === 0) {
          console.log("Fizz" + "\n");
        } else {
          console.log(i + "\n");
        }
      }

      Chess board
      var width = 8, height = 8;
      
      var oddLine = "";
      var evenLine = "";

      for (var i = 0; i < width; ++i) {
        if (i%2) {
          oddLine += "#";
          evenLine += " ";
        } else {
          oddLine += " ";
          evenLine += "#";
        }
      }

      for (var j = 0; j < height; ++j) {
        if (j%2) {
          console.log(evenLine);
        } else {
          console.log(oddLine);
        }
      }

Ch 3 Functions
  Function 
    - wrapping a piece of program in a value
      - to structure larger program 
      - to reduce repetition 
      - to associate names w/ subprograms
      - to isolate subprogram from each other 
  Defining a function
    Function definition = variable definition for a function
    Ex. a function that produces square of a given number 
      var square = function(x) {
        return x * x;
      };
      square(12); // => 144

    Function expression = an expression starts with keyword function
    Function has 0 to multiple parameters and body
    Body 
      - contains statement(s) to be executed when function is called 
      - enclosed within braces 
    keyword return
      - return value to calling code 
      - if not follow by expression, return "undefined" 
  Parameters and scopes 
    parameters 
      - like regular variables
      - initialized by caller of function
    parameters & other variable created inside function are "local" to the function
    variables created outside of any function are global
      - global variables can be accessed from inside of a function
       
  Nested scope: functions created within other functions producing several degrees of locality 
    - each local scope can also see all local scopes that contain it.

    Ex.
      var landscape = function() {
        result = "";
        var flat = function(size) {
          for (var count = 0; count < size; count++)
            result += "_";      
        };
        var mountain = function(size) {
          result += "/";
          for (var count = 0; count < size; count++) {
            result += "'";
          }
          result += "\\";
        };
      flat(3);
      mountain(4);
      flat(6);
      mountain(1);
      flat(1);
      return result;
    };

    console.log(landscape());

    Lexical scoping: Variables in function bodies and at the top level of the program are visible 
    Functions are the only thing that create a new scope 
    Use "let" for bloack scoping

  Functions as values: functions can be called or passed around like other values 
  
  Declaration notation 
    Function declaration with hoisting  
      Ex.
        function square(x) {
          return x * x;
        }
    Function declaration is automatically hoisted to the top of current scope 
    WARNING: DO NOT place function declaration inside an if block or loop!
      - Different browser / platforms behave differently
      - Forbidden by the standard!

  The call stack: where computer stores context of program flow 
    Everytime a function is called, the current context is put on top of "stack"
    When function returns, the top context is then removed from top of stack  
    , and then used to continue execution
  
    Store stack takes memory 
    When stack gets too big, computer fail with a message like "out of stack space" or "too much recursion"

    Ex. Recursion without kill condition 
      function chicken() {
        return egg();
      }
      function egg() {
        return chicken();
      }
      console.log(chicken() + " came first.");

  Optional Arguments 
    Extra parameters passed into a function are ignored
    If expected parameters are not passed into a function, the missing parameter is assigned with "undefined"
    CON: No warning for passing the wrong number of arguments to functions
    PRO: Enable "optional" arguments
    Ex.
      function power(base, exponent) {
        if (exponent == undefined) 
          exponent = 2; // if exponent is undefined, return base square
        var result = 1;
        for (var count = 0; count < exponent; count++) {
          result *= base;
        }
        return result;
      } 
      console.log(power(4));    // => 16
      console.log(power(4, 3)); // => 64 

  Closure: reference a specific instance of local variable within an enclosing function 
  Ex.
    function multiplier(factor) {
      return function(number) {
        return factor * number;
      };
    }

    var twice = multiplier(2);
    console.log(twice(5)); // => 10 

  Recursion - a function calls itself
    Ex. alternative implementation of power
      function power(base, exponent) {
        if (exponent === 0) 
          return 1; // 0th power of any base is 1
        else 
          return base * power(base, exponent - 1); 
      }
      console.log(power(2, 3)); // => 8
    Warning: in typical JavaScript implementation, 
      this is about 10 times slower than looping
    PRO:
      Some problems are much easier to solve with recursion than loop
      , like exploring or processing "branches", each branching out again into more branches
      Ex.
        function findSolution(target) {
          function find(start, history) {
            if (start === target) {
              return history;
            } else if (start > target) {
              return null;
            } else {
              return find(start + 5, "(" + history + " + 5)") || find(start * 3, "(" + history + " * 3)");
            }
          }
          return find(1, "1");
        }

        console.log(findSolution(24));
        // => (((1 * 3) + 5) * 3)

  Growing functions 
    The easier to find a good name for function, the better you understand the concept of the function
    Pick out single concept to extract function from complex logic
    Avoid to add cleverness unless it is absolutely needed 

  Functions and side effects 
    Two types of function (can be of both):
      1. called for side effect
      2. called for returned value
    Functions that return values are useful in more situations
    A pure function:
      - No side-effects
      - Independent from side effects of other code or global variables
      - When called with the same parameters, always returns the same value 
    However, use of side effect can sometimes be efficient

  Summary
    
  Exercises 
    Minimum
      function Minimum(first, second) {
        if (first === second) {
          return null;
        } else if (first < second) {
          return first;
        } else {
          return second;
        }
      }
      
    Recursion
      function isEven(num) {
        if (num === 0) {
          return true;
        } else if (num === 1) {
          return false;
        } else if (num > 0) {
          return isEven(num - 2);
        } else {
          return isEven(num + 2);
        }
      }

    Bean counting
      function countChar(token, char) {
        var result = 0;
        for (var count = 0; count < token.length; count++) {
          if (token.charAt(count) === char) {
            result++;
          }
        }
        return result;
      }
      function countBs(token) {
        return countChar(token, "B");
      }

Ch 4 Data Structures: Objects and Arrays
    The weresquirrel 
    Data sets 
    Properties 
    Methods 
    Objects 
    Mutability 
    The lycanthrope’s log 
    Computing correlation 
    Objects as maps 
    The final analysis 
    Further arrayology 
    Strings and their properties 
    The arguments object 
    The Math object 
    The global object 
    Summary 
    Exercises 
Ch 5 Higher-Order Functions 
    Abstraction 
    Abstracting array traversal 
    Higher-order functions 
    Passing along arguments 
    JSON 
    Filtering an array 
    Transforming with map 
    Summarizing with reduce 
    Composability 
    The cost 
    Great-great-great-great-… 
    Binding 
    Summary 
    Exercises 
Ch 6 The Secret Life of Objects
    History 
    Methods 
    Prototypes 
    Constructors 
    Overriding derived properties 
    Prototype interference 
    Prototype-less objects 
    Polymorphism 
    Laying out a table 
    Getters and setters 
    Inheritance 
    The instanceof operator 
    Summary 
    Exercises 
Ch 7 Project: Electronic Life
    Definition 
    Representing space 
    A critter’s programming interface 
    The world object 
    this and its scope 
    Animating life 
    It moves 
    More life forms 
    A more lifelike simulation 
    Action handlers 
    Populating the new world 
    Bringing it to life 
    Exercises 
Ch 8 Bugs and Error Handling 
    Programmer mistakes 
    Strict mode 
    Testing 
    Debugging 
    Error propagation 
    Exceptions 
    Cleaning up after exceptions 
    Selective catching 
    Assertions 
    Summary 
    Exercises 
Ch 9 Regular Expressions
    Creating a regular expression 
    Testing for matches 
    Matching a set of characters 
    Repeating parts of a pattern 
    Grouping subexpressions 
    Matches and groups 
    The date type 
    Word and string boundaries 
    Choice patterns 
    The mechanics of matching 
    Backtracking 
    The replace method 
    Greed 
    Dynamically creating RegExp objects 
    The search method 
    The lastIndex property 
    Parsing an INI file 
    International characters 
    Summary 
    Exercises 
Ch 10 Modules 
    Why modules help 
    Using functions as namespaces 
    Objects as interfaces 
    Detaching from the global scope 
    Evaluating data as code 
    Require 
    Slow-loading modules 
    Interface design 
    Summary 
    Exercises 
Ch 11 Project: A Programming Language
    Parsing 
    The evaluator 
    Special forms 
    The environment 
    Functions 
    Compilation 
    Cheating 
    Exercises 
Ch 12 JavaScript and the Browser
    Networks and the Internet 
    The Web 
    HTML 
    HTML and JavaScript 
    In the sandbox 
    Compatibility and the browser wars 
Ch 13 The Document Object Model
    Document structure 
    Trees 
    The standard 
    Moving through the tree 
    Finding elements 
    Changing the document 
    Creating nodes 
    Attributes 
    Layout 
    Styling 
    Cascading styles 
    Query selectors 
    Positioning and animating 
    Summary 
    Exercises 
Ch 14 Handling Events
    Event handlers 
    Events and DOM nodes 
    Event objects 
    Propagation 
    Default actions 
    Key events 
    Mouse clicks 
    Mouse motion 
    Scroll events 
    Focus events 
    Load event 
    Script execution timeline 
    Setting timers 
    Debouncing 
    Summary 
    Exercises 
Ch 15 Project: A Platform Game 
    The game 
    The technology 
    Levels 
    Reading a level 
    Actors 
    Encapsulation as a burden 
    Drawing 
    Motion and collision 
    Actors and actions 
    Tracking keys 
    Running the game 
    Exercises 
Ch 16 Drawing on Canvas 
    SVG 
    The canvas element 
    Filling and stroking 
    Paths 
    Curves 
    Drawing a pie chart 
    Text 
    Images 
    Transformation 
    Storing and clearing transformations 
    Back to the game 
    Choosing a graphics interface 
    Summary 
    Exercises 
Ch 17 HTTP 
    The protocol 
    Browsers and HTTP 
    XMLHttpRequest 
    Sending a request 
    Asynchronous Requests 
    Fetching XML Data 
    HTTP sandboxing 
    Abstracting requests 
    Promises 
    Appreciating HTTP 
    Security and HTTPS 
    Summary 
    Exercises 
Ch 18 Forms and Form Fields 
    Fields 
    Focus 
    Disabled fields 
    The form as a whole 
    Text fields 
    Checkboxes and radio buttons 
    Select fields 
    File fields 
    Storing data client-side 
    Summary 
    Exercises 
Ch 19 Project: A Paint Program 
    Implementation 
    Building the DOM 
    The foundation 
    Tool selection 
    Color and brush size 
    Saving 
    Loading image files 
    Finishing up 
    Exercises 
Ch 20 Node.js
    Background 
    Asynchronicity 
    The node command 
    Modules 
    Installing with NPM 
    The file system module 
    The HTTP module 
    Streams 
    A simple file server 
    Error handling 
    Summary 
    Exercises 
Ch 21 Project: Skill-Sharing Website 
    Design 
    Long polling 
    HTTP interface 
    The server 
    The client 
    Exercises 
    Program Structure 
    Functions 
    Data Structures: Objects and Arrays 
    Higher-Order Functions 
    The Secret Life of Objects 
    Project: Electronic Life 
    Bugs and Error Handling 
    Regular Expressions 
    Modules 
    Project: A Programming Language 
    The Document Object Model 
    Handling Events 
    Project: A Platform Game 
    Drawing on Canvas 
    HTTP 
    Forms and Form Fields 
    Project: A Paint Program 
    Node.js
    Project: Skill-Sharing Website 

