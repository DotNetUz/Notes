Ch 1 Values, Types, and Operators
    number 13 in bits => 
        1 1 0 1 => 
        1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 =
        8 + 4 + 1 = 13   
    Values: chunks of bits that represnt pieces of information
        6 basic types of value:
            numbers, strings, Boolean, object, functions and undefined values
    Numbers
        A single number is stored in 64 bits - which can represnt 2^64 different numbers 
        Overflow: a number does NOT fit into given amount of bits
        Represent nonwhole number: extra bit to store position of decimal point
        Negative number: one bit for sign of number
        Actual whole number (integer) can be precisely stored: 9 quadrillion 15 zeros   
        Scientific notation by "e", like 2.998e8 => 299,800,000
        Precision: many number lose precision with only 64 bit bits available 
        Treat fractional digits as approximation NOT precise number
        Arithmetic operator precedence: 
            (), 
            %, *, /
            +, -
        Special numbers:
            Infinity & -Infinity: positive and negative infinity 
                Infinity - 1 is still infinity
                Infinity computation is NOT mathmatically solid 
            NaN: a value of number type, but Not-a-Number (NaN)
                Infinity - Infinity = NaN
                0 / 0 = NaN
    Strings
        string is written by enclosing content in single / double quotes
        escaping character with backslash (\)
            ex. \" a quote preceed by backslash will be part of string, instead of end it
                \n newline, \t tab 
        concatenates strings with + operator 
                
    Unary operators operates on one value
        "typeof" operator:
            typeof 3.5; // => "number"
        binary operator takes two values 
        minus operator can be both unary and binary operator 
    
    Boolean values: true & false
        Comparisons as a way to produce Boolean value
        Ex. 3 > 2; // => true
        Uppercase is always "LESS" than Lowercase
        string Comparison is based on Unicode standard (as a sequence of numbers)  
            - Goes over from left to right, one character at a time
        NaN: The only value in JavaScript that does not equal to itself (nonsensical computation)
        Logical operators: AND , OR, NOT
        precedence (low to high):
            || -> && -> comparison operators: >, ==, etc ->  others
        conditional operator / ternary operator: question mark and a colon 
            Ex. 
                console.log(true ? 1: 2);   // => 1
                console.log(false ? 1: 2);  // => 2

    Undefined values: null and undefined
        values without information - possiblely interchangeable?

    Automatic type conversion
        Ex.
            console.log(8 * null);      // => 0 (null becomes zero)
            console.log("5" - 1);       // => 4 ("5" becomes 5)
            console.log("5" + 1);       // => "51" (string concatenation)
            console.log("five" * 2);    // => NaN
            console.log(false == 0);    // => true    
        JS implicitly convert type of value when an operator is applied with values of mismatched type
        - type coercion 
        
        null and undefined 
        When null or undefined occurs on either side of ==
        The expression return true only if both side are null or undefined
        Ex.
            null == undefined;  // true
            null == 0;          // false
        To check if a value is null or undefined, compare it to null with == or !=
        To check for precise false, use !== and ===
        Use !== and === defensively tor prevent unexpected type conversions 

    Short-circuit of logical operator 
        && and || convert left operand to Boolean type
        based on operator and the result of conversion 
        than return either the original left operand value or the right operand value 
        || operator:
            return left operand if it can be converted to true 
            else return value of right operand 
            Ex. 
                null || "user";     // => "user"
                "Karl" || "user";   // => "Karl"
        && operator:
            return left operand if it can be converted to false
            else return value of right operand 
        For both operators, right operand may not be evaluated depend on the result of left operand conversion 
    Summary 
        - to negate number; ! to negate logically 

Ch 2 Program Structure 
    Expressions and statements 
        Expression = fragment of code that produce a value
        Statement can be expression followed by ;
        Statement has side-effect - change internal state of machine that affects other statement afterward 

    Variables: catch and hold values 
        Variable name:
            Not a reserved word 
            Not include space, punctuation other than $ or _
            Not start with digit 
        Variables grasp value, not contain value 
        A program can only access values it still has a hold on 
        Single var keyword can define multiple variables:
            Ex. 
                vra one = 1, two = 2;
                console.log(one + two); // 3

    Keywords and reserved words: some JS environment may allow reserved word as variable name
     
    The environment = 
        collection of variables and their values at a given time,
        conatins variables as part of the language standard 
  
    Functions 
        Function = a piece of grogram wrapped in a value
        Execute (function) is also invokeing, calling or applying (functions)
        Arguments = values given to function
    
    The console.log function
        console.log is an expression that retrives property from value held by the console variable 
        
    Return values 
        Display text or dialog box is a "side-effect"
        Function produces value by returning value 
        Anything produces value is an expression in JavaScript 

    prompt and confirm 
        confirm: 
            user click OK to return true
            user click Cancel to return false 
        prompt: 
            user input text, returned by prompt
                
    Control flow
        Ex. stright control flow
            var theNumber = Number(prompt("pick a number", ""));
            alert("Your number is the square root of " + theNumber * theNumber);
            Number convert string to a number; 
            Similar functions are String and Boolean that convert values to those types 

    Conditional execution - written with if keyword 
			Ex. 
				var theNumber = Number(prompt("Pick a number", ""));
        if (!isNaN(theNumber))
          alert("Your Number is the square root of " + theNumber * theNumber);

    while and do loops 
      Ex. 
        var number = 0;
        while (number <= 12) {
          console.log(number);
          number += 2;
        }
      block = a sequence of statements enclosed in braces

    Indenting Code 
    for loops 
    Breaking Out of a Loop 
    Updating variables succinctly 
    Dispatching on a value with switch 
    Capitalization 
    Comments 
  Summary 
    Exercises 
      Looping a triangle
      var line = "";
      for (var i = 0; i <= 6; ++i) {
        line += "*";
        for (var j = 0; j <= 6; ++j) {
          console.log(line + '\n');
        }
      }

      FizzBuzz    
      for (var i = 0; i <= 100; ++i) {
        if (i % 15 === 0) {
          console.log("FizzBuzz" + "\n");
        } else if (i % 5 === 0) {
          console.log("Buzz" + "\n");
        } else if (i % 3 === 0) {
          console.log("Fizz" + "\n");
        } else {
          console.log(i + "\n");
        }
      }

      Chess board
      var width = 8, height = 8;
      
      var oddLine = "";
      var evenLine = "";

      for (var i = 0; i < width; ++i) {
        if (i%2) {
          oddLine += "#";
          evenLine += " ";
        } else {
          oddLine += " ";
          evenLine += "#";
        }
      }

      for (var j = 0; j < height; ++j) {
        if (j%2) {
          console.log(evenLine);
        } else {
          console.log(oddLine);
        }
      }

Ch 3 Functions
  Function 
    - wrapping a piece of program in a value
      - to structure larger program 
      - to reduce repetition 
      - to associate names w/ subprograms
      - to isolate subprogram from each other 
  Defining a function
    Function definition = variable definition for a function
    Ex. a function that produces square of a given number 
      var square = function(x) {
        return x * x;
      };
      square(12); // => 144

    Function expression = an expression starts with keyword function
    Function has 0 to multiple parameters and body
    Body 
      - contains statement(s) to be executed when function is called 
      - enclosed within braces 
    keyword return
      - return value to calling code 
      - if not follow by expression, return "undefined" 
  Parameters and scopes 
    parameters 
      - like regular variables
      - initialized by caller of function
    parameters & other variable created inside function are "local" to the function
    variables created outside of any function are global
      - global variables can be accessed from inside of a function
       
  Nested scope: functions created within other functions producing several degrees of locality 
    - each local scope can also see all local scopes that contain it.

    Ex.
      var landscape = function() {
        result = "";
        var flat = function(size) {
          for (var count = 0; count < size; count++)
            result += "_";      
        };
        var mountain = function(size) {
          result += "/";
          for (var count = 0; count < size; count++) {
            result += "'";
          }
          result += "\\";
        };
      flat(3);
      mountain(4);
      flat(6);
      mountain(1);
      flat(1);
      return result;
    };

    console.log(landscape());

    Lexical scoping: Variables in function bodies and at the top level of the program are visible 
    Functions are the only thing that create a new scope 
    Use "let" for bloack scoping

  Functions as values: functions can be called or passed around like other values 
  
  Declaration notation 
    Function declaration with hoisting  
      Ex.
        function square(x) {
          return x * x;
        }
    Function declaration is automatically hoisted to the top of current scope 
    WARNING: DO NOT place function declaration inside an if block or loop!
      - Different browser / platforms behave differently
      - Forbidden by the standard!

  The call stack: where computer stores context of program flow 
    Everytime a function is called, the current context is put on top of "stack"
    When function returns, the top context is then removed from top of stack  
    , and then used to continue execution
  
    Store stack takes memory 
    When stack gets too big, computer fail with a message like "out of stack space" or "too much recursion"

    Ex. Recursion without kill condition 
      function chicken() {
        return egg();
      }
      function egg() {
        return chicken();
      }
      console.log(chicken() + " came first.");

  Optional Arguments 
    Extra parameters passed into a function are ignored
    If expected parameters are not passed into a function, the missing parameter is assigned with "undefined"
    CON: No warning for passing the wrong number of arguments to functions
    PRO: Enable "optional" arguments
    Ex.
      function power(base, exponent) {
        if (exponent == undefined) 
          exponent = 2; // if exponent is undefined, return base square
        var result = 1;
        for (var count = 0; count < exponent; count++) {
          result *= base;
        }
        return result;
      } 
      console.log(power(4));    // => 16
      console.log(power(4, 3)); // => 64 

  Closure: reference a specific instance of local variable within an enclosing function 
  Ex.
    function multiplier(factor) {
      return function(number) {
        return factor * number;
      };
    }

    var twice = multiplier(2);
    console.log(twice(5)); // => 10 

  Recursion - a function calls itself
    Ex. alternative implementation of power
      function power(base, exponent) {
        if (exponent === 0) 
          return 1; // 0th power of any base is 1
        else 
          return base * power(base, exponent - 1); 
      }
      console.log(power(2, 3)); // => 8
    Warning: in typical JavaScript implementation, 
      this is about 10 times slower than looping
    PRO:
      Some problems are much easier to solve with recursion than loop
      , like exploring or processing "branches", each branching out again into more branches
      Ex.
        function findSolution(target) {
          function find(start, history) {
            if (start === target) {
              return history;
            } else if (start > target) {
              return null;
            } else {
              return find(start + 5, "(" + history + " + 5)") || find(start * 3, "(" + history + " * 3)");
            }
          }
          return find(1, "1");
        }

        console.log(findSolution(24));
        // => (((1 * 3) + 5) * 3)

  Growing functions 
    The easier to find a good name for function, the better you understand the concept of the function
    Pick out single concept to extract function from complex logic
    Avoid to add cleverness unless it is absolutely needed 

  Functions and side effects 
    Two types of function (can be of both):
      1. called for side effect
      2. called for returned value
    Functions that return values are useful in more situations
    A pure function:
      - No side-effects
      - Independent from side effects of other code or global variables
      - When called with the same parameters, always returns the same value 
    However, use of side effect can sometimes be efficient

  Summary
    
  Exercises 
    Minimum
      function Minimum(first, second) {
        if (first === second) {
          return null;
        } else if (first < second) {
          return first;
        } else {
          return second;
        }
      }
      
    Recursion
      function isEven(num) {
        if (num === 0) {
          return true;
        } else if (num === 1) {
          return false;
        } else if (num > 0) {
          return isEven(num - 2);
        } else {
          return isEven(num + 2);
        }
      }

    Bean counting
      function countChar(token, char) {
        var result = 0;
        for (var count = 0; count < token.length; count++) {
          if (token.charAt(count) === char) {
            result++;
          }
        }
        return result;
      }
      function countBs(token) {
        return countChar(token, "B");
      }

Ch 4 Data Structures: Objects and Arrays
  Objects group values

  The weresquirrel 

  Data sets 
    Array - a list of values b/t square brackets, separated by commas
    Access element with index: listofNumbers[0]
  
  Properties 
    Except null and undefined, all JS values have properties
    Two common ways to access properties:
      1. dot notation: 
        value.x gets the property of value called "x"
      2. square brackets:
        value[x] tries to evaluate expression x and use the result as the property name 
      If the propery name is NOT a valid variable name, it can ONLY be accessed by square brackets

  Methods
    In addition to length property, both string and array contains properties referring to function values
    Ex. toUpperCase as a string's property of function value type
      var doh = "Doh";
      console.log(typeof doh.toUpperCase);  // => function
      console.log(doh.toUpperCase());       // => "DOH"
    Methods = Properties containing functions
      Ex.
        push  - Add value to the end of array
        pop   - Remove and return value from the end of array
        join  - return a string with all array elements connected by provided 
  Objects
    Object = arbitrary collection of properties, added or removed as needed
    Properties whose names are not valid variable names or valid numbers have to be quoted
    Two usages of curly braces:
      1. start a block of statements
      2. describe objects
    Access a non-existing property produce value "undefined"
    Assign an existing property with "=" operator repaces the property's value
    Assign a non-existing property with "=" operator creates a new property
    Apply unary operator "delete" to remove named property from an object
      Ex.
        var anObject = {left:1, right:2};
        delete anObject.left;
    Check if an object has specified property with binary "in" operator
    Ex.
      console.log("right" in anObject); // => true
      console.log("left" in anObject); // => false
    Array = object for storing sequence of things
    Ex. 
      typeof [1, 2];  // => "object"  

  Mutability
    values such as string, number or Booleans are immutable 
    - they can be combined to derive new values 
    - However, a specific value will always remain the same 

    == operator 
      return true when comparing the same object
      return false when comparing different objects, even with same content 
      No deep comparison built into JS

  The lycanthrope’s log 
    Correlation = measure dependence b/t Variables, usually from -1 to 1
    Zero correlation = two variables are not related
    One correlation = two variables are perfectly related
    Negative one correlation = two variables are perfectly related in opposite (one true; one false)

    phi(φ) coefficient = correlation for binary variables

    phi = (n11n00 - n10n01) / (n1x*n0x*nx1*nx0) ^ (1/2) 

    n11: Squirrel, pizza        - 1   => table[3]
    n00: No squirrel, no pizza  - 76  => table[0]
    n01: No squirrel, pizza     - 9   => table[1]
    n10: Squirrel, no pizza     - 4   => table[2]

    n1x: all Squirrel regardless pizza -> (4+1) = 5
    n0x: all No squirrel regardless pizza -> (76+9) = 85
    nx1: all pizza, regardless squirrel -> (9+1) = 10
    nx0: all No pizza, regardless squirrel -> (76+4) = 80

    phi is about 0.069

  Computing correlation 
    All results can be grouped as four element array ([76, 9, 4, 1]), from 00, 01, 10, 11
    phi can be calculated as following:
    Ex.
      function phi(table) {
        return (table[3] * table[0] - table[2] * table[1]) / 
          Math.sqrt((table[2] + table[3]) *
                    (table[0] + table[1]) *
                    (table[1] + table[3]) *
                    (table[0] + table[2])
            );
      }
      console.log(phi([76, 9, 4, 1]));  // => 0.068599434

    To sum up all combination of a specific event v. squirrel incident
    Ex.
      function hasEvent(event, entry) {
        return entry.events.indexOf(event) != -1;
        // if an event does not exist in "events" indexOh() returns -1
      }   
      function tableFor(event, journal) {
        var table = [0, 0, 0, 0]; // before lopping, initialize an empty table
        for (var i = 0; i < journal.length; i++) {
          var entry = journal[i], index = 0;  // iterate through each entry in journal, default: no event, no squirrel incident
          if (hasEvent(event, entry)) index += 1;
          if (entry.squirrel) index += 2;
          table[index] += 1;  // add entry to one of the expected categories 
        }
        return table;
      }
      console.log(tableFor("pizza", JOURNAL));  // => [76, 9, 4, 1]
  
  Objects as maps
    One possible way of storing records is to store records in an array 
      - but lookup for a particular entry can be cumbersome
      - require looping over the whole array
    A better way:
      Store records as named properties in an object
      - create / access via []
      - check for property with "in" operator 
    Ex.
      var map = {};
      function storePhi(event, phi) {
        map[event] = phi;
      }

      storePhi("pizza", 0.069);
      storePhi("touched tree", -0.081);
      console.log("pizza" in map);    // => true
      console.log(map["touched tree"]);  // => -0.081

    A map correlates values in one domain with another
    Ex.
      for (var event in map) {
        console.log("The correlation of '" + event + "' is " + map[event]);
      }  
    
  The final analysis 
    [Require Journal records]

  Further arrayology - some general array methods
    shift() & unshift()
    Ex.
      var todoList = [];
      function rememberTo(task) {
        todoList.push(task);
      }
      function whatIsNext() {
        return todoList.shift();  // remove from front of array
      }
      function urgentlyRememberTo(task) {
        todoList.unshift(task); // add from front of array
      }
    
    indexOf() & lastIndexOf()
      indexOf() / lastIndexOf() returns index of the first / last occurrence in array
      both take second parameter as alternative index to start from 
      only works against primitive types in array
    Ex. 
      console.log([1, 2, 3, 2, 1].indexOf(2));      // => 1
      console.log([1, 2, 3, 2, 1].lastIndexOf(2));  // => 3
      console.log([1, 2, 3, 2, 1].indexOf(2, 2));   // => 3

    find() & findIndex() to search for reference type in array

      find() returns value of first element in array 
      that satisfies the provided testing function 
      Ex. 
        var data = [[1, 2], [3, 4]];
        
        function propertyZeroIsThree(item) {
          return item[0] === 3;
        }

        var found = data.find(propertyZeroIsThree);
        console.log(found); // => [3, 4] 

      findIndex() returns index of first element in array 
      that satisfies the provided testing function
      Ex.
        var data = [[1, 2], [3, 4]];
        
        function propertyZeroIsThree(item) {
          return item[0] === 3;
        }

        var found = data.findIndex(propertyZeroIsThree);
        console.log(found); // => 1
    
    slice()
      takes one argument: return a new array starting from index given to the end of array
      takes two arguments: start and end index and return a new array 
      from start index to (end index - 1)
      Ex.
        console.log([0, 1, 2, 3, 4].slice(2, 4)); // => [2, 3]
        console.log([0, 1, 2, 3, 4].slice(2)); // => [2, 3, 4]
    
    connect()
      takes an array and return a new array with calling array followed by array passing in 
      similar to + with string
      Ex. remove one element at index provided
        function remove (array, index) {
          return array.slice(0, index).concat(
            array.slice(index + 1)
          );
        }
        console.log(remove([0, 1, 2, 3, 4], 2)); // => [0, 1, 3, 4]

  Strings and their properties 
    slice() & indexOf() works the same way as array
    but indexOf() can take string with more than one character 
    Ex.
      console.log("coconuts".slice(4, 7));    // nut
      console.log("coconuts".indexOf("nu"));  // => 4

    trim() from both ends of string, but not the space in between non-whaitespace characters
    Ex. 
      console.log("  o kay \n ".trim()); // => "o kay"
      
    length property, charAt() and []
    Ex.
      var string = "abc";
      console.log(string.length);     // => 3
      console.log(string.charAt(0));  // => a
      console.log(string[1]);         // => b

  The arguments object
    Every function has "arguments" property
    "arguments" is an object that holds all arguments passing in 
    Function can take more or fewer arguments than specified parameters 
    The arguments object has length property for the number of arguments been passed in 
    Hoever, arguments is NOT an array -> No slice() or indexOf()
    Ex.
      function argCounter() {
        console.log("There are", arguments.length, "argument\(s\)." )
      }
      argCounter("one", "two", "three");  // => There are 3 argument(s).

  The Math object
    Math.max
    Math.min
    Math.sqrt

    Math.sin / Math.asin
    Math.cos / Math.acos
    Math.tan / Math.atan

    Math.PI
    Ex. Given a circle with specified radius, center at (0,0), return a random point along the circle
      function randomPointOnCircle(radius) {
        var angle = Math.random() * 2 * Math.PI;  // a random angle in radians 
        return {
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)
        };
      }
      console.log(randomPointOnCircle(2)); // => {x: -0.8981896522765914, y: -1.7869682002048206}

    Math object acts as namespace so that these functions and values do not have to be global variables 
    Warning: JavaScript does not stop or warn against duplicated variable!!!

    Math.random() returns a pseudorandom number between zero (inclusive) and one (exclusive) => [0,1)
    Math.floor() round down to the nearest whole number
    Math.ceil() round up to the nearest whole number
    Math.round() round to nearest whole number => round up on .5+, else round down

  The global object 
    A global variable can be used as a property of global object
    In browser, global object is "window" variable
    Ex.
      var myVar = 10;
      console.log("myVar" in window); // => true
      console.log(window.myVar);  // => 10

  Summary 
    Array and object both group values
    Other than null and undefined, values in JavaScript has properties
    Properties are accessed via dot notation and [] notation
    Methods are properties with values that are functions
    Objects can also be map, assoicating values with name
    "in" Operator 
      checks if an object holds a property with given name
      used by for loop  - for (var name in object) - to loop over object's properties 

  Exercises 
    The sum of a range
      function range(start, end, step) {
        if (step === undefined) {
          let array = [];
          while (start <= end) {
            array.push(start++);
          }
          return array;
        } else {
          if (step < 0) {
            // desending
            if (start < end) {
              return undefined
            } else {
              let array = [];
              while (start >= end) {
                array.push(start);                
                start += step;
                
              }
              return array;
            }
          } else if (step > 0) {
            // asending
            if (start > end) {
              return undefined
            } else {
              let array = [];
              while (start <= end) {
                array.push(start);                
                start += step;
              }
              return array;
            }
          } else {
            return undefined;
          }
        }
      }
      function sum(a) {
        var result = 0;
        for (var i = 0; i < a.length; i++) {
          result += a[i];
        }
        return result;
      }

    Reversing an array
      function reverseArray(array) {
        var newArray = [];
		    var initialArrayLength = array.length;
        for (var i = 0; i < initialArrayLength; i++) {
          newArray.push(array.pop());
        }
        return newArray;
      }
      function reverseArrayInPlace(array) {
        if (array.length % 2 === 0) {
          // even
          var switchRange= array.length / 2;
          for (var i = 0; i < switchRange; i++) {
            var temp = array[i];
            array[i] = array[array.length - 1 - i];
            array[array.length - i] = temp;
          }
        } else {
          // odd
          var switchRange = Math.floor(array.length / 2);
          for (var i = 0; i < switchRange; i++) {
            var temp = array[i];
            array[i] = array[array.length - 1 - i];
            array[array.length - i] = temp;
          }
        }
      }

    A list
      

    Deep comparison
    
Ch 5 Higher-Order Functions 
- Break down a solution into simpler concept that is represnted as separate functions 
    Abstraction - hide details and allow problems be addressed at a higher level  
      Programer needs to abstract concept effortlessly 

    Abstracting array traversal 

    Higher-order functions 
      Higher-order functions 
        - take functions as arguments or return functions
        - abstract over actions 
      Ex. 
        function greaterThan(n) {
          return function(m) {return m > n; }
        }
        var greaterThan10 = greaterThan(10);
        console.log(greaterThan10(11)); // => true
      
      Ex. functions that change other functions
        // Boolean() function checks if an argument expression is true
        function noisy(f) {
          return function(arg) {
            console.log("calling with", arg);
            var val = f(arg);
            console.log("called with", arg, "- got ", val);
            return val;
          };
        }
        noisy(Boolean)(0);
        // => "calling with 0"
        // => "called with 0 - got flase"
        // => false    
      
      Ex. functions /w new flow of control
        function unless(test, then) {
          if (!test) then();
        }
        function repeat(times, body) {
          for (var i = 0; i < times; i++) body(i);
        }
        repeat(3, function(n){
          unless(n%2, function() {
            console.log(n, "is even");
          });
        });
        // => 0 "is even"
        // => 2 "is even"
        
    Passing along arguments 
      apply() methof of JavaScript function
      ex.
        function transparentWrapping(f) {
          return function() {
            return f.apply(null, arguments);
          };
        }
        // the returned function passes all given argument to f
        // The first argument of apply(), null, simulate a method call
      
    JSON - JavaScript Object Notation
      - All property names are enclosed by double quotes 
      - Only simple data expression / No function calls, variable or computation 
      - No comments allowed within JSON

      JSON.stringfy() convert data into JSON
      Ex.
        var string = JSON.stringify({name: "X", born: 1980});
        console.log(string);  // => {"name": "X", "born": 1980} 

      JSON.parse() extract data from JSON
      Ex. 
        console.log(JSON.parse(string).born); // => 1980

    Filtering an array 
    Transforming with map 
    Summarizing with reduce 
    Composability 
    The cost 
    Great-great-great-great-… 
    Binding 
    Summary 
    Exercises 
Ch 6 The Secret Life of Objects
    History 
    Methods 
    Prototypes 
    Constructors 
    Overriding derived properties 
    Prototype interference 
    Prototype-less objects 
    Polymorphism 
    Laying out a table 
    Getters and setters 
    Inheritance 
    The instanceof operator 
    Summary 
    Exercises 
Ch 7 Project: Electronic Life
    Definition 
    Representing space 
    A critter’s programming interface 
    The world object 
    this and its scope 
    Animating life 
    It moves 
    More life forms 
    A more lifelike simulation 
    Action handlers 
    Populating the new world 
    Bringing it to life 
    Exercises 
Ch 8 Bugs and Error Handling 
    Programmer mistakes 
    Strict mode 
    Testing 
    Debugging 
    Error propagation 
    Exceptions 
    Cleaning up after exceptions 
    Selective catching 
    Assertions 
    Summary 
    Exercises 
Ch 9 Regular Expressions
    Creating a regular expression 
    Testing for matches 
    Matching a set of characters 
    Repeating parts of a pattern 
    Grouping subexpressions 
    Matches and groups 
    The date type 
    Word and string boundaries 
    Choice patterns 
    The mechanics of matching 
    Backtracking 
    The replace method 
    Greed 
    Dynamically creating RegExp objects 
    The search method 
    The lastIndex property 
    Parsing an INI file 
    International characters 
    Summary 
    Exercises 
Ch 10 Modules 
    Why modules help 
    Using functions as namespaces 
    Objects as interfaces 
    Detaching from the global scope 
    Evaluating data as code 
    Require 
    Slow-loading modules 
    Interface design 
    Summary 
    Exercises 
Ch 11 Project: A Programming Language
    Parsing 
    The evaluator 
    Special forms 
    The environment 
    Functions 
    Compilation 
    Cheating 
    Exercises 
Ch 12 JavaScript and the Browser
    Networks and the Internet 
    The Web 
    HTML 
    HTML and JavaScript 
    In the sandbox 
    Compatibility and the browser wars 
Ch 13 The Document Object Model
    Document structure 
    Trees 
    The standard 
    Moving through the tree 
    Finding elements 
    Changing the document 
    Creating nodes 
    Attributes 
    Layout 
    Styling 
    Cascading styles 
    Query selectors 
    Positioning and animating 
    Summary 
    Exercises 
Ch 14 Handling Events
    Event handlers 
    Events and DOM nodes 
    Event objects 
    Propagation 
    Default actions 
    Key events 
    Mouse clicks 
    Mouse motion 
    Scroll events 
    Focus events 
    Load event 
    Script execution timeline 
    Setting timers 
    Debouncing 
    Summary 
    Exercises 
Ch 15 Project: A Platform Game 
    The game 
    The technology 
    Levels 
    Reading a level 
    Actors 
    Encapsulation as a burden 
    Drawing 
    Motion and collision 
    Actors and actions 
    Tracking keys 
    Running the game 
    Exercises 
Ch 16 Drawing on Canvas 
    SVG 
    The canvas element 
    Filling and stroking 
    Paths 
    Curves 
    Drawing a pie chart 
    Text 
    Images 
    Transformation 
    Storing and clearing transformations 
    Back to the game 
    Choosing a graphics interface 
    Summary 
    Exercises 
Ch 17 HTTP 
    The protocol 
    Browsers and HTTP 
    XMLHttpRequest 
    Sending a request 
    Asynchronous Requests 
    Fetching XML Data 
    HTTP sandboxing 
    Abstracting requests 
    Promises 
    Appreciating HTTP 
    Security and HTTPS 
    Summary 
    Exercises 
Ch 18 Forms and Form Fields 
    Fields 
    Focus 
    Disabled fields 
    The form as a whole 
    Text fields 
    Checkboxes and radio buttons 
    Select fields 
    File fields 
    Storing data client-side 
    Summary 
    Exercises 
Ch 19 Project: A Paint Program 
    Implementation 
    Building the DOM 
    The foundation 
    Tool selection 
    Color and brush size 
    Saving 
    Loading image files 
    Finishing up 
    Exercises 
Ch 20 Node.js
    Background 
    Asynchronicity 
    The node command 
    Modules 
    Installing with NPM 
    The file system module 
    The HTTP module 
    Streams 
    A simple file server 
    Error handling 
    Summary 
    Exercises 
Ch 21 Project: Skill-Sharing Website 
    Design 
    Long polling 
    HTTP interface 
    The server 
    The client 
    Exercises 
    Program Structure 
    Functions 
    Data Structures: Objects and Arrays 
    Higher-Order Functions 
    The Secret Life of Objects 
    Project: Electronic Life 
    Bugs and Error Handling 
    Regular Expressions 
    Modules 
    Project: A Programming Language 
    The Document Object Model 
    Handling Events 
    Project: A Platform Game 
    Drawing on Canvas 
    HTTP 
    Forms and Form Fields 
    Project: A Paint Program 
    Node.js
    Project: Skill-Sharing Website 

