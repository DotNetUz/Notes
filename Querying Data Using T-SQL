Module 1 Course Overview
  SQL is around for 50+ years 
  How SQL work > Syntax
  Logical challenges & pitfall

  SQL Terminology & Tools
  Intricacies of SQL
  Underlying concepts of SQL & Relational Model counter part
  How data is processed by every clause of SELECT query
  How to prepare source data, filter it effectively 
  How to handle complications of missing data
  How to combine multiple Rows
  How to support presentation, ordering and paging and when NOT to   

Module 2 What Is T-SQL?
  Module Introduction
    Terminology
    Architectural Overview
    Tools

  What Is T-SQL?
    Standardized by ANSI and ISO
    1st edition published in 1986, latest in 2019
    Each vandor uses subset of and extensions to ANSI SQL standard 
    T-SQL = Transact SQL 
      used by Microsoft SQL Server and Sybase
    
    MS SQL Server = relational DB management system (RDBMS)
    Other types of Database Management System (DBMS) include:
      Hierarchal
      Object-oriented 
      Document stores 
      Key value stores
      Graph database

    Relational model  
      a data modeling paradigm based on set theory and first order predicate logic

    What is DB? Simon Allardice's 'Databases - executive briefing'

  A Little SQL Server Architecture
    SQL Server => SQL Server Services
      Core SQL DB Engine
      Macine learning 
      Integration Analysis 
      Reporting 
      Replication
      Others 

    Core SQL DB Engine can be installed on 
      Windows / Linux OS
      Docker container

    Most Cloud provider offer SQL Server as a managed cloud product 
    MS Azure has Azure SQL DB, a SQL Server DB in a platform as a Service 

    SQL Server is 
      a multi-user server
      communicated via TCP / IP port

    User and application servers use API to send queries to server and receive results from network

    Two authentication methods for users and application clients
      SQL Authentication - login credential stored internally 
      Windows Authentication - Active Directory for single sign-on scenario

    SQL Server Object Hierarchy
      OS contains 1 or more ...
      SQL Server Instance that contains 1 or more ...
      Database that contains 1 or more ...
      Schema that contains ...
      Object(s) like
        Table
        View
        Store Procedure
        others    

    Fully Qualified Object Names
      Can access every object
      Consist of 4 parts: [Instance].[Database].[Schema].Object

    Omit 
      Instance - use current instance connection
      Database - use current session's DB context
      Schema   - use dbo (database owner) or explicit default schema

  Tools
    SQL Server Instance: azure sql database also available  
    Client IDE: SSMS or Azure Data Studio
    Online tools - No persist data:
      www.sbfiddle.uk
      www.sqlfiddle.com

  Demo: Tools
  Module Review

Module 3 Our First SELECT
  Module Introduction
    Query execution order
    Terminology 
      Sets
      Expressions
      Operators
      Functions
      Aliases
      Data types
    SELECT without FROM
  What Is a SQL Query?
    Complete list of SQL clause (caluse = part of a sentence that contains a verb):
      (5) SELECT          - List of expressions to return
      (1) FROM            - Source data set, the ONLY data available for all following clauses 
      (2) WHERE           - Filter rows with predicate (a Boolean function that can return True or False)  
      (3) GROUP BY        - Rows combined into groups based on grouping expression
      (4) HAVING          - Filter whole groups instead of rows
      (6) ORDER BY        - Sort for presentation order
      (7) OFFSET - FETCH  - page specification; limit numbers of rows that will be returned 

  More Terminology
    Set - a collection of unique elements with No order (neither for Row, nor for Column); also an element on its own
    Relation - how a subset of elements related to each other which form a meaningful unit (Table)
    Tuples - a finite ordered list of elements of a relation; AKA Rows 
    Rows - unique and have NO order 
    Key - attribute(s) that ensure uniqueness of Rows, like name, ISBN or order number
    Tuple - attribute, known as Column in SQL 
    Alias 
      - name to hold datasets or individual expressions
      - by default Alias is an object's name, like "Employees" table
      - any expression involve more than just base column lose column alias (AS)

    SQL is a Stringly Typed language = every expression in SQL has a specific data type
      Numeric - integers, decimals and floating-point types
      String  - encoded in ASCII or Unicode 
      Binary  - technically a string, but usually used to store images, video and audio 
      Temporal- Time-related attributes, like date, time or combinations 
     
      Special Data Types
        Hierarchy
        Spatial
        Unstructured data type / Document (XML / JSON)
      
      What is NOT in T-SQL
        Interval  - timespan
        Boolean   - use Bit (numeric type) instead
      
      Operators and Functions
        Creates new expressions from existing ones
          Arithmetic: + - * / %
          String: SUBSTRING, UPPER, LTRIM, + 
          Date & Time: GETDATE, YEAR, DATEDIFF, DATEADD
          Bitwise: &, ^, |, ~
          Comparison: >, <, <>, =, !=, LIKE
          Logical: AND, OR, NOT, IN, ANY, BETWEEN

        User-defined functions

  Demo: First SELECT
    SELECT without FROM
    Examples:
      SELECT 'X'; -- return single row with single column and the value string 'X'
      SELECT X; -- SQL will evaluate X as identifier / alias (for a column) and gets an error b/c X does not exist
      
      SELECT 2 * 7, SQRT(2); 
        -- Expression can contains multiple sub-expressions w/ operators 
        -- separate by comma cause each one to be returned as a separate column of the reults set
      
      SELECT 2 * 7 AS Easy, SQRT(2) AS LessEasy;
        -- Use keyword AS to assign alias(column name) to expressions 

      SELECT 7 / 2; -- return 3 (integer)

      SELECT 7 / 2 * 1.00; -- return 3.00; be aware of Operator Precedence 

      SELECT 7 / (2 * 1.00); -- return 3.50  

    The preferred method to process decimal is use CAST()
      CAST() convert expression from one type to another
        CAST( expression AS datatype(length) )
      SELECT CAST(7 AS DECIMAL(5,2)) / 2; -- return 3.50
    
    Always use ISO format (YYYYMMDD) when CAST string into DATE type
      SELECT CAST('20191218' AS DATE) AS TODAY;

    Avoid implicit conversion in SQL
      SELECT '4' + 4; -- return intteger 8

  Module Review

Module 4 The FROM Clause
  Module Introduction
    FROM clause - evaluation of the source dataset of any query 
    SELECT FROM single source set (table)
    SELECT FROM multiple source sets (tables)

  TSQL Demo Database
    Create Demo DB with script "Module 4 - TSQL Demo DB.sql"
    Table:
      Customers
        Customers' name as key (key icon is SSMS) and field "Country"  
        No customer ID or number - avoid surrogate keys or ids for every table
        Customer ID will not likely to be used to refer to the customer in real world 
        ??? QUESTION: How to uniquely, concisely identify numerous customers without using ID? Composite Attribute?
      Orders
        Autogenerated OrderID as primary key: 
          OrderID is used elsewhere once generated
          OrderID is used to IDENTIFY order by customers and seller - a valid attribute of order itself 
          Customer field is SQL foreign key 
            A foreign key is the counterpart of the relational models referential integrity constraint 
            - Enforce the rule that only valid customers in Customers table can place order
      Items:
        Item is the key and second attribute is "Color"
      Order Items:
        Contains all the items sold in each order
        2 foreign keys: OrderID and Item - ensure both OrderID and Item are valid 
    
  Demo: FROM Single Table
    Example 1
      SELECT *
      FROM Customers; -- Do NOT use this in production

    1. Customers table is evaluated by FROM caluse (the source set)
    2. Customers table is then evaluated by SELECT clause
    3. SELECT clause evaluate EACH ROW from source set to construct the results 

    Example 2
      SELECT 'Pluralsight' AS BestTraining 
      FROM Customers;

    1. Customers table is evaluated by FROM caluse
    2. Then the source set is evaluated in SELECT clause 
    3. Expression in SELECT clause is evaluated for EACH ROW
    4. Expression can be columns from table OR literal constant like a string   
    5. Result set has same number of rows as Customers table under column name 'BestTraining', each display 'Pluralsight'

    Example 3. 
      SELECT  OrderID + 0 AS OrderID, 
              OrderDate, 
              Customer AS Client
      FROM    Orders;
    
    1. Combine column with ANY operator (like '+') will REMOVE column name from resulting column
    2. It is recommanded to use AS keyword to provide alias in this case
    3. An alternative column name can also be used to subsitute the original column name with AS keyword
    4. Aliasing with AS helps clarify expressions
    
  Introduction to Multiple Tables in FROM
    Multiple Data Sources - need to JOIN separate data sources together
    JOIN 2 tables 
      Table_1 = (A, B, C) 
      Table_2 = (B, E)  
    
    Step 1 - CROSS JOIN to produce Cartesian Product
    1. Every JOIN start with Cartesian Product (CROSS JOIN) - every element from table 1 is paried with every elements from table 2
       Cartesian Product = (AB, AE, BB, BE, CB, CE)
       Table_1 CROSS JOIN Table_2 
    2. CROSS JOIN is not often used - typically rows from both table are matched based on common denominator 
       Such as orders from a specific customer OR order with specific items solde 

    Step 2 - Matching Rows 
    Table_1 INNER JOIN Table_2
    1. INNER JOIN start with Cartesian Product and a JOIN PREDICATE that specifies match condition 
    2. JOIN PREDICATE is used to evaluate each pair of element from Cartesian Product
    3. If JOIN PREDICATE evaluated to TRUE, the pair will be kept, else the pair will be removed
    4. Query continue with kept pairs to next phase

    Example.
      Table_1 INNER JOIN Table_2
      ON
      Table_1.Character = Table_2.Character  
      
      For Cartesian Product = (AB, AE, BB, BE, CB, CE)
      Only 'BB' is kept

    Step 3 - Add reserved rows
    1. To keep ALL elements from Table_1, regardless if they have matching element in Table_2 
       Table_1 need to be reserved with LEFT OUTER JOIN - b/c it is on the LEFT side
    2. The elements from reserved set that FAILED JOIN PREDICATE evaluation are now re-introduced 
    3. All rows of result set have same structure 
       so the elements from reserved set that failed predicate need to be paired as well 
    4. "NULL" is paried with re-introduced element to indicate a missing value 

    Example.
      Table_1 LEFT OUTER JOIN Table_2
      ON
      Table_1.Character = Table_2.Character 

      For Cartesian Product = (AB, AE, BB, BE, CB, CE)
      Only 'BB' is kept
      A and C failed JOIN PREDICATE Table_1.Character = Table_2.Character, but now re-introduced  
      result = (AxNULL, BB, CxNULL)

  Demo: Multiple Tables
    Using Customer's name (Primary Key in Customers table) in Orders table as Natural keys
    Natural Keys are meaningful / real attributes
    Natural keys reduce the need to JOIN tables  

    Step 1 - Cartesian Product
      SELECT  *
      FROM    Customers
              CROSS JOIN
              Orders;
    
    Step 2 - INNER JOIN
      SELECT  *
      FROM    Customers AS C
              INNER JOIN
              Orders AS O
              ON C.Customer = O.Customer; 
      The predicate evaluate to TRUE if customer is paired with own order 
      Alias Table to shorter name (C and O) to keep query concise 
      SQL server evaluate every row of the Cartesian Product and eliminate all that failed  

      If a JOIN predicate is ALWAYS TRUE, then the result would be the same as CROSS JOIN

    Step 3 - LEFT OUTER JOIN
      To include customers who never made an order 

      SELECT  *
      FROM    Customers AS C
              LEFT OUTER JOIN
              Orders AS O
              ON C.Customer = O.Customer; 

  Module Review

Module 5 Filtering with WHERE
  Module Introduction
    Ternary logic (3 valued logic) 
    NULL indicators - how to handle it correctly for filtering 
    Logical predicates
    Using WHERE

  Understanding NULLs
    NULL 
      Indicate missing or inapplicable data 
      Not part of original relational model - introduced in 1975 (standardized in 1986)
    
    NULL IS NOT A VALUE!
      - can be seen as marker, indicator or state
  
  3VL (Ternary) Logic
    3 values: True, False, Unknown 
    Rule #1: Any comparison of two unknowns is unknown
    Rule #2: Comparison of known value to an unknown is unknown 
    Rule #3: State predicates evaluate to True or False

  Logical Predicates and Operators
    Additional Logical Operators - When using multiple predicates, be sure to use parentheses
      ALL
        Predicate: X > ALL(A, B, C) is True, only when ...
        X > A AND X > B AND X > C
        This will evaluate the same for Any comparison operator: <, ==, !=, ...
        If A, B or C is NULL, the predicate X > ALL(A, B, C) will evaluate to Unknown
      
      ANY / SOME
        Predicate: X > ANY|SOME(A, B, C) is True, when ...
        X > A OR X > B OR X > C
        If any of A, B or C is NULL, as long as X still more than any of the rest, 
        the predicate is True 
        Else, the predicate evaluate to Unknown 

      BETWEEN
        Predicate: X BETWEEN A AND B is true when ...
        X >= A AND X <= B
        Bounderies included 

      IN 
        Predicate: X IN (A, B, C) is true when ...
        X = A OR X = B OR X = C

      NOT IN
        Predicate: X NOT IN (A, B, C) is true when ...
        X <> A AND X <> B AND X <> C
        If any operand is NULL, the entire predicate will always evaluate to Unknown 
        
      LIKE
        Predicate: X LIKE ( <pattern> ) is true when ...
        X matches wildcard pattern 

      EXISTS
        Predicate: EXISTS (sub-query) is true when 
        sub-query returns any row at all 

    NULL Predicates 
      How to check if an expression is or is not NULL
        1. X = NULL is always evaluate to (unknown) NULL, regardless X IS NULL or NOT

        2. X <> NULL is always evaluate to (unknown) NULL, regardless X IS NULL or NOT

        3. X IS NULL evaluate to True if X is null, Flase if not; Never unknown 

        4. X IS NOT NULL evaluate to False if X is null, True if not; never unknown 
        
  Filtering with WHERE
  
  Module Review

Module 6 Grouping Rows
  Module Introduction
  What Is Grouping Good For?
  Grouping Rows
  Group Filtering with HAVING
  Module Review
  Evaluating SELECT Expressions
  Module Introduction

Module 7 Evaluating SELECT Expressions
Dealing with NULLs
Using DISTINCT
Module Review

Module 8 Ordering and Paging
  Module Introduction
  Law of Order
  ORDER BY
  Determinism and Tiebreakers
  Paging Result Sets
  Demo: Ordering and Paging
  Module Review

Module 9 Wrapping Up
  Module Introduction
  
  Course Review
    What is T-SQL and its root in relational model
    What is SQL Server, the ditions to use, authentication
    How to access object using fully qualified names

  Takeaway
  Feedback
  Next Steps
  Additional Resources and Conclusion