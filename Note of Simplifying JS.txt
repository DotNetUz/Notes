Code Example: https://github.com/jsmapr1/simplifying-js/
CHapter 01
Tip 01: Signal Unchanging Values with const as default
  const variable cannot be changed but it is NOT immutable
  e.g. items in a const array CAN be changed 
  const variable can be skimed over without tracking 

  Ex. variables/const/const.js
    const taxRate = 0.1;
    const total = 100 + (100 * taxRate);
    // Skip 100 lines of code
    return `Your Order is ${total}`;  // value of total cannot be changed after declaration 
  // vs. 
    var taxRate = 0.1;
    var total = 100 + (100 * taxRate);
    // Skip 100 lines of code 
    return `Your Order is ${total}`; // conditions may alter value of total
  
  Contrasting const and let to address what might change 
  Ex. variables/const/const.js
    const taxRate = 0.1;  // fixed - known-known
    const shipping = 5.00;  // fixed - known-known 
    let total = 100 + (100 * taxRate) + shipping; // value of total is NOT permanent - known-unknown 
    // skip 100 lines of code 
    return  `Your Order is ${total}`;

  Changing value of a const variable is possible with objects, arrays or other collections
  - but it's best to avoid mutations if possible 
  Ex. variables/const/const.js
    const discountable = [];
    // lines skipped
    for (let i = 0; i < cart.length; i++) {
      if(cart[i].discountAvailable) {
        discountable.push(cart[i]);
      }
    }
  
  Same example without mutations
    const discountable = cart.filter(item => item.dscountAvailable);

Tip 02: Reduce Scope Conflicts with let and const
  let is block scope; var is lexically scoped 
  block scope variables: exist only in blocks like if or for block
  let and const cannot be redeclared with the same name
  var can be redeclared with the same name in the same scope
  Decalre different / expressive names to keep detail and intent clear

Tip 03: Isolate information with Block Scoped variables
  let prevents scope conflicts in for loops and other iterations
  variables assigned with var are functionally scoped 
    - they are always referred to the last value assigned w/in a function
  Ex. variables/scope/scope.js
    function addClick(items) {
      for (let i = 0; i < items.length; i++) {
        items[i].onClick = function () {
          return i; // let variable (i) declared inside block are unique per iteration 
        };
      }
      return items;
    }

Tip 04: Convert Variables to Readable Strings w/ Template Literals w/out concatenation 
  Template literal is surrounded by backticks(`) 
  Anything that's not a string is surrounded by curly braces prefixed with $
  Ex. variables/literals/literals.js
    function greet(name) {
      return `Hi, ${name}`;
    }
    greet('Leo'); // "Hi, Leo"

  method call within template literal is also possible
  Ex.
    return `Hi, ${name.toUpperCase()}!`; // "Hi, LEO" 
  
  Another example with URL:
    return `https://${getProvider}/${image}?width=${parseInt(width, 10)}`;

Chapter 02  Manage Data Collection with Arrays
  How data or collections like objects can be converted into arrays    
  include()
  Spread operator (...)

Tip 05: Create Flexible Collections w/ Arrays
  Structures for collection of data: maps, sets, weakmaps, weaksets, objects and arrays
  arrays have method such as sort(), map(), filter() and reduce()

  Ex. arrays/arrays/arrays.js - example of sort and spread operator 
  const​ team = [​'Joe'​, ​'Dyan'​, ​'Bea'​, ​'Theo'​];
  function alphabetizeTeam(team) {
    return [...team].sort();
  }

  Ex. arrays/arrays/arrays.js - example of filter()
    const staff = [{
      name: 'Wesley',
      position: 'musician',
    }, {
      name: 'Davis',
      position: 'engineer'
    }];

    function getMusicians(staff) {
      return staff.filter(m => m.position === 'musician');
    }

    getMusicians(staff); // [{name: "Wesley", position: "musician"}]
  
  To iterate over an object, one needs to get keys from Object.keys() then iterate over those 
  Ex. arrays/arrays/arrays.js - example of Object.keys()
    const game1 = {
      player: 'Jim Jonas',
      hits: 2,
      runs: 1,
      errors: 0
    };

    const game2 = {
      player: 'Jim Jonas',
      hits: 3,
      runs: 0,
      errors: 1
    };

    const total = {};

    const stats = Object.keys(game1);
    for (let i = 0; i < stats.length; i++) {
      const stat = stats[i];
      if(stat !== 'player') {
        total[stat] = game1[stat] + game2[stat];
      }
    }

  total; // { hits: 5, runs: 1, errors: 1}

  Iterable: a way for program to go through a collection one item at a time while tracking current position
  Any action applies to arrays also applies to any data structure with iterable (eg. string)
  OR one that can be transformed into an iterable (like with Object.keys())

  Conceptually an object is a key-value store that can also be an array of arrays - with the inner arrays holding only two items
  Ex. object as key-value store vs. array of arrays
    const dog = {name: 'Don', color: 'black'};  // object
    const dogPair = [
      ['name', 'Don'],
      ['color', 'black']
    ];  // array of arrays

    function getName(dogPair) {
      return dogPair.find(attribute => {
        return attribute[0] === 'name';
      })[1]
    } 

    getName(dogPair); // 'Don'

  Object.entries() - convert object to an array of arrays
  Ex.
    const dog = {name: 'Don', color: 'black'};  // object
    Object.entries(dog)[0]; // ['name', 'Don']

Tip 06 Check Existence in an Array with Includes() (but without checking position)
  Check for value in array with indexOf(); return -1 if no matching value
  Ex. arrays/includes/includes.js
    const sections = ['contact', 'shipping'];
    function displayShipping(sections) {
      return sections.indexOf('shipping') > -1;
    }
  
  New method: includes() check if a value exist and return true or false 
  Ex. arrays/includes/includes.js
    const sections = ['contact', 'shipping'];
    function displayShipping(sections) {
      return sections.includes('shipping');
    }

Tip 07 Mold Arrays with the Spread Operator (with minimal code and side effects)
  Spread Operator (...) converts an array to a list of items
  Spread operator cannot be used on by itself - the info needs to be spread into something 
  Ex. 
    const items = ['item 0', 'item 1'];
    const copyItems = [...items]; 
  
  Task: Remove an item from an array
   
  Solution 1: using only loop @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const updated = [];
      for (let i = 0; i < items.length; i++){
        if (items[i] !== removable){
          updated.push(items[i]);
        }
      }
      return updated;
    }

  With array method splice(), the original array is modified, even for a const variable
  splice(stating_index, number_of_items_to_be_removed)

  Solution 2: using splice() @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      items.splice(index, 1);
      return items;
    }

  With array method slice(), the original array is unchanged 
  slice(inclusive_starting_index, exclusive_ending_index)

  Solution 3: using slice() @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      return items.slice(0, index).concat(items.slice(index + 1));
    }
  
  With slice() and spread operator to provide visual clue of sub array format 

  Solution 4: using slice() & spread operator @ arrays/spread/spread.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      return [...items.slice(0, index), ...items.slice(index + 1)];
    }
  
  Task: Create a list of arguments for a function 

  Solution: convert array to a list of function parameters @ arrays/spread/spread.js
    const book = ['Reasons and Persons', 'Derek Parfit', 19.99];
    function formatBook(title, author, price){
      return `${title} by ${author} $${price}`;
    }
    formatBook(...book);

Tip 08 Avoid Push Mutations with the Spread Operator
  Task: avoid array mutation @ arrays/push/push.js
  const cart = [
 	  {
 	    name: 'The Foundation Triology',
 	    price: 19.99,
 	    discount: false,
 	  },
 	  {
 	    name: 'Godel, Escher, Bach',
 	    price: 15.99,
 	    discount: false,
 	  },
 	  {
 	    name: 'Red Mars',
 	    price: 5.99,
 	    discount: true,
 	  },
 	];
 	
 	const reward = {
 	  name: 'Guide to Science Fiction',
 	  discount: true,
 	  price: 0,
 	};
 	
 	function addFreeGift(cart) {
 	  if (cart.length > 2) {
 	    /*
      cart.push(reward); // mutate original cart array
 	    return cart;
      */
      return [...cart, reward]; // no change to original cart  
 	  }
 	  return cart;
 	}
 	
 	function summarizeCart(cart) {
 	  const discountable = cart.filter(item => item.discount);
 	  if (discountable.length > 1) {
 	    return {
 	      error: 'Can only have one discount',
 	    };
 	  }
 	  const cartWithReward = addFreeGift(cart);
 	  return {
 	    discounts: discountable.length,
 	    items: cartWithReward.length,
 	    cart: cartWithReward,
 	  };
 	}

Tip 09 Avoid Sort Confusion with the Spread Operator 
  Task: Sort the array multiple times while getting the same result with Spread Operator
  Ex. Sort array of employees @ arrays/sort/sortMutate.js
  const staff = [
 	  {
 	    name: 'Joe',
 	    years: 10,
 	  },
 	  {
 	    name: 'Theo',
 	    years: 5,
 	  },
 	  {
 	    name: 'Dyan',
 	    years: 10,
 	  },
 	];
  function sortByYears(a, b) {
    if(a.years === b.years) {
      return 0;
    }
    return a.years - b.years;
  }
  const sortByName = (a, b) => {
    if(a.name === b.name) { return 0; }
    return a.name > b.name ? 1:-1;  
  }; 

  // sort by years of service
  staff.sort(sortByYears);  // original array mutated 
  staff.sort(sortByName);   // original array mutated again
  staff.sort(sortByYears);  // original array mutated with different results from last time sorting by year  

  // Fix: sort a copy of original array
  [...staff].sort(sortByYears); // original array unchanged
  [...staff].sort(sortByName);  // original array unchanged
  [...staff].sort(sortByYears); // original array unchanged & same result as last time sorting by year 

Chapter 03 
  Maximize Code Clarity with Special Collections
  Express intention when decalre variable 
  Choose data collection to maintain simplicity and felxibility 
    like objects used as key-value collection
    Map & Set
  Switch b/t structures 

Tip 10 Use Objects for Static Key-Value Loopups
  Objects are best collection for simple key-value lookups
  When data are structurally different from others and not interchangable, a key-value collection might be more appropriate. 
  - to share unchanging structured key-value data
  Avoid to use objects for dynamic information that is updated frequently (or looped over, sorted) or unknown until runtime 
  Ex. collection of colors in hex-code 
    const colors = {
      red: '#d10202',
 	    green: '#19d836',
 	    blue: '#0e33d8'
    }
  Ex. configuration @ collections/object/object.js
    export const config = {
      endpoint: 'http://pragprog.com,
      key: 'secretkey'
    }
  
  Task: Define static objects programmatically
    Build an object within a function 
    Pass object to another function
    Information is collected, sent, then unpacked (in another function)

  Ex. collections/object/object.js
    function getBill(item) {
      return {
        name: item.name,
        due: twoWeeksFromNow(),
        total: calculateTotal(item.price)
      };
    }
    const bill = getBill({
      name: 'Room Cleaning',
      price: 30
    });
    function displayBill(bill) {
      return `Your total ${bill.total} for ${bill.name} is due on ${bill.due}`;
    } 
  
















  
















   


  



