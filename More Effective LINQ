Module 1: Course Overview
  Constructing LINQ pipeline 
  Extending LINQ
  Optimizing performance
  Test and debug LINQ code

  Goal: Apply LINQ in all situations and expend & optimize accordingly 

Module 2: Discovering the Power of LINQ
  Why LINQ is Awesome
    Started in C# 3 (2007)
    Language features LINQ is based on:
      Lambda Expression
      Extension Methods
      Anonymous Types
      Query Expression Syntax 
      Generics 
      "yield" & "var" keyword

  Lambda Expressions
    pass anonymous functions into methods 
    work best as short one-line function
    eg. 
      customers.Where(c => c.Email !=  null)
      // filter a list of customers w/ Email

  Extension Methods
    Extend any existing type - even if not created by user - by adding methods
    Extension methods 
      must be static methods of a static class
      must use "this" keyword in method declaration 
      class where the method xetends from is in method declaration
    eg. 
      static class StringExtensions
      {
        public static string Shout(this string s) 
        {
          return s.ToUpper() + "!!!!";
        }
      }
    The library of framework methods that power LINQ are all extension methods on IEnumerable<T> 
    For IEmumerable<T>, LINQ extension methods are available 
    Many extension methods also return IEmumerable<T>, they can be chained into pipelines
    LINQ pipelines should make code more readable, not less

  Anonymous Types and the 'var' Keyword
    "var": compiler infers type 
      eg. var dict = new Dictionary<string, Customer>();
    "var": allows Anonymous Types
      eg. var x = new { Author = "Mark Seemann", Title = "Dependency Injection in .NET" };
    Anonymous Type with EXACT same properties are consider of same type
      eg. var y = new { Author = "Martin Fowler", Title = "Patterns of Enterprise Architecture" }
          // same type as var x above
          var books = new[] {x, y}; // array of the smae Anonymous Type
    Anonymous Type infer property names automatically
      eg. 
        var author = "Adam Nathan";
        var title = "WPF 4"
        var book = new { author, title }; // but the property name is now lower case...
    For LINQ, Anonymous Type is used to pass state through different stages of LINQ pipeline
    preferable to tuples 

  Query Expression Syntax
    Keywords introduced the same time as LINQ
    Similar to SQL syntax
    eg. 
      var query =
        from c in customers
        group c by c.Country into countryGroup
        orderby countryGroup.Key
        select countryGroup;
    The syntax or LINQ is not only for DB
      LINQ to Entities (EF): convert into SQL with Expression Tree
      LINQ to Objects: an in-memory collection of objects 
        like list of strings or array of customers
    Query Expression Syntax VS. Extension Methods (chained)
      special cases for each approach

  Generics and the 'yield' Keyword
    Generics: Create methods and classes 
      that are NOT limited to only work with a specific type
      eg. List<T> makes list of any type
    Extend LINQ with customized generic method
      eg.
        // generic method that can operate on an IEnumerable<T>
        public static IEnumerable<T> Double<T>(this IEnumerable<T> source)
        {
          foreach (var s in source) 
          {
            yield return s;
            yield return s;
            // Whenever returning an IEnumerable sequence
            // call "yield return" for each element of the sequence to be emitted 
            // use "yield break" to exist method early 
          }
        } 
  
  Expression Trees: turn Lambda Expressions into data structure for inspection or manipulation

  Collections are Everywhere
    LINQ can be used w/ collections or sequences of data
      In-memory objects
      DB queries
      Algorithmically generated data
    LINQ brings functional programming style into C#

  Introducing LINQPad

  What to Expect in the Rest of this Course
    Different "best practices" of LINQ
      Mod 2: Thinking in patterns 
        - spot place to apply LINQ
      Mod 3: Unleashing the Power of Pipelines 
        - chaining LINQ operators and extension methods
      Mod 4: Writing Clean and Readable Code 
        - write LINQ pipelines that are easy to understand and maintain 
      Mod 5: Extending LINQ
        - customized LINQ extension methods & use 3rd party extensions
      Mod 6: Avoiding unnecessary work
        - avoid code execution unless really need to
      Mod 7: Optimizing Performance of LINQ queries 
      Mod 8: Test & Debug effectively w/ LINQ
      Mod 9: Embracing functional style
        - identify key functional concepts
      
Module 3: Thinking in Patterns
  Module Introduction
    Looping through collections
      Switch from into imperative style (how to do) to declarative style (what to do)
      Declarative style: expresses intent with succinct code 

  LINQ Challenge - Motorsport Scores
    // calculate total score without the lowest 3 
    // starting with ...
    "10, 5, 0, 8, 10, 1, 4, 0, 10, 1".Split(',')
    // return string array

  Get to Know the Available LINQ Extensions
    MSDN -> System.Linq / Enumerable / Methods
      know what are available in LINQ to simplify code 
      like takeWhile

  Spot the Pattern #1 - Filtering Collections
    Filter with Where() taking Lambda Expression
    eg. Iterate over customer with Non-null or Non-empty Email property
      foreach (var c in customers.Where(c => !String.IsNullOrEmpty(c.Email))) 
      {...}  
    Filter with query expression syntax
    eg. 
      foreach (var customer in
        from c in customers
        where !String.IsNullOrEmpty(c.Email)
        select c) 
      { ... }
      
  Spot the Pattern #2 - Finding One Item
    Identify order by spacific order Id
    guess: use Single() -
      return the ONLY element that satisfied condition 
      throw InvalidOperationException if none or more than one elements are found    
    
    Recommandation #1: FirstOrDefault() - 
      find first item in collection that matches a particular condition or 
      return null or default value if none found
      eg. return first order with matching id
        Order orderToRefund = orders.FirstOrDefault(o => o.Id == orderId);

    recommandation #2: First() 
      find first item in collection that matches a particular condition or
      throw InvalidOperationException if none found
      eg.
        Order orderToRefund = orders.First(o => o.Id == orderId);

  Spot the Pattern #3 - True for Everything?
    Any() determines whether any element exists or satisfies a condition  
      return true if any element pass the condition 
      return flase otherwise 
    eg. Set the flag to true if any order was refunded
      bool anyRefunded = orders.Any( o => o.Status == "Refunded"); 

    All() determines whether all elements satisfy a condition 
      return true if sequence is empty OR all elements in sequence pass the condition
      return flase otherwise
    eg. Set flag to flase if NOT all orders are delivered 
      bool allDelivered = orders.All( o => o.Status == "Delivered");
      
  Spot the Pattern #4 - Transforming Objects
    Select() maps each element and return IEnumerable<T> of the same size
    eg. Convert an array of file path to an IEnumerable<T> sequence of file size for each file
      paths.Select( p => new FileInfo(p).Length )

    Apply ToList(), ToArray(), ToDictionary() to create List, array or Dictionary from IEnumerable
    eg. Create Dictionary form IEnumerable sequence 
      paths.Select(p => new FileInfo(p)).ToDictionary( p => p.Name, p => p.Length);
      // Name is used as key and Length is used as value  

  Spot the Pattern #5 - How Many like This?
    Count() 
      returns the number of elements that pass the given condition 
      OR given no lambda expression, returns the total number of elements in sequence
      eg. return the number of refunded orders
        orders.Count( o => o.Status == "Refunded" )  

    Sum()
      returns sum of values return from lambda expression given to each element
      eg. Sum of orders' amount
        orders.Sum( o => o.Amount )

  Spot the Pattern #6 - Grouping Things
    GroupBy() 
      given lambda expression that returns key for grouping
      returns an IEnumerable sequence of IGrouping objects, each with a key (specified by lambda expression)
      eg. 
        
  Using Productivity Tools to Spot Patterns
  LINQ Challenge Solution - Motorsport Scores
  Module Summary

Module 4: Unleashing the Power of Pipelines
  Module Introduction
  Transforming Elements
  Filtering Elements
  Reducing Sequences
  Generating Sequences
  Expanding Sequences
  Reordering Sequences
  The Power of Pipelines
  LINQ Challenge - Album Duration
  LINQ Challenge - Range Expansion
  Real World LINQ - Find in Files
  Real World LINQ - Parsing Log Files
  Real World LINQ - Orphaned Project Files
  Module Summary

Module 5: Writing Clean and Readable Code
  Module Introduction
  Why Clean Code Matters
  LINQ Challenge - Sort by Age
  LINQ Challenge - Bishop Moves
  Using the LINQ Query Expression Syntax
  LINQ Challenge - Longest Book
  Module Summary

Module 6: Extending LINQ
  Module Introduction
  Demo: Creating an Extension Method
  Demo: Concatenating Strings
  Demo: Creating a MaxBy Extension Method
  LINQ Challenge: Counting Pets
  LINQ Challenge: Swim Length Times
  Demo: Using MoreLINQ's Batch Extension Method
  LINQ Challenge: Counting Consecutive Sales
  Module Summary

Module 7: Avoiding Unnecessary Work with Laziness
  Module Introduction
  Deferred Execution
  Demo: RSS Downloader
  Breaking Out Early
  Avoiding Multiple Enumeration
  Multiple Enumeration and Databases
  Multiple Enumeration and Correctness
  Returning IEnumerable<T>
  Module Summary

Module 8: Optimizing Performance
  Module Introduction
  When Should You Optimize?
  Is LINQ Always the Right Choice?
  Speeding up LINQ with LinqOptimizer and PLINQ
  Understanding the Implementation
  Optimizing LINQ to Entities
  Demo: Avoiding Returning too Much Data
  Demo: Avoiding Select N+1
  Module Summary

Module 9: Testing and Debugging Effectively
  Module Introduction
  Demo: Debugging LINQ Queries in Visual Studio
  Demo: Pipeline Tracing with Extension Methods
  Testing LINQ Queries
  Testing LINQ to Entity Framework
  Exception Handling in LINQ Queries
  Demo: Suppressing Errors in LINQ Pipelines
  Module Summary

Module 10: Embracing a Functional Style
  Module Introduction
  Declarative Code
  Chaining Functions
  Higher Order Functions
  Being Lazy
  Avoiding Side Effects
  Course Summary and Bonus Content