Code Example: https://github.com/jsmapr1/simplifying-js/
CHapter 01
Tip 01: Signal Unchanging Values with const as default
  const variable cannot be changed but it is NOT immutable
  const declaration creates a read-only reference (one-time assignment) to a value  
  e.g. items in a const array CAN be changed 
  const variable can be skimed over without tracking 

  Ex. variables/const/const.js
    const taxRate = 0.1;
    const total = 100 + (100 * taxRate);
    // Skip 100 lines of code
    return `Your Order is ${total}`;  // value of total cannot be changed after declaration 
  // vs. 
    var taxRate = 0.1;
    var total = 100 + (100 * taxRate);
    // Skip 100 lines of code 
    return `Your Order is ${total}`; // conditions may alter value of total
  
  Contrasting const and let to address what might change 
  Ex. variables/const/const.js
    const taxRate = 0.1;  // fixed - known-known
    const shipping = 5.00;  // fixed - known-known 
    let total = 100 + (100 * taxRate) + shipping; // value of total is NOT permanent - known-unknown 
    // skip 100 lines of code 
    return  `Your Order is ${total}`;

  Changing value of a const variable is possible with objects, arrays or other collections
  - but it's best to avoid mutations if possible 
  Ex. variables/const/const.js
    const discountable = [];
    // lines skipped
    for (let i = 0; i < cart.length; i++) {
      if(cart[i].discountAvailable) {
        discountable.push(cart[i]);
      }
    }
  
  Same example without mutations
    const discountable = cart.filter(item => item.dscountAvailable);

Tip 02: Reduce Scope Conflicts with let and const
  let is block scope; var is lexically scoped 
  block scope variables: exist only in blocks like if or for block
  let and const cannot be redeclared with the same name
  var can be redeclared with the same name in the same scope
  Decalre different / expressive names to keep detail and intent clear

Tip 03: Isolate information with Block Scoped variables
  let prevents scope conflicts in for loops and other iterations
  variables assigned with var are functionally scoped 
    - they are always referred to the last value assigned w/in a function
  Ex. variables/scope/scope.js
    function addClick(items) {
      for (let i = 0; i < items.length; i++) {
        items[i].onClick = function () {
          return i; // let variable (i) declared inside block are unique per iteration 
        };
      }
      return items;
    }

Tip 04: Convert Variables to Readable Strings w/ Template Literals w/out concatenation 
  Template literal is surrounded by backticks(`) 
  Anything that's not a string is surrounded by curly braces prefixed with $
  Ex. variables/literals/literals.js
    function greet(name) {
      return `Hi, ${name}`;
    }
    greet('Leo'); // "Hi, Leo"

  method call within template literal is also possible
  Ex.
    return `Hi, ${name.toUpperCase()}!`; // "Hi, LEO" 
  
  Another example with URL:
    return `https://${getProvider}/${image}?width=${parseInt(width, 10)}`;

Chapter 02  Manage Data Collection with Arrays
  How data or collections like objects can be converted into arrays    
  include()
  Spread operator (...)

Tip 05: Create Flexible Collections w/ Arrays
  Structures for collection of data: maps, sets, weakmaps, weaksets, objects and arrays
  arrays have method such as sort(), map(), filter() and reduce()

  Ex. arrays/arrays/arrays.js - example of sort and spread operator 
  const​ team = [​'Joe'​, ​'Dyan'​, ​'Bea'​, ​'Theo'​];
  function alphabetizeTeam(team) {
    return [...team].sort();
  }

  Ex. arrays/arrays/arrays.js - example of filter()
    const staff = [{
      name: 'Wesley',
      position: 'musician',
    }, {
      name: 'Davis',
      position: 'engineer'
    }];

    function getMusicians(staff) {
      return staff.filter(m => m.position === 'musician');
    }

    getMusicians(staff); // [{name: "Wesley", position: "musician"}]
  
  To iterate over an object, one needs to get keys from Object.keys() then iterate over those 
  Ex. arrays/arrays/arrays.js - example of Object.keys()
    const game1 = {
      player: 'Jim Jonas',
      hits: 2,
      runs: 1,
      errors: 0
    };

    const game2 = {
      player: 'Jim Jonas',
      hits: 3,
      runs: 0,
      errors: 1
    };

    const total = {};

    const stats = Object.keys(game1);
    for (let i = 0; i < stats.length; i++) {
      const stat = stats[i];
      if(stat !== 'player') {
        total[stat] = game1[stat] + game2[stat];
      }
    }

  total; // { hits: 5, runs: 1, errors: 1}

  Iterable: a way for program to go through a collection one item at a time while tracking current position
  Any action applies to arrays also applies to any data structure with iterable (eg. string)
  OR one that can be transformed into an iterable (like with Object.keys())

  Conceptually an object is a key-value store that can also be an array of arrays - with the inner arrays holding only two items
  Ex. object as key-value store vs. array of arrays
    const dog = {name: 'Don', color: 'black'};  // object
    const dogPair = [
      ['name', 'Don'],
      ['color', 'black']
    ];  // array of arrays

    function getName(dogPair) {
      return dogPair.find(attribute => {
        return attribute[0] === 'name';
      })[1]
    } 

    getName(dogPair); // 'Don'

  Object.entries() - convert object to an array of arrays
  Ex.
    const dog = {name: 'Don', color: 'black'};  // object
    Object.entries(dog)[0]; // ['name', 'Don']

Tip 06 Check Existence in an Array with Includes() (but without checking position)
  Check for value in array with indexOf(); return -1 if no matching value
  Ex. arrays/includes/includes.js
    const sections = ['contact', 'shipping'];
    function displayShipping(sections) {
      return sections.indexOf('shipping') > -1;
    }
  
  New method: includes() check if a value exist and return true or false 
  Ex. arrays/includes/includes.js
    const sections = ['contact', 'shipping'];
    function displayShipping(sections) {
      return sections.includes('shipping');
    }

Tip 07 Mold Arrays with the Spread Operator (with minimal code and side effects)
  Spread Operator (...) converts an array to a list of items
  Spread operator cannot be used on by itself - the info needs to be spread into something 
  Ex. 
    const items = ['item 0', 'item 1'];
    const copyItems = [...items]; 
  
  Task: Remove an item from an array
   
  Solution 1: using only loop @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const updated = [];
      for (let i = 0; i < items.length; i++){
        if (items[i] !== removable){
          updated.push(items[i]);
        }
      }
      return updated;
    }

  With array method splice(), the original array is modified, even for a const variable
  splice(stating_index, number_of_items_to_be_removed)

  Solution 2: using splice() @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      items.splice(index, 1);
      return items;
    }

  With array method slice(), the original array is unchanged 
  slice(inclusive_starting_index, exclusive_ending_index)

  Solution 3: using slice() @ arrays/spread/problem.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      return items.slice(0, index).concat(items.slice(index + 1));
    }
  
  With slice() and spread operator to provide visual clue of sub array format 

  Solution 4: using slice() & spread operator @ arrays/spread/spread.js
    function removeItem(items, removable) {
      const index = items.indexOf(removable);
      return [...items.slice(0, index), ...items.slice(index + 1)];
    }
  
  Task: Create a list of arguments for a function 

  Solution: convert array to a list of function parameters @ arrays/spread/spread.js
    const book = ['Reasons and Persons', 'Derek Parfit', 19.99];
    function formatBook(title, author, price){
      return `${title} by ${author} $${price}`;
    }
    formatBook(...book);

Tip 08 Avoid Push Mutations with the Spread Operator
  Task: avoid array mutation @ arrays/push/push.js
  const cart = [
 	  {
 	    name: 'The Foundation Triology',
 	    price: 19.99,
 	    discount: false,
 	  },
 	  {
 	    name: 'Godel, Escher, Bach',
 	    price: 15.99,
 	    discount: false,
 	  },
 	  {
 	    name: 'Red Mars',
 	    price: 5.99,
 	    discount: true,
 	  },
 	];
 	
 	const reward = {
 	  name: 'Guide to Science Fiction',
 	  discount: true,
 	  price: 0,
 	};
 	
 	function addFreeGift(cart) {
 	  if (cart.length > 2) {
 	    /*
      cart.push(reward); // mutate original cart array
 	    return cart;
      */
      return [...cart, reward]; // no change to original cart  
 	  }
 	  return cart;
 	}
 	
 	function summarizeCart(cart) {
 	  const discountable = cart.filter(item => item.discount);
 	  if (discountable.length > 1) {
 	    return {
 	      error: 'Can only have one discount',
 	    };
 	  }
 	  const cartWithReward = addFreeGift(cart);
 	  return {
 	    discounts: discountable.length,
 	    items: cartWithReward.length,
 	    cart: cartWithReward,
 	  };
 	}

Tip 09 Avoid Sort Confusion with the Spread Operator 
  Task: Sort the array multiple times while getting the same result with Spread Operator
  Ex. Sort array of employees @ arrays/sort/sortMutate.js
  const staff = [
 	  {
 	    name: 'Joe',
 	    years: 10,
 	  },
 	  {
 	    name: 'Theo',
 	    years: 5,
 	  },
 	  {
 	    name: 'Dyan',
 	    years: 10,
 	  },
 	];
  function sortByYears(a, b) {
    if(a.years === b.years) {
      return 0;
    }
    return a.years - b.years;
  }
  const sortByName = (a, b) => {
    if(a.name === b.name) { return 0; }
    return a.name > b.name ? 1:-1;  
  }; 

  // sort by years of service
  staff.sort(sortByYears);  // original array mutated 
  staff.sort(sortByName);   // original array mutated again
  staff.sort(sortByYears);  // original array mutated with different results from last time sorting by year  

  // Fix: sort a copy of original array
  [...staff].sort(sortByYears); // original array unchanged
  [...staff].sort(sortByName);  // original array unchanged
  [...staff].sort(sortByYears); // original array unchanged & same result as last time sorting by year 

Chapter 03 
  Maximize Code Clarity with Special Collections
  Express intention when decalre variable 
  Choose data collection to maintain simplicity and felxibility 
    like objects used as key-value collection
    Map & Set
  Switch b/t structures 

Tip 10 Use Objects for Static Key-Value Loopups
  Objects are best collection for simple key-value lookups
  When data are structurally different from others and not interchangable, a key-value collection might be more appropriate. 
  - to share unchanging structured key-value data
  Avoid to use objects for dynamic information that is updated frequently (or looped over, sorted) or unknown until runtime 
  Ex. collection of colors in hex-code 
    const colors = {
      red: '#d10202',
 	    green: '#19d836',
 	    blue: '#0e33d8'
    }
  Ex. configuration @ collections/object/object.js
    export const config = {
      endpoint: 'http://pragprog.com,
      key: 'secretkey'
    }
  
  Task: Define static objects programmatically
    Build an object within a function 
    Pass object to another function
    Information is collected, sent, then unpacked (in another function)

  Ex. collections/object/object.js
    function getBill(item) {
      return {
        name: item.name,
        due: twoWeeksFromNow(),
        total: calculateTotal(item.price)
      };
    }
    const bill = getBill({
      name: 'Room Cleaning',
      price: 30
    });
    function displayBill(bill) {
      return `Your total ${bill.total} for ${bill.name} is due on ${bill.due}`;
    }

Tip 11 Create Objects Without Mutations Using Object.assign()
  Side note: Short-circuit evaluation 
  The second argument is executed or evaluated only if the first argument does not suffice to determine the value of expression
  JS returns the result of last value that halted the execution
  
  Task: evaluate to the first truthy value with OR (||)
    console.log(false || null || "" || 0 || NaN || "Hello" || undefined); // Hello

  Task: evaluate to the first falsy value with AND (&&)
    console.log(1 && [] && {} && true && "World" && null && 2010);  // null
  
  Object.assign() takes a series of objects and updates the inner-most object with keys and values from outer objects,
  then returns the updated first object
  The outermost object has precedence over any inner objects.

  Task: update object with Object.assign()
  Ex.
    const object1 = { a: 1, b: 2, c: 3 };
    const object3 = { c: 4, d: 5 };
    
    const object2 = Object.assign(object3, object1);

    console.log(object1.a, object1.b, object1.c, object1.d); // 1 2 3 undefined - object 1 unchanged
    console.log(object2.a, object2.b, object2.c, object2.d); // 1 2 3 5         - object 2 changed
    console.log(object3.a, object3.b, object3.c, object3.d); // 1 2 3 5         - object 3 changed
  
  Alternatively, to keep object3 (default) unchanged, supply Object.assign() with empty object as first argument
  Ex. 
    const object1 = { a: 1, b: 2, c: 3 };
    const object3 = { c: 4, d: 5 };
    
    const object2 = Object.assign({}, object3, object1);

    console.log(object1.a, object1.b, object1.c, object1.d); // 1 2 3 undefined         - object 1 unchanged
    console.log(object2.a, object2.b, object2.c, object2.d); // 1 2 3 5                 - object 2 changed
    console.log(object3.a, object3.b, object3.c, object3.d); // undefined undefined 4 5 - object 3 unchanged

  Task: update nested object with Object.assign() - deep copying 
    Copying with previous approach will cross-reference the objects, so when either the original or cpoy object been changed, 
    both will be impacted 
    Ex. collections/assign/assign.js 
    const defaultEmployee = {
      name: {
        first: '',
        last: '',
      },
      years: 0
    };   
    // create employee object with dientical content of defaultEmployee
    const employee = Object.assign({}, defaultEmployee); 
    // assign value 'Joe' to name.first property 
    // defaultEmployee's name.first property is also assigned the value 'Joe'
    employee.name.first = 'Joe';

    const employee2 = Object.assign(
      {},
      defaultEmployee,
      {
        name: Object.assign({}, defaultEmployee.name)
      }
    );
    // apply Object.assign() to specific nested property (name)
    // with this approach, defaultEmployee is unchanged 

Tip 12 Update information with Object Spread 
  object spread operator has yet to be part of the spec - but is a popular new addition in ES6
  However, value with the same key will be replaced by the last declared 
  Task: Update flat object with object spread operator
  Ex.
    const book = {
      title: 'Reasons and Persons',
      author: 'Derek Parfit'
    };
    const update = {...book, year: 1984};
    // { title: 'Reasons and Persons', author: 'Derek Parfit', year: 1984}

  Task: Update nested object with object spread operator 
  Ex.
    const defaultEmployee = {
      name: {
        first: '',
        last: '',
      },
      years: 0
    }; 

    const employee = {...defaultEmployee, name: {
      ...defaultEmployee.name
    }};

    employee.name.first = 'Joe';

    employee;
    /*
    {
      name: {
        first: 'Joe',
        last: '',
      },
      years: 0
    }
    */
    
    defaultEmployee;
    /*
    {
      name: {
        first: '',
        last: '',
      },
      years: 0
    }
    */

Tip 13 Update Key-Value Data Clearly w/ Maps 
  Map as alternative to object
   when Key-value pairs are frequently added or removed
   when key is NOT a string 
  
  Task: Adding or removing values to map
  Ex. 
    // shape of each item is the same in array
    const dogs = [
      {name: 'max', size: 'small', breed:'boston terrier', color: 'black'},
      {name: 'don', size: 'large', breed:'labrador', color: 'black'},
      {name: 'max', size: 'small', breed:'boston terrier', color: 'black'}
    ];
    // Then create a collection of applied filters, each containing a key (color) and a value (black)
    // to add a filter, remove a filetr and clear all filter values ...

  Try to complete the task with standard objects ...
  Ex.  
    let filters = {}; // make an empty object to hold information 
    function addFilters(filters, key, value) {
      filters[key] = value; // method on object
    }
    function deleteFilters(filters, key) {
      // operator defined by JS
      delete filters[key]; // using delete may leave undefined holes in array
    }
    function clearFilters(filters) {
      filters = {}; // variable re-assignment
      return filters;
    }

  Map is more predictable, which leads to productivity 

  Side Note: Browser Engine 
    JS is interpreted by engines
    Chrom and Node use V8 engineer
    Firefox uses SpiderMonkey
    IE and Edge use Chakra 
    Key lookup in object is linear but can be logarithmic when implemented natively 
    -> big object is more expensive than big map 
  
  Ex. 
    let filters = new Map();  // declare filters with let b/c map will be mutated 
    filters.set('breed', 'labrador');  
    filters.get('breed');  // labrador
    
    // add multiple values with chaining 
    let filters = new Map()
      .set('breed', 'labrador')
      .set('size', 'large')
      .set('color', 'chocolate');
    filters.get('size');  // large

    // add multiple values with 2-D array
    let filters = new Map(
      [
        ['breed', 'labrador'],
        ['size', 'large'],
        ['color', 'chocolate']
      ]
    ); 
    filters.get('color');  // chocolate

    // Use Array.from() to transform a map into a 2-D key-value array
    console.log(Array.from(filters)); 
    console.log(Array.from(filters.keys())); // ['breed', 'size', 'color']

    // Use delete() method to remove value
    filters.delete('color');
    filters.get('color');   // undefined 

    // Use clear() method to remove allkey-value pairs 
    filters.clear();
    filters.get('size');   // undefined 

  Adding or removing values with map
  Ex. 
    const petFilters = new Map();
    
    function addFilters(filters, key, value) {
      filters.set(key, value);
    }

    function deleteFilters(filters, key) {
      filters.delete(key);
    }

    function clearFilters(filters) {
      filters.clear();
    }

  Why use Map over Object as collection:
    Object cannot use integer as key
    but Map can
    Ex. 
      let errors = new Map([
        [100, 'Invalid name'],
        [110, 'Name should only contain letters'],
        [200, 'Invalid color']
      ]);

      errors.get(100); // 'Invalid name'
      errors.keys();   // MapIterator {100, 110, 200}
  MapIterator allows looping through data
  
Tip 14 Iterate Over Key-Value Data w/ Map and Spread Operator  
  Looping over object is complicated - iterate over map instead
  Task: Lopping over object
  Ex. collections/mapSpread/object.js
    const filters = {
      color: 'black',
      breed: 'labrador'
    };

    function getAppliedFilters(filters) {
      const keys = Object.keys(filters);
      const applied = [];
      for (const key of keys){
        applied.push(`${key}:${filters[key]}`);
      }
      return `Your filters are: ${applied.join(',')}`; 
    }
    
    // Loop over object in sorted sequence 
    function getSortedAppliedFilters(filters) {
      const keys = Object.keys(filters);
      keys.sort();
      const applied = [];
      for (const key in keys) {
        applied.push(`${key}:${filters[key]}`);
      }
      return `Your filters are: ${applied.join(',')}`; 
    }
  
  Task: Iterate over map with for ... of loop
  Ex. collections/mapSpread/iterate.js
    const filters = new Map()
      .set('color', 'black')
      .set('breed', 'labrador');
    // iterate over map with for ... of loop
    function checkFilters(filters) {
      for (const entry of filters) {
        console.log(entry);
      }
    } 
    // ['color', 'black']
    // ['breed', 'labrador'] 
  
  Side Note: Map method entries() returns a MapIterator of the key-value of a mapas group of pairs
  filters.entries();
  // MapIteraotr { ['color', 'black'], ['breed', 'labrador'] }

  Assign variables using destructuring 

  Ex. collections/mapSpread/iterate.js
  // takes instance of map or MapIterator
  function getAppliedFilters(filters) {
    const applied = [];
    for (const [key, value] of filters) {
      applied.push(`${key}:${value}`);
    }
    return `Your filter are: ${applied.join(', ')}.`;
  }

  However, with this approach, the order of iteration is the same as map itself and cannot be changed 

  Task: Sort Map with the spread operator 
  Spread operator returns a list of key-value pairs on map
  Ex. 
    ...filters; // ['color', 'black'], ['breed', 'labrador']
  spread operator needs to be spread into something 
    [...filters]; // [['color', 'black'], ['breed', 'labrador']]
  A comparer function is required to sort a 2-D array (by Key)
  Ex. 
    function sortByKey(a, b) {
      return a[0] > b[0] ? 1:-1
    }

    function getSortedAppliedFilters(filters) {
      const applied = [];
      for (const [key, value] of [...filters].sort(sortByKey)) {
        applied.push(`${key}:${value}`)
      }
      return `Your filters are: ${applied.join(',')}.`;
    }
  
  Alternatively, map() method of array can be used here:
    1. Convert map into array
    2. Sort array
    3. Convert each pair to a key:value string
    4. Join array to create a string
    5. Return string as part of template string 

  Ex. collections/mapSpread/mapSpread.js
    function getSortedApliedFilters(filters) {
      const applied = [...filters]
        .sort(sortByKey)
        .map( ([key, value]) => {
          return `${key}:${value}`;
        })
        .join(',');
      return `Your filters are: ${applied}.`;
    }
    // 'Your filters are: breed:labrador, color:black.'

Tip 15 Create Maps w/out Side effects
  Task: Apply a set of defaults to a map while taking inputs from user
  Ex. collections/mapSideEffects/sideEffects.js
    const defaults = new Map()
      .set('color', 'brown')
      .set('breed', 'beagle')
      .set('state', 'kansas'); // default setting
    
    const filters = new Map()
      .set('color', 'black'); // user input 
    
    function applyDefaults(map, defaults) {
      for(const [key, value] of defaults) {
        if (!map.has(key)) {
          map.set(key, value);
        }
      }
    }

    applyDefaults(filters, defaults); // filters is now mutated 
  Task: Apply a set of defaults to a map without mutating the original map by copying the map
    Copy map by:
      1. using the spread operator to create list of pairs
      2. pass in array of pairs to create new map
    Ex. collections/mapSideEffects/copy.js
      function applyDefaults(map, defaults) {
        const copy = new Map([...map]);
        for(const [key, value] of defaults) {
          if(!map.has(key)) {
            map.set(key, value);
          }
        }
        return copy;
      }
  
  Side Note: Map keys are unique - the latest value update persist 
  Task: Apply a set of defaults to a map without mutating the original map 
    by combining maps with spread operator
    function applyDefaults(map, defaults) {
      return new Map([...map, ...defaults]);
    }

Tip 16 Keep Unique Values with Set 
  Task: pull unique items from an array with Set
  Ex. 
    const colors = ['black', 'black', 'chocolate'];
    const unique = new Set(colors); // Set {'black', 'chocolate'}
  
  Task: spread operator with Set to get array of unique items 
  Ex. collections/set/set.js
    function getUnique(array) {
      return [...new Set(array)];
    }
  
  Task: get unique values from an array of objects in one iteration
  Ex. collections/set/set.js
    function getUniqueColors(dogs) {
      const unique = new Set();
      for(const dog of dogs) {
        unique.add(dog.color);
      }
      return [...unique];
    }

  Task: get unique values from an array of objects with reduce()
  Ex.
    function getUniqueColorsReduce(dogs) {
    const colors =
      [...dogs.reduce(
        (colors, { color }) => 
          colors.add(color), 
        new Set()
      )];
    return colors;
    }

Chapter 4 Write Clear Conditionals
  - Write clean and predictable JS code by cleaning up conditional expressions
  - Review basics:
    truthy and falsy values 
    ternary expression 
    short circuiting 

Tip 17 Shorten Conditionals with Falsy Values
  Equivalency & Identity 
  
  Equivalent values are same values but of different type
  Equivalent value is checked with '=='

  1 == '1' // true 

  Identical values are of strict equality of the same type

  1 === '1' // false
  1 === 1 // true 

  Objects, like instances of array, are checked by refernce 

  Eg. An empty string is "equal" to false but they are not "identical" 
    '' == false // true 
  List of falsy values:
    false
    null
    0
    NaN
    ''
    ""
    undefined
  Arrays and objects are always truthy, even when they are empty 

  Potential issue with unintented mutation: 
    (Delete) Removing key value pair will default the (non-exist) value to undefined, 
    which is a falsy value 
  To avoid this issue: 
    1. prevent data from mutation
    2. use strict equivalency (=== / !==)

Tip 18 CHeck Data Quickly with Ternary Operator
  Ternary operator produce predictable code by reducing the number of variables assigned
  Instead of defining or assign variable inside if / else block like:
  Eg. 
    let permissions;
    if (title === 'manager') {
      permissions = ['time', 'pay'];
    } else {
      permissions = ['time'];
    }
  A shorten version w/ ternary operator:
  Eg.
    const permissions = title === 'manager' ? ['time', 'pay']:['time'];
  
  Warning: avoid to chain multiple ternary expressions
  When nested ternary expressions are needed, it is best to refactor into a function
  eg.
    function getTimePermissions({title}) {
      if(title === 'manager') {
        return ['time', 'overtimeAuthorization', 'pay'];
      }
      if(title === 'supervisor') {
        return ['time', 'overtimeAuthorization']
      }
      return ['time'];
    }
    const permissions = getTimePermissions({title:'employee'}); // ['time']
  
Tip 19 Maximize Efficiency w/ Short Circuiting 
  || op to check and assign with default operand as needed 
  eg. 
    const name = "charles" || "Who am I"; // "charles" b/c it's truthy

    function getIconPath(icon) {
      const path = icon.path || 'default.png'; 
      // if icon is undefined, 'path' will be assigned with 'default.png' 
      return path;
    } 

  && op to check for error in combinations of requirements -  all must be true else default
  eg.
    function getImage(config) {
      const images = config.images;
      return images && images.length ? images[0] : 'default.png';
      // return images[0] only if images is defined and has length more than 0
    }
  For combination check of even more requirements, refactor w/ function or RegEx

Chapter 5 Simplify Loops
  - avoid mutations
  - return predictable results
  - concise (as short as possible)
  - arrow function turns simple loop into one-liner 

Tip 20 Simplify Looping with Arrow Functions
  callback functions: functions passed in as parameter to other Functions
  function injection with callback: pass in a function to return a customized result
  eg.
    let capitalize = name => name[0].ToUpperCase() + name.slice(1);
    function applyCustomGreeting(name, callback) {
      return callback(capitalize(name)); // return a function that takes specified parameters
    }

  One of the ideal case for arrow function:
    - Simple anonymous function 
    - one-liner
    - single parameter

  eg. in combination w/ previous example 
    applyCustomGreeting('joe', function(name) {
      return `Oh, hi ${name}!`;
    }); // "Oh, hi Joe!"

Tip 21 Write Shorter Loops with Array Methods
  for loop and for ... of loop may present unnecessary clutter 
  
  eg. loop to convert price strings into floating point values (loops/methods/problem.js)
    const prices = ['1.0', '2.15'];
    const formattedPrices = [];
    for (let i = 0; i < prices.length; i++) {
      formattedPrices.push(parseFloat(prices[i]));
    }
  
  As new limitations applied, code clusters increase 
  Code become less predictable 

  eg. loop to ONLY convert price strings into floating point values (loops/methods/problem.js)
    const prices = ['1.0', '2.15'];
    const formattedPrices = [];
    for (let i = 0; i < prices.length; i++) {
      const price = parseFloat(prices[i]);
      if (price) {
        formattedPrices.push(price);
      }
    }
  
  With the exception of reduce(), most array methods change size of array or shape (key / value pairs) of data
  List of common methods:
    map()
      change shape but not size 
      Example: Get the value of a key across similar items
    
    sort()
      change order but no change in size or shape
    
    filter()
      change size but not shape 
      Example: Get ONLY items of specific property value 
    
    find()
      change size to 1 but not shape; does not return an array 

    forEach()
      use shape; no return 

    reduce() 
      change shape and size as needed 
  
  Rewrite "loop to convert price strings into floating point values":
    const formattedPrices = price.map(price => parseFloat(price));
  
  Rewrite "loop to ONLY convert price strings into floating point values":
    const formattedPrices = price.map(price => parseFloat(price)).filter(price => price);
    // falsy values will be pulled

Tip 22 Create Arrays of same size with map()
  Every array method takes a callback function that applies to each member 
  Except reduce(), the callback function takes one argument - the individual member 
  eg. map() as simplified loop
    // normal loop
    const instruments = [];
    for (let i = 0; i < band.length; i++) {
      const instrument = band[i].instrument;
      instruments.push(instrument);
    }

    // refactor into saperate functions
    function getInstrument(member) {
      return member.instrument;
    }

    for (let i = 0; i < band.length; i++) {
      const instrument = band[i].instrument;
      instruments.push(getInstrument(band[i]));
    }    

    // remove loop
    const instruments = band.map(getInstrument);

    // convert named function into anonymous function
    const instruments = band.map( member => member.instrument );

Tip 23 Pull Out Subsets of Data with filter() and find()
  Change size and retain shape
  Note: 
    match() method on string returns an array of info if there is a match
    else, return null
    eg. 
      'Dave'.match(/Dav/)     // ["Dav", index: 0, input: "Dave", groups: undefined]
      'Michelle'.match(/Dav/) // null
      
  eg. return subset of array by specific criteria 
    // loop approach
    const daves = [];
    for (let i = 0; i < team.length; i++) {
      if(team[i].match(/Dav/)) {
        daves.push(team[i]);
      }      
    }
  
  The same task can be done with filter():
  filter() takes function that returns true / false value 
  
  eg. return subset of array by filter() with specific criteria
    const daves = team.filter(member => member.match(/Dav/));
  
  To get only one or first match by find():
  eg. 
    // loop approach
    let memorialInstructor;
    for(let i = 0; i < instructors.length; i++) {
      if(instructors[i].libraries.includes('Memorial')) {
        memorialINstructor = instructors[i];
        break;
      }
    }

    // find() approach
    const memorialInstructor = 
      instructors.find(instructor => {
        return instructor.libraries.includes("Memorial");
      });

  Warning: 
    If there is no match, filter() returns an empty array 
    but find() returns undefined

  To add default behavior to find() with short circuiting 
  eg. 
    const image = [{
      path:'./me.jpg',
      profile: false
    }];
    const profile = images.find(image => image.profile) || {path: './default.jpg'};

  Note: currying reduce arguments down to one
    /* data
      {
        name: 'Jim',
        libraries: ['MERIT']
      }
    */
    const findByLibrary = library => instructor => {
      return instructor.libraries.include(library);
    } 
    const librarian = instructors.find(findByLibrary('MERIT'));

  Tip 24 Apply Consistent Actions with forEach()
  






  





  



  











  




  
  





    




  





  
















  
















   


  



