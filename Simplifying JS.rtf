{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Calibri;}{\f2\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9 Introduction\b0\par
 Ever get the feeling you\rquote ve woken up and everything\rquote s different? If you\rquote ve looked at modern JavaScript, you may feel like you woke up in a new world where nothing\rquote s the same.\par
Yesterday, you were tweaking a simple jQuery accordion. Today, you look at some JavaScript code and the ubiquitous jQuery $ operator is gone. In its place are lots of strange dots (...) and strange symbols (=>) (the spread operator and arrow functions, as you\rquote ll soon learn). Sure, some things look familiar, such as class, but even that seems to be unpredictable (where are the private methods?).\par
Are you perplexed? Maybe a little excited? Well, I have good news for you: Everything has changed for the better.\par
When the ECMAScript 6 spec was released\f1\emdash ES6 for short\emdash JavaScript code changed dramatically. The changes were so substantial that after reading this book you\rquote ll be able to tell at a glance which code was written with pre-ES6 syntax and which code was written with post-ES6 syntax. JavaScript now is different. Modern JavaScript is any code composed with post-ES6 syntax.\par
Modern JavaScript is a pleasure to write. I\rquote m a long-time unrepentant JavaScript fan, but I\rquote ll admit that I found the old syntax a little clunky at times, and it was pretty hard to defend. Modern JavaScript is better. But it\rquote s changed significantly, and catching up can be hard.\par
\par
\b How To Use This Book\par
\b0 In this book, you\rquote ll learn to write modern JavaScript from the ground up. But I\rquote m not going to throw a bunch of syntax at you. I want you to learn to think in terms of contemporary JavaScript. You\rquote ll see every piece of syntax with a recommendation for not just how to use it, but when to use it.\par
Also, I\rquote m not going to run through every minor syntax change. I know your time is valuable, so I\rquote ll only show you syntax that has high impact and that\rquote s something you\rquote ll use over and over again. You can deal with edge cases when they arise. This book will give you the best features and nothing else.\par
Throughout the book, you\rquote ll see why the syntax changes aren\rquote t random\emdash they follow a simple set of principles designed to make the language easier to read and write. Modern JavaScript is simple, predictable, readable, and flexible. And every new piece of syntax should be evaluated in those terms, including syntax that isn\rquote t yet part of the spec.\par
And because modern JavaScript has as many paradigm changes as there are syntax changes, you\rquote ll spend some time reviewing older JavaScript concepts to see how you can use them in a modern context. This is important because JavaScript was previously written primarily using libraries (jQuery above all else), and it was easy to plug in just enough code to get something working without understanding the underlying concepts. As more code projects incorporate JavaScript as part of major features, and not just a handful of plugins, you\rquote ll need to understand concepts you may have glossed over before.\par
For example, you might have safely ignored syntax changes in ES5. You could use array methods such as map() and reduce() for several years, but you might have ignored them because browsers weren\rquote t fully compatible and because transpilers weren\rquote t yet mature. Array methods are now essential parts of good code. It\rquote s worth taking a step back to review them.\par
Still, I know you have plenty to do every day\emdash that\rquote s why this book follows a tips format that allows you to jump in and out at will. You don\rquote t need to read this straight through. I\rquote ll reference syntax from previous and future tips so that you can jump around as you need to. Keep a copy at your desk and skim it during a break, or load it up on your phone so you can get a quick tip in while waiting at the dentist office.\par
When learning new syntax, the most important thing you can do is read code. And the best code is real code. You won\rquote t see foo-bar examples or lots of math expressions in this book. Instead, you\rquote ll work with strings, objects, currency, email addresses, and the like. In other words, the code samples you see will be close to life. This adds a little complexity to the examples, but it will ultimately make it much easier for you to internalize the ideas so that you can bring them into your code quickly and easily.\par
Finally, every sample is available in a repo for this book. The code has nearly 100 percent test coverage, so jump in and try ideas out. To get things working, you\rquote ll need at least Node.js version 8.5 installed. You\rquote ll also occasionally want to try code in a browser. Be sure to use a modern browser such as Chrome, Edge, or Internet Explorer 11+.\par
\b Whom This Book Is For\b0\par
This book is for anyone who has a little programming experience. It helps to have some JavaScript experience, but that\rquote s not strictly necessary. I\rquote ll assume that you know some basic programming concepts, such as loops, conditionals, functions, and classes. In short, if you\rquote ve seen modern JavaScript and you\rquote re excited to learn more, then this book is for you.\par
You may feel like you woke up in a strange new world. That\rquote s not a bad thing. In fact, this new world is awesome\emdash the coffee\rquote s brewing, and the aroma of fresh-baked danishes makes this new world a place you want to wake up to. JavaScript is better than ever\emdash it\rquote s time to enjoy it.\par
Online Resources\par
You can also find the code on github\f0\lang1033  ({{\field{\*\fldinst{HYPERLINK https://github.com/jsmapr1/simplifying-js }}{\fldrslt{https://github.com/jsmapr1/simplifying-js\ul0\cf0}}}}\f0\fs22 )\f1\lang9  or on the book\rquote s Pragmatic Bookshelf website.[2] The website also includes a handy community forum if you\rquote d like to reach out for help along the way. Thanks in advance for reporting any issues that you find in the book code or text via the errata form, also conveniently found on the book website.\par
To stay up-to-date on new syntax changes, you can follow me on twitter\emdash @joesmorgan[3]\emdash or online at thejoemorgan.com.[4] \par
\par
 Chapter 1\par
Signal Intention with Variable Assignment\par
Before we begin, I have a question for you. How many variables did you declare in your code yesterday? It doesn\rquote t matter what language you were writing. Was it ten? A hundred? How about over the last week? Last month? Probably a lot.\par
Now think about how many variables you read yesterday. Maybe you read your own code, or maybe you were skimming someone else\rquote s. Did you see a hundred variables? a thousand? Chances are, you don\rquote t have a clue.\par
Now if I asked you how many curried functions you saw yesterday, I bet you\rquote d know the answer. I can tell you that I saw exactly one curried function yesterday. I know that because even though there\rquote s been lots of ink spilled about curried functions in JavaScript (and I\rquote ll be spilling some myself in Tip 34, \u8203? Maintain Single Responsibility Parameters with Partially Applied Functions \u8203?), it\rquote s not nearly as common as a simple variable declaration. In fact, if you\rquote ve never heard of a curried function, that\rquote s even more proof that they aren\rquote t nearly as important as simple variable declaration. We spend so much time thinking and teaching complex concepts, but something as simple as variable declaration will affect your life and the lives of other developers in a much more significant way.\par
You\rquote re about to rethink JavaScript code from the ground up. And that means you need to start at the most basic level: assigning information to variables. So that\rquote s the theme for our first chapter.\par
Modern JavaScript has several new ways to declare variables. Whenever you start to write a variable, you just need to ask yourself if this will make the code more readable and predictable for the next developer. You\rquote ll find that it actually changes how you write quite a bit.\par
You\rquote re going to look at two new variable declaration types. The first, const, doesn\rquote t allow you to reassign the variable (which you\rquote ll see is a good thing). The second, let, will allow reassignment, but it\rquote s block scoped and will protect you from potential scope conflicts. Finally, you\rquote ll learn how to use template literals to create new strings from your variables.\par
The tips in this chapter will help you understand how your decisions will affect the rest of the code, and also how your decisions will affect anyone else who might eventually pick up and read your code.\par
I hope that as you read this chapter, you begin to critically examine the JavaScript that you write every day. The bonus is that with just a handful of tips, you\rquote ll be well on your way to writing JavaScript code that\rquote s more simple and expressive. And don\rquote t be surprised if the mindset you learn when assessing variable declarations flows out into the rest of your code. After all, it\rquote s the most common decision you\rquote ll make while you write\emdash a decision you\rquote ll make 10, 20, 100 times tomorrow, and next week, and next month.\par
Ready? Good. Let\rquote s begin.\par
\par
Tip 1\tab Signal Unchanging Values with const\par
\par
In this tip, you\rquote ll learn to use const to avoid reassignment and signal your intention to other developers.\par
Modern JavaScript introduced several new variable declarations, which is great. But it also introduced a new problem: Which variable declaration should be the default? And when should we use another type?\par
In the past, you had only one option for non-global variable assignment: var. Now there are many different options\emdash var, let, and const\emdash and each one has an appropriate usage. Try and keep things simple. In most cases, const is the best choice, not because it allows you to do the most, but because it lets you do the least. It has restrictions that make your code more readable.\par
\par

\pard\li720\sa200\sl276\slmult1 ECMAScript 6\par
ECMAScript is the official technical specification for JavaScript. JavaScript incorporated major syntax changes in ECMAScript 5 and ECMAScript 6, which are referred to as ES5 and ES6. Going forward, the spec will be updated yearly. Most developers now refer to the spec by year, such as ES2017.\par

\pard\sa200\sl276\slmult1\par
const is a variable declaration that you can\rquote t reassign within the context of the block. In other words, once you establish it, it can\rquote t be changed. That doesn\rquote t mean it\rquote s immutable\emdash a value that cannot be changed. If it\rquote s assigned to an array, the items in the array can be changed. We\rquote ll look at this more shortly.\par
It may seem odd to developers in other languages with a constant assignment that const is the preferred declaration. In those languages, a constant is usually something you\rquote d write in ALLCAPS and only use on rare occasions to denote things that are never going to change, like the first digits of pi.\par
In JavaScript, though, const is a great default choice precisely because it can\rquote t be reassigned. When you assign a value, you aren\rquote t just declaring a piece of information. You\rquote re also signaling what you plan to do with that information. When you assign values and signal that they won\rquote t be changed, you give future developers (including yourself!) the knowledge that they can forget about a value while they skim the code. And when you\rquote re reading a large amount of code that you haven\rquote t seen before, you\rquote ll be happy that you can forget some of what you read.\par
Let\rquote s assume you\rquote re fixing a bug in a piece of code. You\rquote re skimming through the code to get an idea of how it works and to see if you can guess where the problem might be. Consider two programs. The first program uses const to assign a variable while the second uses var to assign a variable.\par
\par
variables/const/const.js\par
\u8203? \tab\u8203?const\u8203? taxRate = 0.1;\tab\par
\u8203? \tab\u8203?const\u8203? total = 100 + (100 * taxRate);\par
\u8203? \tab\u8203?// Skip 100 lines of code\u8203?\par
\u8203? \tab\u8203?return\u8203? \u8203?\f0\lang1033 `\f1\lang9 Your Order is \u8203?$\{total\}\u8203?`\u8203?;\par
\par
variables/const/const.js\par
\u8203? \tab\u8203?var\u8203? taxRate = 0.1;\u8203? \tab\par
\u8203? \tab\u8203?var\u8203? total = 100 + (100 * taxRate);\par
\u8203? \tab\u8203?// Skip 100 lines of code\u8203?\par
\u8203? \tab\u8203?return\u8203? \u8203?`Your Order is \u8203?$\{total\}\u8203?`\u8203?;\par
\par
They look nearly identical, but the first is much easier to understand. Ignore the fact that a block of code shouldn\rquote t be 100 lines long; you have a large amount of code where lots of changes are occurring.\par
With the first block, you know exactly what will get returned: Your Order is 110. You know this because total is a constant that can\rquote t be reassigned. With the second block, you have no idea what the return value is going to be. You are going to need to go through the 100 lines of additional code looking for loops or conditionals or reassignments or anything that might change the value. Maybe the code is adding a shipping cost. Maybe additional items will be added to the total. Maybe a discount is going to be applied and the total will drop.\par
You have no idea what the total is going to be when it\rquote s assigned with var. When you assign a variable with const, it removes one additional piece of information that you need to retain in your head while reading code. Consider one last example:\par
\par
variables/const/const.js\par
\u8203? \tab\u8203?const\u8203? taxRate = 0.1;\par
\u8203? \tab\u8203?const\u8203? shipping = 5.00;\par
\u8203? \tab\u8203?let\u8203? total = 100 + (100 * taxRate) + shipping;\u8203? \tab\par
\u8203? \tab\u8203?// Skip 100 lines of code\u8203?\par
\u8203? \tab\u8203?return\u8203? \u8203?`Your Order is \u8203?$\{total\}\u8203?`\u8203?;\par
\par
Take a moment and think about what you can be certain of from this code. You know you can\rquote t be sure of the total. The developers have signaled that taxRate and shipping are unchanging (if only that were true), but the total isn\rquote t permanent. You know this value can\rquote t be trusted.\par
The best case is to know that an assignment won\rquote t change. The second best case is to know that it might change. If you can see that the developers used const regularly and let rarely, you can guess areas of change.\par
Make all variable assignments either a known-known or a known-unknown.\par
There\rquote s one important consideration when using const: A value assigned to const is not immutable. In other words, you can\rquote t reassign the variable, but you can change the value. That may seem contradictory, but here it is in practice.\par
variables/const/const.js\par
\u8203? \tab\u8203?const\u8203? discountable = [];\par
\u8203? \tab\u8203?// Skip some lines\u8203?\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < cart.length; i++) \{\par
\u8203? \tab\u8203?if\u8203? (cart[i].discountAvailable) \{\par
\u8203? \tab\f0\lang1033\tab\f1\lang9 discountable.push(cart[i]);\par
\u8203? \tab\}\par
\u8203? \tab\}\par
\par
This is perfectly valid code. Even though discountable is assigned with const, you can still push items to it. This creates the exact problem we saw earlier: You can\rquote t be certain of what you\rquote ll see later in the code. For objects, arrays, or other collections, you\rquote ll need to be more disciplined.\par
\par
There\rquote s no clear consensus on what you should use, but your best bet is to avoid mutations as much as possible.\par
\par
Here\rquote s an example of the previous code written without mutations.\par
variables/const/const.js\par
\u8203? \tab\u8203?const\u8203? discountable = cart.filter(item => item.discountAvailable);\par
Same result. No mutations. If the code is confusing, you can jump to Chapter 5, \u8203?Simplify Loops\u8203? for more information about array methods.\par
For now, just use const as a default. Once the code changes to the point where const is no longer appropriate, you can try a different declaration.\par
In the next tip, you\rquote ll see precisely when const is no longer an appropriate choice and why you should use a new declaration: let. \par
\par
Tip 2\tab Reduce Scope Conflicts with let and const\par
In this tip, you\rquote ll learn that in cases where a value is going to change, let is the best choice.\par
You saw in the previous tip that when you\rquote re working with variables, you\rquote re better off avoiding reassignment. But what do you do in situations where you really need to reassign a variable? In those cases, you should use let.\par
let is similar to var because it can be reassigned, but unlike var, which is lexically scoped, let is block scoped. You\rquote ll explore scope more in Tip 3, \u8203? Isolate Information with Block Scoped Variables \u8203?. For now, just know that block scoped variables exist only in blocks, such as an if block or a for loop. Outside those blocks, they aren\rquote t accessible. As a rule, this means the variable doesn\rquote t exist outside the curly braces in which it was declared.\par
To see how a block scoped or a lexically scoped variable can change code, consider an example. This code looks for the lowest price for an item. To find the lowest price, it makes three simple checks:\par

\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1     If there is no inventory: Return 0.\par
{\pntext\f2\'B7\tab}    If there is a sale price and sale inventory: Return sale price.\par
{\pntext\f2\'B7\tab}    If there is no sale price or no sale inventory: Return price.\par

\pard\sa200\sl276\slmult1\par
variables/let/problem.js\par
\u8203?1: \tab\u8203?function\u8203? getLowestPrice(item) \{\par
\u8203?- \tab   \u8203?var\u8203? count = item.inventory; \par
\u8203?- \tab   \u8203?var\u8203? price = item.price;\par
\u8203?- \tab\par
\u8203?5: \tab   \u8203?if\u8203? (item.salePrice) \{\par
\u8203?- \tab     \u8203?var\u8203? count = item.saleInventory; \par
\u8203?- \tab     \u8203?if\u8203? (count > 0) \{\par
\u8203?- \tab       price = item.salePrice;\par
\u8203?- \tab     \}\par
\u8203?10: \tab   \}\par
\u8203?- \tab\par
\u8203?- \tab   \u8203?if\u8203? (count) \{ \par
\u8203?- \tab     \u8203?return\u8203? price;\par
\u8203?- \tab   \}\par
\u8203?15: \tab\par
\u8203?- \tab   \u8203?return\u8203? 0;\par
\u8203?- \tab\}\par
\par
Take a moment and see if you can find the bug.\par
Look at each expected outcome and see what you can find. Alternatively, you can run the test suite.[5]\par
Did you find it? The problem is that you\rquote re reassigning a variable to the same variable name.\par
If you have an item with no inventory and no sale price, the item.salePrice conditional will be skipped and you\rquote ll get 0.\par
variables/let/let.spec.js\par
\u8203? \tab\u8203?const\u8203? item = \{\par
\u8203? \tab   inventory: 0,\par
\u8203? \tab   price: 3,\par
\u8203? \tab   salePrice: 0,\par
\u8203? \tab   saleInventory: 0,\par
\u8203? \tab\};\par
\par
Next, if you have a sale price and a sale inventory, you get the sale price. In this case, the returned value will be 2.\par
variables/let/let.spec.js\par
\u8203? \tab\u8203?const\u8203? item = \{\par
\u8203? \tab   inventory: 3,\par
\u8203? \tab   price: 3,\par
\u8203? \tab   salePrice: 2,\par
\u8203? \tab   saleInventory: 1,\par
\u8203? \tab\};\par
\par
Finally, if you have a sale price but no sale inventory, you expect to get the regular price, 3. What you actually get is 0.\par
variables/let/let.spec.js\par
\u8203? \tab\u8203?const\u8203? item = \{\par
\u8203? \tab   inventory: 3,\par
\u8203? \tab   price: 3,\par
\u8203? \tab   salePrice: 2,\par
\u8203? \tab   saleInventory: 0,\par
\u8203? \tab\};\par
\par
If you\rquote re still a little confused, that\rquote s okay. It\rquote s a tricky bug. The problem is that you declare the variable count on lines 2 to 3. There\rquote s a sale price, so you go into the next if block. At this point, you redeclare the variable count on line 6. Now the problem is that this is set to 0 because there\rquote s no more sale inventory. By the time you get to the next if block on line 12, the inventory is wrong. It looks like there\rquote s no sale inventory and no regular priced inventory. Even though you have a regular inventory, you\rquote re accidentally checking the sale inventory and returning the wrong value.\par
\par
You might want to dismiss this problem as trivial. But bugs like this are subtle and hard to catch if they make it into production.\par
\par
Fortunately, you can avoid this issue using let. In fact, let helps you avoid this issue in two ways.\par
\par
let is block scoped, which again means any variable declared inside a block doesn\rquote t exist outside the block.\par
variables/let/let.js\par
\u8203? \tab\u8203?function\u8203? getLowestPrice(item) \{\par
\u8203? \tab   \u8203?let\u8203? count = item.inventory;\par
\u8203? \tab   \u8203?let\u8203? price = item.price;\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (item.salePrice) \{\par
\u8203? \tab     \u8203?let\u8203? count = item.saleInventory;\par
\u8203? \tab     \u8203?if\u8203? (count > 0) \{\par
\u8203? \tab       price = item.salePrice;\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (count) \{\par
\u8203? \tab     \u8203?return\u8203? price;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? 0;\par
\u8203? \tab\}\par
\par
In this case, using let to declare the count variable in the if block isn\rquote t going to conflict with the count variable declared at the start of the function.\par
\par
Of course, let isn\rquote t the only variable declaration that\rquote s block scoped. const is also block scoped. Because you\rquote re never reassigning count, you can use const instead and keep things even more clear, although you\rquote ll need to continue to use let to declare price because that may update. Honestly, you should just use different names to keep things clear. The final code would be this:\par
variables/let/const.js\par
\u8203? \tab\u8203?function\u8203? getLowestPrice(item) \{\par
\u8203? \tab   \u8203?const\u8203? count = item.inventory;\par
\u8203? \tab   \u8203?let\u8203? price = item.price;\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (item.salePrice) \{\par
\u8203? \tab     \u8203?const\u8203? saleCount = item.saleInventory;\par
\u8203? \tab     \u8203?if\u8203? (saleCount > 0) \{\par
\u8203? \tab       price = item.salePrice;\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (count) \{\par
\u8203? \tab     \u8203?return\u8203? price;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? 0;\par
\u8203? \tab\}\par
\par
As an added bonus, let and const have another protection. You can\rquote t redeclare a variable of the same name. With var, you can redeclare a variable of the same name in the same scope. In other words, you can say var price = 1 at, say line 10 and var price = 5 at line 25 with no conflict. This can be a huge problem if you unintentionally reuse a variable name. With let, you can\rquote t make this mistake.\par
\par
This code would generate a TypeError.\par
variables/let/declaration.js\par
\u8203? \tab\u8203?function\u8203? getLowestPriceDeclaration(item) \{\par
\u8203? \tab   \u8203?const\u8203? count = item.inventory;\par
\u8203? \tab   \u8203?let\u8203? price = item.price;\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (!count) \{\par
\u8203? \tab     \u8203?return\u8203? 0;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?// ...\u8203?\par
\u8203? \tab\par
\u8203? \tab   \u8203?let\u8203? price = item.saleInventory ? item.salePrice : item.wholesalePrice;\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? price;\par
\u8203? \tab\}\par
\par
This issue won\rquote t come up often, but it\rquote s a nice way to catch a potential bug early in the process.\par
\par
In the next tip, you\rquote ll take a deeper look into scope and how let solves one of the most common and perplexing scope conflicts in JavaScript. \par
\par
Tip 3\tab Isolate Information with Block Scoped Variables\par
\par
In this tip, you\rquote ll learn how let prevents scope conflict in for loops and other iterations.\par
\par
At one point or another, every developer will make the mistake of capturing the wrong variable during a for loop. The traditional solution involves some pretty advanced JavaScript concepts. Fortunately, the let variable declaration makes this complex issue disappear.\par
\par
Remember, when you use a block scoped variable declaration, you\rquote re creating a variable that\rquote s only accessible in the block. A variable declared in an if block isn\rquote t available outside the curly braces. A variable declared inside a for loop isn\rquote t available outside the curly braces of the for loop. But that doesn\rquote t mean you can\rquote t access variables declared outside a function. If you declare a block scope variable at the top of a function, it is accessible inside the block.\par
\par
If you declare a lexically scoped variable, however, it\rquote s accessible anywhere inside a function. A variable created inside an if block can be accessed anywhere else in the function. In fact, you can even access a variable before it was declared because of a compile process called hoisting.[6]\par
\par
If that all seems too abstract, that\rquote s fine. It\rquote s easier to understand in practice. Chances are, if you\rquote ve encountered a lexical scope issue before, it probably occurred when you were adding a click function to a series of DOM elements:\par
variables/scope/scope.html\par
\u8203? \tab\u8203?<!doctype html>\u8203?\par
\u8203? \tab\par
\u8203? \tab <html lang=\u8203?"en"\u8203?>\par
\u8203? \tab     <body>\par
\u8203? \tab         <ul style=\u8203?"cursor:pointer"\u8203?>\par
\u8203? \tab             <li> Say Zero </li>\par
\u8203? \tab             <li> Say One </li>\par
\u8203? \tab             <li> Say Two </li>\par
\u8203? \tab         </ul>\par
\u8203? \tab     </body>\par
\u8203? \tab     <script>\par
\u8203? \tab         \u8203?const\u8203? items = document.querySelectorAll(\u8203?'li'\u8203?);\par
\u8203? \tab         \u8203?for\u8203?(\u8203?var\u8203? i = 0; i< items.length; i++) \{\par
\u8203? \tab             items[i].addEventListener(\u8203?'click'\u8203?, () => \{\par
\u8203? \tab                 alert(i);\par
\u8203? \tab             \})\par
\u8203? \tab         \};\par
\u8203? \tab     </script>\par
\u8203? \tab </html>\par
\par
Open this code in a browser and try clicking on one of the list elements. You\rquote ll find that every click will give the same result: 3.\par
\par
It\rquote s tempting to think this is a browser bug, but it\rquote s actually more related to how JavaScript assigns variables. It can happen anywhere, even in regular JavaScript code. Let\rquote s look at how this issue can occur even in plain JavaScript without DOM manipulation.\par
\par
If you paste this code into a browser console or a REPL, you\rquote ll see the same problem.\par
variables/scope/problem.js\par
\u8203?1: \tab\u8203?function\u8203? addClick(items) \{\par
\u8203?2: \tab   \u8203?for\u8203? (\u8203?var\u8203? i = 0; i < items.length; i++) \{\par
\u8203?3: \tab     items[i].onClick = \u8203?function\u8203? () \{ \u8203?return\u8203? i; \}; \par
\u8203?4: \tab   \}\par
\u8203?5: \tab   \u8203?return\u8203? items;\par
\u8203?6: \tab\}\par
\u8203?7: \tab\u8203?const\u8203? example = [\{\}, \{\}];\par
\u8203?8: \tab\u8203?const\u8203? clickSet = addClick(example);\par
\u8203?9: \tab clickSet[0].onClick();\par
Using REPLs\par
\par
REPL is an acronym for "read evaluate print loop." It is one of the most valuable tools you can have when working with code. A REPL is simply a command-line interface where you type in some code and the REPL immediately evaluates it and returns the result.\par
\par
For example, type in 2+2 and you\rquote ll get 4. These are great when you can\rquote t quite remember syntax and want to give it a quick check. I can never remember the method for making a string uppercase, which is a problem when I need to yell something. To refresh my memory, I\rquote ll go into a REPL and type \rquote hi!\rquote .upperCase(), which gives me an error. Then I\rquote ll try again with \rquote hi!\rquote .toUpperCase(); //HI!, which works and off I go.\par
\par
Where are these REPLs? If you have Node.js installed on your computer (which you should), go to a command line and type node and you\rquote ll be dropped into a REPL.\par
\par
If you are debugging code in a browser, you also have a REPL at your fingertips, though it is called console in most browsers. All modern browsers have developer tools that contain a console of some sort. This is another place where you can type JavaScript code and see immediate results. As a bonus, this will help you check which features are natively implemented on that particular browser.\par
\par
No matter which array element you try, you\rquote ll get the same result.\par
\par
Why is this happening?\par
\par
The problem again is scope. Variables assigned with var are functionally scoped (which, again, is technically referred to as lexically scoped). That means that they\rquote ll always refer to the last value they\rquote re assigned within a function.\par
\par
When you set a new function on line 3 in the preceding example, you\rquote re saying to return the value i whatever it may be at the time you call the code. You are not saying: return the value of i at the time it\rquote s set. As a result, because i belongs to the function, the value changes on each loop iteration.\par
\par
The traditional solution is complicated, and it can confuse even the most experienced JavaScript developers.\par
variables/scope/curry.js\par
\u8203? \tab\u8203?function\u8203? addClick(items) \{\par
\u8203? \tab   \u8203?for\u8203? (\u8203?var\u8203? i = 0; i < items.length; i++) \{\par
\u8203? \tab     items[i].onClick = (\u8203?function\u8203? (i) \{\par
\u8203? \tab       \u8203?return\u8203? \u8203?function\u8203? () \{\par
\u8203? \tab         \u8203?return\u8203? i;\par
\u8203? \tab       \};\par
\u8203? \tab     \}(i));\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? items;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?const\u8203? example = [\{\}, \{\}];\par
\u8203? \tab\u8203?const\u8203? clickSet = addClick(example);\par
\u8203? \tab clickSet[0].onClick();\par
\par
It involves a combination of closures (creating a variable inside a function for another function to use), higher-order functions (functions that return other functions), and self-invoking functions. If you don\rquote t understand that, it\rquote s fine. You\rquote ll learn more about higher-order functions in Tip 34, \u8203? Maintain Single Responsibility Parameters with Partially Applied Functions \u8203?.\par
\par
Fortunately, you don\rquote t need to understand these higher concepts quite yet. If you rewrite the preceding code using let, you\rquote ll get the same results without the extra code clutter. Test out the following code in a browser console or REPL and you\rquote ll get the results you were expecting.\par
variables/scope/scope.js\par
\u8203?1: \tab\u8203?function\u8203? addClick(items) \{\par
\u8203?2: \tab   \u8203?for\u8203? (\u8203?let\u8203? i = 0; i < items.length; i++) \{ \par
\u8203?3: \tab     items[i].onClick = \u8203?function\u8203? () \{ \u8203?return\u8203? i; \};\par
\u8203?4: \tab   \}\par
\u8203?5: \tab   \u8203?return\u8203? items;\par
\u8203?6: \tab\}\par
\u8203?7: \tab\u8203?const\u8203? example = [\{\}, \{\}];\par
\u8203?8: \tab\u8203?const\u8203? clickSet = addClick(example);\par
\u8203?9: \tab clickSet[0].onClick();\par
\par
Looking at line 3, you\rquote ll notice the only thing you changed is using let instead of var. Because let is blocked scoped, any variable declared inside the for block belongs only to that block. So even if the value changes in another iteration, the value won\rquote t change on the previously declared function.\par
\par
In simpler terms, let locks the value during each iteration of the for loop.\par
\par
Because let can do nearly everything var can do, it\rquote s always best to use let whenever you might otherwise use var.\par
\par
I hope this gave you some ideas for how to declare variables. You will find in upcoming tips that variable declaration is so important that you may want to restructure whole code blocks to keep declarations clear and predictable.\par
\par
In the next tip, you\rquote ll look at how to transform data to readable strings using template literals. \par
\f0\par
Tip 4\tab Convert Variables to Readable Strings with Template Literals\par
\par
In this tip, you will learn how to convert variables into new strings without concatenation.\par
\par
Strings are messy. That\rquote s all there is to it. When you\rquote re pulling information from strings, you have to deal with the ugliness of natural language: capitalization, punctuation, misspellings. It\rquote s a headache.\par
\par
Collecting information into strings is less painful, but it can still get ugly quickly. Combining strings in JavaScript can be particularly rough, especially when you combine strings assigned to variables with strings surrounded by quotes.\par
\par
Here\rquote s a situation that comes up all the time: You need to build a URL. In this case, you\rquote re building a link to an image on a cloud service. Your cloud service is pretty great, though. In addition to hosting the asset, you can pass query parameters that will convert the asset in a variety of ways (height, width, and so on).\par
\par
To keep things relatively simple, you\rquote re going to make a function that creates a URL by combining your cloud provider URL with the ID of the image and the width as a query parameter.\par
\par
To keep things complicated, you\rquote re going to combine regular strings with strings that are returned from a function, strings that are assigned to variables, and strings that are converted right before concatenation. You\rquote re going to use a function (implemented elsewhere) that will return a cloud provider such as pragprog.com/cloud. Your function will take ID and width as parameters, but it will need to parse the width to make sure it\rquote s an integer.\par
\par
URLs get particularly ugly because you have to add slashes between the parts of a route along with the building blocks of queries such as ?, =, and &. Traditionally, you have to combine each piece with a + sign.\par
\par
The final result looks like this:\par
variables/literals/problem.js\par
\u8203? \tab\u8203?function\u8203? generateLink(image, width) \{\par
\u8203? \tab   \u8203?const\u8203? widthInt = parseInt(width, 10);\par
\u8203? \tab   \u8203?return\u8203? \u8203?'https://'\u8203? + getProvider() + \u8203?'/'\u8203? + image + \u8203?'?width='\u8203? + widthInt;\par
\u8203? \tab\}\par
\par
There\rquote s a lot going on there, and the combination of information and + signs doesn\rquote t help. And this is a particularly simple URL. They can get more complicated fast. What if the route was longer or you needed an additional four parameters? These things get long.\par
\par
Fortunately, you can cut down the complexity quite a bit using template literals. Template literals are a simple syntax that lets you combine strings along with JavaScript expressions to create a new string.\par
\par
There are only two things you need to know: First, a template literal is surrounded by backticks (\lquote ) instead of single or double quotes. Second, anything that\rquote s not a string (including strings assigned to variables) needs to be surrounded by a special designator: a $ sign with the variables or other JavaScript code in curly braces: \lquote $\{stuff\}\lquote .\par
\par
You\rquote ll most often use this for combining strings and variables.\par
variables/literals/literals.js\par
\u8203? \tab\u8203?function\u8203? greet(name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Hi, \u8203?$\{name\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab greet(\u8203?'Leo'\u8203?);\par
\u8203? \tab\u8203?'Hi, Leo'\u8203?;\par
\par
But you can also perform JavaScript actions. For example, you can call a method on a object. In this case, you\rquote re converting a string to uppercase:\par
variables/literals/literals.js\par
\u8203? \tab\u8203?function\u8203? yell(name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`HI, \u8203?$\{name.toUpperCase()\}\u8203?!`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab greet(\u8203?'Pankaj'\u8203?);\par
\u8203? \tab\u8203?'HI, PANKAJ!'\u8203?;\par
\par
You can even perform more complex computations, such as combining math calculations. Really, you can perform any action in the curly braces, but it would only make sense to perform actions that return a string or integer.\par
variables/literals/literals.js\par
\u8203? \tab\u8203?function\u8203? leapYearConverter(age) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`You'd be \u8203?$\{Math.floor(age / 4)\}\u8203? if born on a leap year.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab leapYearConverter(34);\par
\u8203? \tab\u8203?// "You'd be 8 if born on a leap year."\u8203?\par
\par
Try not to do much with the curly braces. It can be more cluttered than it\rquote s worth. If you need to do heavy data conversions, perform the action outside the template literal and assign the result to a variable.\par
\par
You now have all the tools to rewrite your original string concatenation as a single template literal. Take a moment and try it out.\par
\par
Your solution probably looks something like this:\par
variables/literals/literals.js\par
\u8203? \tab\u8203?function\u8203? generateLink(image, width) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`https://\u8203?$\{getProvider()\}\u8203?/\u8203?$\{image\}\u8203??width=\u8203?$\{parseInt(width, 10)\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
Doesn\rquote t that look significantly cleaner? Template literals are such an improvement on string concatenation that you should rarely ever combine strings with traditional concatenation. The only time it would be better is if you\rquote re combining two variables with no additional information. Even in that case, you may still use template literals because those backticks are a clue to other developers that you\rquote re returning a string.\par
\par
In the next chapter, you\rquote re going to learn about how to use collections of data. You\rquote ll be building on many of the ideas in this chapter as you make choices between new and existing collections.\par
Footnotes\par
\par
[5]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://pragprog.com/titles/es6tips/source_code }}{\fldrslt{https://pragprog.com/titles/es6tips/source_code\ul0\cf0}}}}\f0\fs22\par
[6]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Glossary/Hoisting }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\ul0\cf0}}}}\f0\fs22\par
\par
 Chapter 2\par
Manage Data Collections with Arrays\par
The ancient Greek poet Archilochus wrote, \ldblquote A fox knows many things, but a hedgehog one important thing.\rdblquote  The great historian Isaiah Berlin said all thinkers are either hedgehogs or foxes. I think the same is true of syntax.\par
As you\rquote ve seen, const is a hedgehog. It can only do one thing\f1\emdash make an unchanging declaration. By only doing one thing, it makes your code readable and predictable. As you\rquote ll see in upcoming tips, array methods are all hedgehogs. They can do only one thing on an array. But they do it well, so you can safely predict outcomes without diving into the details.\par
For the most part, you want to stick with syntax that does one thing very well. But there are times when you need things to be flexible. An array is the ultimate fox because it can do many things. In fact, it can do almost anything you\rquote d ever want for a collection of information. More importantly, many other collections use concepts that you\rquote d most often associate with arrays.\par
For example, when you have a string, \rquote hedgehog\rquote , you have a lot of available actions you\rquote d normally perform on arrays. You can get the size: \rquote hedgehog\rquote .length will return 8. You can also pick out individual letters by index: \rquote hedgehog\rquote [3] will return \rquote g\rquote . There are so many other methods that it would take too long to list them all.\par
These methods don\rquote t belong to arrays specifically (they rely on a property called Iterator), but they\rquote re most intuitively connected to arrays. When you study arrays carefully, you\rquote ll gain many insights into other data structures. Arrays know many things. They are foxes.\par
In this chapter, you\rquote ll see that arrays are becoming better than ever. Not only are they a good choice for many data needs, but they have new syntax that reduces many common actions to one-liners while simultaneously reducing mutations that can cause subtle bugs. And pay attention\emdash you\rquote ll see the same ideas in later tips.\par
To begin, you\rquote ll see how data can always be converted to arrays, including converting other collections (such as objects) to arrays when necessary. From there, you\rquote ll learn new syntax, such as includes(), to test existence in arrays and, crucially, the spread operator symbolized by three dots (...). The spread operator is so important in the modern use of arrays that the next two tips will explore how the spread operator changes how you use arrays in your code. Pay close attention\emdash you\rquote ll see the spread operator in many future tips.\par
To keep code readable, you should stick with simple, predictable approaches (hedgehogs). But to make code flexible, you need arrays to move between structures. It\rquote s a tough balancing act, but you need both. Everything you do in JavaScript will be easier if you have a clear understanding of arrays.\par
Time to jump in and see how arrays provide a level of flexibility you won\rquote t find in most collections.\f0\par
\par
Tip 5\tab Create Flexible Collections with Arrays\par
\par
In this tip, you\rquote ll learn how arrays maximize flexibility and give you a foundation for understanding all other collections.\par
\par
In JavaScript, there used to be only two structures for collections of data: arrays and objects. That list is growing. Now there are maps, sets, weakmaps, weaksets, objects, and arrays.\par
\par
When choosing a collection, you have to ask yourself what you need to do with the information. If you need to manipulate it in any way (add, remove, sort, filter, alter all members), then arrays are often the best collection. And even when you don\rquote t use an array, you\rquote ll almost certainly use ideas that you\rquote d associate with arrays.\par
\par
Arrays have a remarkable amount of flexibility. Because arrays preserve order, you can add and remove items according to their position or determine if they have a position at all. You can sort to give the array a new order as you\rquote ll see in Tip 9, \u8203? Avoid Sort Confusion with the Spread Operator \u8203?.\par
arrays/arrays/arrays.js\par
\u8203? \tab\u8203?const\u8203? team = [\par
\u8203? \tab   \u8203?'Joe'\u8203?,\par
\u8203? \tab   \u8203?'Dyan'\u8203?,\par
\u8203? \tab   \u8203?'Bea'\u8203?,\par
\u8203? \tab   \u8203?'Theo'\u8203?,\par
\u8203? \tab ];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? alphabetizeTeam(team) \{\par
\u8203? \tab   \u8203?return\u8203? [...team].sort();\par
\u8203? \tab   \u8203?// ['Bea', 'Dyan', 'Joe', 'Theo']\u8203?\par
\u8203? \tab\}\par
\par
Interestingly, order is not technically guaranteed,[7] but it\rquote s safe to assume that it will work in nearly all circumstances.\par
\par
With array methods such as map(), filter(), and reduce(), you can alter or update the information easily with single lines, as you\rquote ll see starting with Tip 22, \u8203? Create Arrays of a Similar Size with map() \u8203?.\par
arrays/arrays/arrays.js\par
\u8203? \tab\u8203?const\u8203? staff = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Wesley'\u8203?,\par
\u8203? \tab     position: \u8203?'musician'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Davis'\u8203?,\par
\u8203? \tab     position: \u8203?'engineer'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getMusicians(staff) \{\par
\u8203? \tab   \u8203?return\u8203? staff.filter(member => member.position === \u8203?'musician'\u8203?);\par
\u8203? \tab   \u8203?// [\{name: 'Wesley', position: 'musician'\}]\u8203?\par
\u8203? \tab\}\par
\par
You may notice some strange looking syntax. Don\rquote t worry\f1\emdash you\rquote ll get to it soon. A lot of the new syntax in ES5 and ES6 is related to arrays. That should be a clue that they\rquote re valued highly in the JavaScript community.\par
Still, you\rquote ll need to use other collections. Yet, a solid understanding of arrays will greatly improve your code because arrays are at the heart of many popular data manipulations. For example, if you need to iterate over an object, the first thing you\rquote d do is get the keys into an array with Object.keys() and then iterate over those. You\rquote re using an array as a bridge between the object and a loop.\par
arrays/arrays/arrays.js\par
\u8203? \tab\u8203?const\u8203? game1 = \{\par
\u8203? \tab   player: \u8203?'Jim Jonas'\u8203?,\par
\u8203? \tab   hits: 2,\par
\u8203? \tab   runs: 1,\par
\u8203? \tab   errors: 0,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? game2 = \{\par
\u8203? \tab   player: \u8203?'Jim Jonas'\u8203?,\par
\u8203? \tab   hits: 3,\par
\u8203? \tab   runs: 0,\par
\u8203? \tab   errors: 1,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? total = \{\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? stats = Object.keys(game1);\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < stats.length; i++) \{\par
\u8203? \tab   \u8203?const\u8203? stat = stats[i];\par
\u8203? \tab   \u8203?if\u8203? (stat !== \u8203?'player'\u8203?) \{\par
\u8203? \tab     total[stat] = game1[stat] + game2[stat];\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   hits: 5,\u8203?\par
\u8203? \tab\u8203?//   runs: 1,\u8203?\par
\u8203? \tab\u8203?//   errors: 1\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
Arrays seem to pop up everywhere because they have a built-in iterable.[8] An iterable is merely a way for the code to go through a collection one item at a time while knowing its current position. Any action you can perform on an array you can also perform on any data type that has an iterable (such as strings) or one that you can quickly transform into an iterable (as with Object.keys()).\par
\par
If you know that you can create a new array with the spread operator, as you\rquote ll see in Tip 7, \u8203? Mold Arrays with the Spread Operator \u8203?, then you know that you can create a new Map with the spread operator because it also has a built-in iterable, as you\rquote ll see in Tip 14, \u8203? Iterate Over Key-Value Data with Map and the Spread Operator \u8203?.\par
\par
Finally, you can express nearly every collection concept in the form of an array, which means you can easily convert from an array to a specialized collection and back again. Think about an object as a key-value store.\par
arrays/arrays/arrays.js\par
\u8203? \tab\u8203?const\u8203? dog = \{\par
\u8203? \tab   name: \u8203?'Don'\u8203?,\par
\u8203? \tab   color: \u8203?'black'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab dog.name;\par
\u8203? \tab\u8203?// Don\u8203?\par
\par
You can describe that same concept, a key-value store, as an array of arrays. The internal arrays contain only two items. The first item is a key. The second item is the value. This particular structure, an array consisting of two items, is also called a pair. Finding the value for a specific key is merely a matter of finding the pair with the correct key name and then returning the second item.\par
arrays/arrays/arrays.js\par
\u8203? \tab\u8203?const\u8203? dogPair = [\par
\u8203? \tab   [\u8203?'name'\u8203?, \u8203?'Don'\u8203?],\par
\u8203? \tab   [\u8203?'color'\u8203?, \u8203?'black'\u8203?],\par
\u8203? \tab ];\par
\u8203? \tab\u8203?function\u8203? getName(dog) \{\par
\u8203? \tab   \u8203?return\u8203? dog.find(attribute => \{\par
\u8203? \tab     \u8203?return\u8203? attribute[0] === \u8203?'name'\u8203?;\par
\u8203? \tab   \})[1];\par
\u8203? \tab\}\par
\par
Admittedly, that\rquote s a lot of extra code for something so simple. You certainly wouldn\rquote t put this in a code base, but it\rquote s good to know that an object could be an array of pairs.\par
\par
In fact, you\rquote ll use pairs to convert data between the Map object and an array. And now that the TC39 committee has finalized the spec to convert an object to an array of pairs using Object.entries(),[9] you\rquote ll be able to use any array technique on objects with a quick conversion.\par

\pard\li720\sa200\sl276\slmult1 The TC39 Committee\par
What does it mean that something is part of a finalized spec? The JavaScript spec is determined by a committee called the TC39 committee. They take proposals for syntax changes through a standard process before defining their official specifications (or spec). You\rquote ll often hear developers refer to \ldblquote stage 1\rdblquote  or \ldblquote stage 2\rdblquote  features when talking about features still in the review process. This just means that they are still being finalized but are on the way to adoption as part of the spec. After a piece of syntax is approved, browsers start to work on native implementations.\par
In other words, there are always new syntax changes on the way. Up until ES6, you would refer to syntax changes by version such as ES5 or ES6. From now on, you will see syntax changes by year such as ES2017, ES2018, and so on. To add to the confusion, because most JavaScript will still need to be compiled to earlier syntax to be compatible with older browsers, you can use syntax before it\rquote s final. This can be dangerous, but occasionally there are features that are so popular they are affectively adopted by the community before they are officially approved. New syntax features such as async and await or the Object spread are used before they are official.\par

\pard\sa200\sl276\slmult1\par
Having a deep understanding of arrays, and most iterables by proxy, will let you grasp not only many of the new ES6 features that we\rquote re about to explore, but also many new features that are coming soon.\par
In the next tip, you\rquote ll begin to work with arrays by learning how testing existence in arrays has become even easier with includes().\f0\par
\par
Tip 6\tab Check Existence in an Array with Includes()\par
In this tip, you\rquote ll learn how to find out if a value exists in an array without checking position.\par
It\rquote s easy to get so caught up in the big exciting changes in a language (such as the spread operator, which you\rquote ll see in a moment) that you miss the small changes that simplify common tasks.\par
Arrays now have an easy improvement to handle a common problem: testing existence. Testing existence is an important action, and it\rquote s crucial in everything from ternaries (Tip 18, \u8203? Check Data Quickly with the Ternary Operator \u8203?), to short circuiting (Tip 19, \u8203? Maximize Efficiency with Short Circuiting \u8203?), to most conditionals in general.\par
Testing existence with JavaScript arrays has always been a little clunky. For example, if you want to see if an array contains a certain string, you check to see if the string has a position (position being another feature of an iterable). If the position exists, you\rquote ll get the index. If not, you get -1. The problem is that the index can be 0, which evaluates to false (also known as being falsy). This means the existence can be true, but the check can evaluate to false.\par
arrays/includes/problem.js\par
\u8203? \tab\u8203?const\u8203? sections = [\u8203?'shipping'\u8203?];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? displayShipping(sections) \{\par
\u8203? \tab   \u8203?if\u8203? (sections.indexOf(\u8203?'shipping'\u8203?)) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?true\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?false\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// false\u8203?\par
\par
Because of this unfortunate situation, a position at 0 being falsy, you have to compare the index against a number and not just test that it\rquote s truthy. It\rquote s not a big problem, but it\rquote s just extra code to remember. Jump ahead to Tip 17, \u8203? Shorten Conditionals with Falsy Values \u8203? for more on falsy values.\par
arrays/includes/greater.js\par
\u8203? \tab\u8203?const\u8203? sections = [\u8203?'contact'\u8203?, \u8203?'shipping'\u8203?];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? displayShipping(sections) \{\par
\u8203? \tab   \u8203?return\u8203? sections.indexOf(\u8203?'shipping'\u8203?) > -1;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// true\u8203?\par
\par
Fortunately, another feature coming up in ES2017 will eliminate that boilerplate comparison. The new array method, called includes(),[10] will check to see if a value exists in an array and return a Boolean of true or false.\par
You can rewrite the preceding code with a simple check.\par
arrays/includes/includes.js\par
\u8203? \tab\u8203?const\u8203? sections = [\u8203?'contact'\u8203?, \u8203?'shipping'\u8203?];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? displayShipping(sections) \{\par
\u8203? \tab   \u8203?return\u8203? sections.includes(\u8203?'shipping'\u8203?);\par
\u8203? \tab\}\par
\par
This may seem like a trivial change, but after writing -1 over and over in a codebase, or even worse, forgetting and getting false negatives on a zero-indexed value, it\rquote s a welcome change.\par
Now that you\rquote ve seen how integral arrays are to JavaScript, you\rquote ll dive into them a little more as we explore some of the new features that make them even more exciting and powerful. It\rquote s best to get comfortable with arrays because they\rquote re everywhere in JavaScript. And even if you aren\rquote t using them directly, don\rquote t be surprised if a lot of what you learn about arrays begins to show up in other collections.\par
In the next tip, you\rquote ll learn how to use the most interesting and powerful new technique for working with arrays: the spread operator. \par
\par
Tip 7\tab Mold Arrays with the Spread Operator\par
In this tip, you\rquote ll learn how to simplify many array actions with the spread operator.\par
As you\rquote ve seen, arrays provide an incredible amount of flexibility for working with data. But the number of methods that an array contains can be confusing, and it could lead you to some problems with mutations and side effects. Fortunately, the spread operator gives you a way to create and manipulate arrays quickly with minimal code.\par
\par
The spread operator, symbolized with three dots (...), may be the most widely used new feature in JavaScript. You\rquote re likely to find it in nearly every file containing ES6+ syntax.\par
\par
That said, it\rquote s hard to take the spread operator seriously. I certainly didn\rquote t. What it does is so mundane: It converts an array to a list of items. Turns out, that tiny action has many benefits that we\rquote ll explore in the next few tips.\par
\par
The benefits don\rquote t end with just arrays. You\rquote ll see the spread operator over and over. It pops up in the Map collection, as you\rquote ll see in Tip 14, \u8203? Iterate Over Key-Value Data with Map and the Spread Operator \u8203?. You\rquote ll use a variation called the rest operator in functions, as you\rquote ll see in Tip 31, \u8203? Pass a Variable Number of Arguments with the Rest Operator \u8203?. And you can use the spread operator on any data structure or class property using generators, as you\rquote ll see in Tip 41, \u8203? Create Iterable Properties with Generators \u8203?.\par
\par
I hope that I\rquote ve sparked your interest. To start, try using the spread operator on a simple array.\par
\par
You begin with an array of items.\par
\u8203? \tab\u8203?const\u8203? cart = [\u8203?'Naming and Necessity'\u8203?, \u8203?'Alice in Wonderland'\u8203?];\par
\par
You then use the spread operator (...) to turn that into a list\f1\emdash a series of items that you can use in parameters or to build an array:\par
\u8203? \tab\u8203?const\u8203? cart = [\u8203?'Naming and Necessity'\u8203?, \u8203?'Alice in Wonderland'\u8203?];\par
\u8203? \tab ...cart\par
\par
If you try this out in a REPL or a browser console, you\rquote ll get an error. The syntax is correct, but you can\rquote t use the spread operator on its own. You can\rquote t, for example, assign the output to a variable. You have to spread the information into something.\par
\u8203? \tab\u8203?const\u8203? copyCart = [...cart];\par
\u8203? \tab\u8203?// ['Naming and Necessity', 'Alice in Wonderland']\u8203?\par
\par
Now, before you think \ldblquote big deal\rdblquote  and skip to the next tip, I want you to know I understand. I didn\rquote t appreciate the spread operator until I started seeing it pop up everywhere. And I didn\rquote t love it until I started using it. But now it\rquote s my favorite ES6 feature by far.\par
\par
To see how powerful the spread operator can be, start with a simple task: removing an item from an array. Here\rquote s an approach using only a loop:\par
arrays/spread/problem.js\par
\u8203? \tab\u8203?function\u8203? removeItem(items, removable) \{\par
\u8203? \tab   \u8203?const\u8203? updated = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?let\u8203? i = 0; i < items.length; i++) \{\par
\u8203? \tab     \u8203?if\u8203? (items[i] !== removable) \{\par
\u8203? \tab       updated.push(items[i]);\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? updated;\par
\u8203? \tab\}\par
\par
This isn\rquote t bad code. But there\rquote s certainly a lot of it. It\rquote s a good rule to keep things as simple as you can. The more clutter and loops that exist, the harder it will be to read and understand the code.\par
\par
In trying to simplify, you may stumble on an array method called splice(). It removes an item from an array, and that\rquote s exactly what you want! If you refactor the preceding function, it does become more simple.\par
arrays/spread/splice.js\par
\u8203? \tab\u8203?function\u8203? removeItem(items, removable) \{\par
\u8203? \tab   \u8203?const\u8203? index = items.indexOf(removable);\par
\u8203? \tab   items.splice(index, 1);\par
\u8203? \tab   \u8203?return\u8203? items;\par
\u8203? \tab\}\par
\par
The problem with splice() is that is mutates the original array. Take a look at the following example and see if you can spot the problem:\par
arrays/spread/splice.js\par
\u8203? \tab\u8203?const\u8203? books = [\u8203?'practical vim'\u8203?, \u8203?'moby dick'\u8203?, \u8203?'the dark tower'\u8203?];\par
\u8203? \tab\u8203?const\u8203? recent = removeItem(books, \u8203?'moby dick'\u8203?);\par
\u8203? \tab\u8203?const\u8203? novels = removeItem(books, \u8203?'practical vim'\u8203?);\par
\par
What do you think the novels array will contain?\par
\par
The only book it will contain is \rquote the dark tower\rquote . When you called removeItem() the first time, you passed it books and got back the array without \rquote moby dick\rquote . But it also changed the books array. When you passed it to the next function, it was only two items long.\par
\par
This is why mutations can be so hazardous, particularly if you\rquote re using them in a function. You may not expect the information passed to be fundamentally different. Notice in this case that you\rquote re even assigning books with const. You may assume this won\rquote t be mutated, but that isn\rquote t always the case.\par
\par
Splice may seem like a good alternative to a for loop, but mutations can create so much confusion that you\rquote re better off avoiding them whenever possible.\par
\par
Finally, there\rquote s one last option. Arrays also have a method called slice(), which returns a part of an array without changing the original array. When you\rquote re using slice, you pass a startpoint and endpoint, and you get everything in between. Alternatively, you can pass just a startpoint and get everything from that point until the end of the array. Then you can use concat() to put the pieces of the array back together.\par
arrays/spread/slice.js\par
\u8203? \tab\u8203?function\u8203? removeItem(items, removable) \{\par
\u8203? \tab   \u8203?const\u8203? index = items.indexOf(removable);\par
\u8203? \tab   \u8203?return\u8203? items.slice(0, index).concat(items.slice(index + 1));\par
\u8203? \tab\}\par
\par
This code is pretty great. You get the new array back without changing the original array, and you avoid a lot of code. However, it isn\rquote t clear what\rquote s being returned. Another developer would need to know that concat() joins two arrays into a single flat array. There\rquote s no visual clue for what you\rquote re doing.\par
\par
This is where the spread operator comes in. Combined with a slice, the spread operator turns both sub-arrays into a list that\rquote s placed back into square brackets. It actually looks like an array. And more importantly, it gives you a smaller array without affecting the larger array.\par
arrays/spread/spread.js\par
\u8203? \tab\u8203?function\u8203? removeItem(items, removable) \{\par
\u8203? \tab   \u8203?const\u8203? index = items.indexOf(removable);\par
\u8203? \tab   \u8203?return\u8203? [...items.slice(0, index), ...items.slice(index + 1)];\par
\u8203? \tab\}\par
\par
Notice a few things about this code. There are no mutations. It\rquote s easy to read. It\rquote s simple. It\rquote s reusable. It\rquote s predictable. In short, it has all of your favorite attributes.\par
\par
You can actually further improve this code. As you\rquote ll see in Tip 23, \u8203? Pull Out Subsets of Data with filter() and find() \u8203?, you can pass a function that removes a specific item in an array. There are many ways to perform the same action. Go for the one that best communicates your intentions.\par
\par
This is just the beginning. The spread operator lets you quickly pull out the items of an array with very few characters. And you\rquote ll always put them back into a structure that you can quickly and easily recognize.\par
\par
If you look back through the four examples, you see that they all work. But the spread is the most readable and the easiest to predict.\par
\par
The other popular way to use the spread operator is to create a list of arguments for a function. Create a small function to format an array of information.\par
arrays/spread/spread.js\par
\u8203? \tab\u8203?const\u8203? book = [\u8203?'Reasons and Persons'\u8203?, \u8203?'Derek Parfit'\u8203?, 19.99];\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? formatBook(title, author, price) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{title\}\u8203? by \u8203?$\{author\}\u8203? $\u8203?$\{price\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
How can you put the information into the function? Try it out. You probably came up with something like this:\par
arrays/spread/spread.js\par
\u8203? \tab formatBook(book[0], book[1], book[2]);\par
\par
But there\rquote s an even simpler version that you won\rquote t have to change if the amount of data on the book changes. For example, say you add a publication year.\par
\par
If you came up with something like this, great work. Parameters are lists of arguments, so the spread operator allows you to convert an array to a list of parameters quickly and easily.\par
arrays/spread/spread.js\par
\u8203? \tab formatBook(...book);\par
\par
Here\rquote s the interesting thing: This isn\rquote t the only way you can quickly extract information from an array in parameters. You could also pull it out directly using array destructuring. You\rquote ll explore destructuring in greater detail in Tip 29, \u8203? Access Object Properties with Destructuring \u8203?.\par
\par
And that\rquote s not all! The spread operator really starts to shine in parameters once you begin to use a variable number of arguments. If you want a quick look, jump ahead to Tip 31, \u8203? Pass a Variable Number of Arguments with the Rest Operator \u8203?. As you can see, the spread operator is incredibly useful and there\rquote s plenty more to explore.\par
\par
Now that you\rquote ve seen how it works, it\rquote s time to look at how you can rewrite common array actions using the spread operator to avoid confusing mutations and side effects.\f0\par
\par
Tip 8\tab Avoid Push Mutations with the Spread Operator\par
\par
In this tip, you\rquote ll learn how to avoid array mutations by creating new arrays with the spread operator.\par
\par
As you\rquote ve just seen, mutations can have unexpected consequences. If you change something in a collection early in the code, you can create a bug much deeper. Mutations may not always cause major headaches, but they do have that potential, so it\rquote s best to avoid them when possible. In fact, some popular JavaScript libraries (such as Redux) won\rquote t allow functions with any mutations at all.\par
\par
Plus, a lot of modern JavaScript is functional in style, meaning you\rquote ll need to write code that doesn\rquote t contain side effects and mutations. There\rquote s a lot to be said about functional JavaScript, more than what can fit in this book. If you\rquote re interested, you can learn more in Functional JavaScript [Fog13] by Michael Fogus.\par
\par
I hope by now you understand why mutations are bad. But if you\rquote re like me, you probably wonder what does it all mean in practice? Consider a common array mutation: push(). The push() method changes the original array by adding an item to the end. When you add an item, you\rquote re mutating the original array. Fortunately, you can avoid the side effect with the spread operator.\par
\par
Before that, start with a problem caused by the push() method.\par
\par
Imagine a simple function that takes a shopping cart and summarizes the contents. The function checks to see if there are too many discounts and returns an error object if there are. Otherwise, if the cart has enough items, it adds a free gift.\par
arrays/push/push.js\par
\u8203? \tab\u8203?const\u8203? cart = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'The Foundation Triology'\u8203?,\par
\u8203? \tab     price: 19.99,\par
\u8203? \tab     discount: \u8203?false\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Godel, Escher, Bach'\u8203?,\par
\u8203? \tab     price: 15.99,\par
\u8203? \tab     discount: \u8203?false\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Red Mars'\u8203?,\par
\u8203? \tab     price: 5.99,\par
\u8203? \tab     discount: \u8203?true\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? reward = \{\par
\u8203? \tab   name: \u8203?'Guide to Science Fiction'\u8203?,\par
\u8203? \tab   discount: \u8203?true\u8203?,\par
\u8203? \tab   price: 0,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? addFreeGift(cart) \{\par
\u8203? \tab   \u8203?if\u8203? (cart.length > 2) \{\par
\u8203? \tab     cart.push(reward);\par
\u8203? \tab     \u8203?return\u8203? cart;\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? cart;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? summarizeCart(cart) \{\par
\u8203? \tab   \u8203?const\u8203? discountable = cart.filter(item => item.discount);\par
\u8203? \tab   \u8203?if\u8203? (discountable.length > 1) \{\par
\u8203? \tab     \u8203?return\u8203? \{\par
\u8203? \tab       error: \u8203?'Can only have one discount'\u8203?,\par
\u8203? \tab     \};\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?const\u8203? cartWithReward = addFreeGift(cart);\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     discounts: discountable.length,\par
\u8203? \tab     items: cartWithReward.length,\par
\u8203? \tab     cart: cartWithReward,\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\par
The cart is a simple array, and the gift is merely an added item. The problem is this code is one line away from causing an error. As usual, take a moment and see if you can locate the problem.\par
\par
This is a great example of why a mutation can seem so harmless. What if six months down the road, a well-meaning developer decides to clear things up by putting all the variable declarations at the top of the function?\par
arrays/push/push.js\par
\u8203? \tab\u8203?function\u8203? summarizeCartUpdated(cart) \{\par
\u8203? \tab   \u8203?const\u8203? cartWithReward = addFreeGift(cart);\par
\u8203? \tab   \u8203?const\u8203? discountable = cart.filter(item => item.discount);\par
\u8203? \tab   \u8203?if\u8203? (discountable.length > 1) \{\par
\u8203? \tab     \u8203?return\u8203? \{\par
\u8203? \tab       error: \u8203?'Can only have one discount'\u8203?,\par
\u8203? \tab     \};\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     discounts: discountable.length,\par
\u8203? \tab     items: cartWithReward.length,\par
\u8203? \tab     cart: cartWithReward,\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\par
Now the bug will surface. When you use the function addFreeGift(), you\rquote re mutating the cart array. It will always have at least one discount if there are more than two items. Even though you\rquote re assigning the return value (the cart with added gift) to a new variable, you\rquote ve mutated the original cart array. Any time someone has a cart with more than three items and one discount, they\rquote ll get an error.\par
\par
If this had a test, maybe it would be an easy fix. If there\rquote s no test, who knows how long before customer service gets an angry email.\par
\par
You might notice the problem with a lot of these examples is that the mutation happens in a separate function. Good catch! In fact, that\rquote s exactly the reason why mutations can be so dangerous. When you call a function, you should trust that it won\rquote t change any supplied values. Functions that have no side effects are called \ldblquote pure\rdblquote  functions, and that\rquote s what you should strive to achieve.\par
\par
It can be even more confusing when you return a value from a function even though you mutated the input. A developer who comes through later will likely assume that the original values haven\rquote t changed given that the return value is the one with the update. In this case, they\rquote d be wrong. The input value was also changed.\par
\par
Time to fix the problem. It\rquote s so incredibly simple\f1\emdash you should immediately understand why the spread operator became so popular.\par
arrays/push/push.js\par
\u8203? \tab\u8203?function\u8203? addGift(cart) \{\par
\u8203? \tab   \u8203?if\u8203? (cart.length > 2) \{\par
\u8203? \tab     \u8203?return\u8203? [...cart, reward];\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? cart;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? summarizeCartSpread(cart) \{\par
\u8203? \tab   \u8203?const\u8203? cartWithReward = addGift(cart);\par
\u8203? \tab   \u8203?const\u8203? discountable = cart.filter(item => item.discount);\par
\u8203? \tab   \u8203?if\u8203? (discountable.length > 1) \{\par
\u8203? \tab     \u8203?return\u8203? \{\par
\u8203? \tab       error: \u8203?'Can only have one discount'\u8203?,\par
\u8203? \tab     \};\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     discounts: discountable.length,\par
\u8203? \tab     items: cartWithReward.length,\par
\u8203? \tab     cart: cartWithReward,\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\par
All you need to do is take the current array and spread it into square brackets, tacking the newest item on at the end.\par
\par
In essence, all you\rquote re doing is rewriting the contents as a list. Note that this is a brand new array so there\rquote s no way we could possibly change the original array. We\rquote re just reusing the contents to make a new array.\par
arrays/push/push.js\par
\u8203? \tab   \u8203?const\u8203? titles = [\u8203?'Moby Dick'\u8203?, \u8203?'White Teeth'\u8203?];\par
\u8203? \tab   \u8203?const\u8203? moreTitles = [...titles, \u8203?'The Conscious Mind'\u8203?];\par
\u8203? \tab\u8203?// ['Moby Dick', 'White Teeth', 'The Conscious Mind'];\u8203?\par
\par
What I love most about creating new arrays this way (and I\rquote m sure you will, too) is that you can forget so many methods. You won\rquote t need them anymore.\par
\par
Quick! How do you add a new item to the start of an array? How do you make a copy of an array? Hint: It\rquote s different than assigning the same array to a new variable. Did you have to look them up? Don\rquote t worry, I still do, too. I mean, who could remember that slice() is a function to make a copy. Here they are with the spread replacement:\par
arrays/push/push.js\par
\u8203? \tab\u8203?// Add to beginning.\u8203?\par
\u8203? \tab   \u8203?const\u8203? titles = [\u8203?'Moby Dick'\u8203?, \u8203?'White Teeth'\u8203?];\par
\u8203? \tab   titles.shift(\u8203?'The Conscious Mind'\u8203?);\par
\u8203? \tab\par
\u8203? \tab   \u8203?const\u8203? moreTitles = [\u8203?'Moby Dick'\u8203?, \u8203?'White Teeth'\u8203?];\par
\u8203? \tab   \u8203?const\u8203? evenMoreTitles = [\u8203?'The Conscious Mind'\u8203?, ...moreTitles];\par
\u8203? \tab\par
\u8203? \tab   \u8203?// Copy\u8203?\par
\u8203? \tab   \u8203?const\u8203? toCopy = [\u8203?'Moby Dick'\u8203?, \u8203?'White Teeth'\u8203?];\par
\u8203? \tab   \u8203?const\u8203? copied = toCopy.slice();\par
\u8203? \tab\par
\u8203? \tab   \u8203?const\u8203? moreCopies = [\u8203?'Moby Dick'\u8203?, \u8203?'White Teeth'\u8203?];\par
\u8203? \tab   \u8203?const\u8203? moreCopied = [...moreCopies];\par
\par
And of course, to repeat a point from earlier, you\rquote re signaling your intention to return an array. Another developer may not remember that slice() creates a new array, but when they see the square brackets, they\rquote ll know exactly what they\rquote ll get.\par
\par
In the next tip, you\rquote ll see how creating copies of arrays can prevent problems when you must use methods that mutate arrays, such as sort().\par
\par
Tip 9\tab Avoid Sort Confusion with the Spread Operator\par
\par
In this tip, you\rquote ll learn how to use the spread operator to sort an array multiple times while getting the same result.\par
\par
You\rquote ve seen by now that you can replace many mutating functions with the spread operator. What should you do when there\rquote s a function that you can\rquote t easily replace? The answer is fairly simple: Use the spread operator to create a copy of the original array, and then mutate that one.\par
\par
Don\rquote t let the simplicity of the answer fool you. Mutation bugs can sneak up when you least expect them.\par
\par
This comes up in applications that have tabular sorting data. If you haven\rquote t written an application that displays tabular data, wait around\emdash I guarantee you\rquote ll do it. And the minute you create that table of tabular data, the next request you\rquote ll hear from your account or project manager is to make the table sortable.\par
\par
Skip the UI components and look purely at the data and functions. You need to make an application that takes an array of staff members and sorts them either by name or years of service.\par
\par
Start with an array of employees.\par
arrays/sort/sortMutate.js\par
\u8203? \tab\u8203?const\u8203? staff = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Joe'\u8203?,\par
\u8203? \tab     years: 10,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Theo'\u8203?,\par
\u8203? \tab     years: 5,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Dyan'\u8203?,\par
\u8203? \tab     years: 10,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
Next, add a couple of custom sorting functions to sort by either name or age. If you don\rquote t understand the sort functions, don\rquote t worry. It\rquote s not necessary for this example. If interested, you can check out the sort documentation on the Mozilla Developer Network.[11]\par
arrays/sort/sortMutate.js\par
\u8203? \tab\u8203?function\u8203? sortByYears(a, b) \{\par
\u8203? \tab   \u8203?if\u8203? (a.years === b.years) \{\par
\u8203? \tab     \u8203?return\u8203? 0;\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? a.years - b.years;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? sortByName = (a, b) => \{\par
\u8203? \tab   \u8203?if\u8203? (a.name === b.name) \{\par
\u8203? \tab     \u8203?return\u8203? 0;\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? a.name > b.name ? 1 : -1;\par
\u8203? \tab\};\par
\par
At this point, you\rquote d just call the sort function on the array whenever the user clicks a column heading. For example, if a user chooses to sort by years of service, the function will sort and update the array.\par
arrays/sort/sortMutate.js\par
\u8203? \tab staff.sort(sortByYears);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Theo',\u8203?\par
\u8203? \tab\u8203?//     years: 5\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Joe',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Dyan',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?// ];\u8203?\par
\par
Now this is where it gets tricky. When you sorted the array, you changed it. Even though the code looks likes it\rquote s finished executing, the change is still there.\par
\par
Suppose the user then sorted by user name. Again, the array mutates.\par
arrays/sort/sortMutate.js\par
\u8203? \tab staff.sort(sortByName);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Dyan',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Joe',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Theo',\u8203?\par
\u8203? \tab\u8203?//     years: 5\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?// ];\u8203?\par
\par
Nothing spectacular, but look what happens if the user goes back and sorts by years of service again. Maybe they forgot a name. Maybe they needed some different information. Who knows?\par
\par
What result would the user see? What result do you think the user should see? Turns out, sorting by name a second time yields completely different results.\par
arrays/sort/sortMutate.js\par
\u8203? \tab staff.sort(sortByYears);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Theo',\u8203?\par
\u8203? \tab\u8203?//     years: 5\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Dyan',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Joe',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?// ]\u8203?\par
\par
This is a simple example. Imagine a table of hundreds of employees with many of the employees sharing the same years of service. Every time a user clicks the sort button, they\rquote d see a slightly different order.\par
\par
At that point, your user has lost trust in the application. That\rquote s something you don\rquote t want. Mutations can have big impacts.\par
\par
How do you stop mutations when the method you want to use has to mutate the data? The answer is simple: Don\rquote t mutate the data. Make a copy and then perform the mutation.\par
\par
The only thing you need to change in your code is to spread the original array into a new array before sorting.\par
arrays/sort/sortSpread.js\par
\u8203? \tab [...staff].sort(sortByYears);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Theo',\u8203?\par
\u8203? \tab\u8203?//     years: 5\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Joe',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'Dyan',\u8203?\par
\u8203? \tab\u8203?//     years: 10\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?// ];\u8203?\par
\par
Now your users can sort however much they want because we aren\rquote t changing the original array. The results will always be the same as the previous sort for that type.\par
\par
The spread operator is great, not because it\rquote s complex (you\rquote ll see some fancier collections in just a moment), but because it\rquote s so incredibly simple while still being incredibly powerful.\par
\par
In the next chapter, you\rquote ll start to branch out into other collections. You\rquote ll learn when it is appropriate to use Map, Set, or standard objects.\par
Footnotes\par
\par
[7]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/34955787/is-a-javascript-array-order-guaranteed }}{\fldrslt{https://stackoverflow.com/questions/34955787/is-a-javascript-array-order-guaranteed\ul0\cf0}}}}\f1\fs22\par
[8]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Built-in_iterables }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Built-in_iterables\ul0\cf0}}}}\f1\fs22\par
[9]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/tc39/proposal-object-values-entries }}{\fldrslt{https://github.com/tc39/proposal-object-values-entries\ul0\cf0}}}}\f1\fs22\par
[10]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/tc39/Array.prototype.includes/ }}{\fldrslt{https://github.com/tc39/Array.prototype.includes/\ul0\cf0}}}}\f1\fs22\par
[11]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 3\par
Maximize Code Clarity with Special Collections\par
\par
I\rquote ll admit I like organizing things. I change my garage constantly. I keep all the little screws in a box with drawers that I can easily pull out. I keep most hand tools on a pegboard, but I have a couple of small toolboxes stocked with the most common items for carrying around the house to do small repairs. And I keep a few cardboard boxes full of odds and ends.\par
\par
The thing is that I don\rquote t need those containers. I can (and have) stuffed everything into one cardboard box, but it certainly doesn\rquote t make my life easier. I keep things separated because the container does matter. It changes how quickly I find what I need (drawers), how easily I can identify what I have or don\rquote t have (pegboard), and how seamlessly I can transport the whole group of things around the house (toolbox).\par
\par
I bet you see where this is going. This chapter is all about how to use collections to make your data easy to use and accessible. After all, the collections you use for your data can change how you work with the data.\par
\par
The beauty of code is that, unlike my garage, you can switch back and forth between containers. That\rquote s great. You should always use the best collection for the job, and fortunately for you, the options in JavaScript have significantly increased.\par
\par
What to do with all this new information? When choosing a variable declaration, you learned that the most important consideration was signaling intention to future developers. Similarly, when choosing a collection, you just have to ask yourself one question: how can you maintain simplicity and flexibility?\par
\par
In this chapter, you\rquote ll look at different collection types and how they can give you flexibility and simplicity and when they might lead to confusing and buggy code.\par
\par
You\rquote ll start off by looking at objects used as key-value collections and when they\rquote re an appropriate choice for data that won\rquote t be changed. From there, you\rquote ll see two new collections, Map and Set. You\rquote ll learn why those were introduced and how they create clear interfaces for working with data that you\rquote ll update or iterate over.\par
\par
In addition, you\rquote ll learn how and when to switch over to another structure to take advantage of its methods before switching back to your original structure.\par
\par
Even if you make a choice that ends up being wrong (and who among us hasn\rquote t made a few wrong choices when writing code?), you aren\rquote t going to be bound by it indefinitely. Take a look at the choices, select the one best suited to your task, but don\rquote t be afraid if you have to switch later. It\rquote s easy. The collection you use to hold your data does matter. But unlike my garage, you won\rquote t need to spend a Saturday rearranging things if you need to make a change. \f0\par
\par
Tip 10\tab Use Objects for Static Key-Value Lookups\par
\par
In this tip, you\rquote ll learn why objects are the best collection for simple key-value lookups.\par
\par
You probably noticed that I love arrays. But they are not appropriate in many situations. As you saw, it is always possible to store any type of information in arrays\f1\emdash they are really are that flexible\emdash but it can make things more confusing than necessary. And you often end up obscuring information more than you communicate it.\par
\par
What if you had some data and you wanted to conditionally apply some colors in the UI. You want the data to be red if data was below threshold, green if everything is within normal range, and blue if some data was above a threshold. As usual, some very smart designer with a lot of training picked the absolute perfect shades of these colors (personally, I can never tell the difference, but that\rquote s why I don\rquote t design).\par
\par
You could put the hex values in an array, but that doesn\rquote t really communicate much.\par
\u8203? \tab\u8203?const\u8203? colors = [\u8203?'#d10202'\u8203?, \u8203?'#19d836'\u8203?, \u8203?'#0e33d8'\u8203?];\par
\par
What the heck does #d10202 even mean? It happens to be a shade of red, but there\rquote s no way to know that without actually knowing it ahead of time. The problem is that this data is related\emdash it\rquote s all colors\emdash but not interchangeable. Unlike an array of users where all users are structurally similar and one can be substituted for another, the different colors will serve different purposes (indicating value to users). When a developer wants the hex code for red, they don\rquote t care what other values are in the collection. They don\rquote t need to know that red is the first or third color. In this case, a key-value collection will be more appropriate. You really need to give future developers a better idea of what the information means.\par
\par
In cases where arrays aren\rquote t appropriate and you want a key-value collection, most developers reach for objects. And objects are great, but as you will see in upcoming tips, there are now more options for key-value collections.\par
\par
The TC39 committee added more options for collections because objects are complex. They can be key-value collections, which is how you will use them in this chapter, or they can be closer to classes with constructors, methods, and properties. Most things in JavaScript, including other collection types, are objects at their core.\par
\par
This chapter will leave aside some of the complexities of object properties, prototypes, and the keyword this and instead look at how objects are used as key-value collections. The keyword this, for example, is a huge topic that\rquote s well covered by Kyle Simpson in You Don\rquote t Know JS: this & Object Prototypes. [Sim14]\par
\par
Now that you are thinking about objects primarily as collections competing against other collection types, such as Map, the new challenge is knowing when to chose plain objects deliberately, as the best solution for the problem, and not as a default.\par
\par
As a rule, objects are great when you want to share unchanging structured key-value data, but are not appropriate for dynamic information that is updated frequently or unknown until runtime, as you will see in later tips.\par
\par
For example, if you wanted to share your collection of colors, objects are a great choice. The data doesn\rquote t change. You wouldn\rquote t dynamically change the hex value for red. In this case, you can change your array of colors to an object by adding keys and wrapping the whole thing in curly braces. When you create an object this way, with key-values in curly braces, you are using object literal syntax.\par
\u8203? \tab\u8203?const\u8203? colors = \{\par
\u8203? \tab     red: \u8203?'#d10202'\u8203?,\par
\u8203? \tab     green: \u8203?'#19d836'\u8203?,\par
\u8203? \tab     blue: \u8203?'#0e33d8'\u8203?\par
\u8203? \tab\}\par
\par
When a future developer wants to get the proper color red, they don\rquote t need to know a position; they just call it directly: colors.red. Alternatively, they can use array syntax colors[\rquote red\rquote ]. It\rquote s simple. That\rquote s why objects are so valuable for retrieving static information.\par
\par
The key here is static information. Objects are not good for information that\rquote s continually updated, looped over, altered, or sorted. In those cases, use Map. Objects are a path to find information when you know where it will be. Config files are often objects because they are set up before runtime and are simple key-value stores of static information.\par
collections/object/object.js\par
\u8203? \tab\u8203?export\u8203? \u8203?const\u8203? config = \{\par
\u8203? \tab   endpoint: \u8203?'{{\field{\*\fldinst{HYPERLINK http://pragprog.com }}{\fldrslt{http://pragprog.com\ul0\cf0}}}}\f1\fs22 '\u8203?,\par
\u8203? \tab   key: \u8203?'secretkey'\u8203?,\par
\u8203? \tab\};\par
\par
But static objects can also be defined programmatically. For example, you can build an object in a function and then pass it to another function. The information is collected, sent, and then unpacked in another function. In this way, it\rquote s static because it is not mutated and updated.\par
\par
The trick is that the data is set and then retrieved the same way every time. You are not mutating an existing object; you are creating a new object in each function. And more importantly, you know the key names when you are writing the code. You are not setting the keys using variables. The next function knows in advance what it will be getting.\par
collections/object/object.js\par
\u8203? \tab\u8203?function\u8203? getBill(item) \{\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     name: item.name,\par
\u8203? \tab     due: twoWeeksFromNow(),\par
\u8203? \tab     total: calculateTotal(item.price),\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? bill = getBill(\{ name: \u8203?'Room Cleaning'\u8203?, price: 30 \});\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? displayBill(bill) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your total \u8203?$\{bill.total\}\u8203? for \u8203?$\{bill.name\}\u8203? is due on \u8203?$\{bill.due\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
In the preceding example, an object is being used to add structure to information passed between objects. Instead of writing displayBill() as a function that takes each item as a parameter, you are passing the object, and the function is pulling out the values it needs.\par
\par
This is where objects are far superior to other collections. Not only are they quick and clear, but with object destructuring, pulling data from objects is even quicker and cleaner than ever. Jump ahead to Tip 29, \u8203? Access Object Properties with Destructuring \u8203? if you want to see it in action. Destructuring is part of the reason why nothing beats an object for a quick lookup.\par
\par
But again, notice that the function is creating a new object. It\rquote s setting the information and then immediately retrieving it in a different function. It\rquote s not setting the information repeatedly. If you want to add lots of information to an object programmatically, other collections may be better suited for the task, such as the Map object, which we\rquote ll explore in Tip 13, \u8203? Update Key-Value Data Clearly with Maps \u8203?.\par
\par
For now, you know that objects still play a huge role in JavaScript. You\rquote ll use them all the time when you\rquote re sharing information. In the next two tips, you\rquote ll look at a common use case: combining two similar objects together. And then you\rquote ll explore some other collections that you can use in place of objects.\par
\par
Objects will come up more when you get to functions and classes, but for now, remember to keep their usage at a basic level and take a moment to consider other collections before creating an object.\par
\par
In the next tip, you\rquote ll dive into working with objects, beginning with making changes to objects without mutations.\par
\par
Tip 11\tab Create Objects Without Mutations Using Object.assign()\par
\par
In this tip, you\rquote ll learn how to update an object without mutations, using Object.assign().\par
\par
In the previous tip, you took a quick look at objects and got rules for when they offer distinct advantages over other collections. Still, you need to be careful when using them because they can leave you open to the same problems with mutations and side effects that you saw in arrays. Casually adding and setting fields on objects can create unseen problems.\par
\par
Consider a very common problem. You have an object with a number of key-values pairs. The problem is that the object is incomplete. This happens often when you have legacy data and there are new fields, or you are getting data from an external API and you need it to match your data model. Either way, the issue is the same: you want to fill in the remaining fields using a default object.\par
\par
How can you create a new object that preserves the original data while adding in the defaults? And, of course, you don\rquote t want side effects or mutations.\par
\par
Take a moment to write out the code. See what you come up with.\par
\par
If you wrote the code out, it would probably look something like this:\par
collections/assign/problem.js\par
\u8203? \tab\u8203?const\u8203? defaults = \{\par
\u8203? \tab   author: \u8203?''\u8203?,\par
\u8203? \tab   title: \u8203?''\u8203?,\par
\u8203? \tab   year: 2017,\par
\u8203? \tab   rating: \u8203?null\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   author: \u8203?'Joe Morgan'\u8203?,\par
\u8203? \tab   title: \u8203?'Simplifying JavaScript'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? addBookDefaults(book, defaults) \{\par
\u8203? \tab   \u8203?const\u8203? fields = Object.keys(defaults);\par
\u8203? \tab   \u8203?const\u8203? updated = \{\};\par
\u8203? \tab   \u8203?for\u8203? (\u8203?let\u8203? i = 0; i < fields.length; i++) \{\par
\u8203? \tab     \u8203?const\u8203? field = fields[i];\par
\u8203? \tab     updated[field] = book[field] || defaults[field];\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? updated;\par
\u8203? \tab\}\par
\par
There\rquote s nothing wrong with this code, but it sure is wordy. Fortunately, this was a common enough issue that ES5 introduced Object.assign() to create and update fields on an object with keys and values from another object (or objects).\par
\par
In other words, Object.assign() lets you update an object with properties from another object.\par
\par
So how does Object.assign() work? It\rquote s fairly simple. The method takes a series of objects and updates the inner-most object with the keys and values from outer objects, then returns the updated first object. The outermost object has precedence over any inner objects.\par
\par
It\rquote s easier to see than explain, but when you see how simple it is, you\rquote ll love it. Here\rquote s how you can rewrite addBookDefaults() using Object.assign():\par
collections/assign/mutate.js\par
\u8203? \tab Object.assign(defaults, book);\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   author: 'Joe Morgan',\u8203?\par
\u8203? \tab\u8203?//   title: 'Simplifying JavaScript',\u8203?\par
\u8203? \tab\u8203?//   year: 2017,\u8203?\par
\u8203? \tab\u8203?//   rating: null,\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
Your nine-line function dropped to a single line. But by now, you may have guessed there\rquote s a problem in this code. When it updates the initial object\emdash  the default object\emdash it also mutates the original. If you run the code again with a different book object, you\rquote ll get an unexpected result.\par
collections/assign/mutate.js\par
\u8203? \tab\u8203?const\u8203? anotherBook = \{\par
\u8203? \tab   title: \u8203?'Another book'\u8203?,\par
\u8203? \tab   year: 2016,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab Object.assign(defaults, anotherBook);\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   author: 'Joe Morgan',\u8203?\par
\u8203? \tab\u8203?//   title: 'Simplifying JavaScript',\u8203?\par
\u8203? \tab\u8203?//   year: 2017,\u8203?\par
\u8203? \tab\u8203?//   rating: null,\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
You accidentally changed the default object to make me, \lquote Joe\rquote , the default author, so I\rquote m going to start getting credit for a whole bunch of books I\rquote ve never written.\par
\par
Fortunately, the solution is simple. Just make the first object an empty object. After you do that, the returned object will be the updated empty object. The other objects will have no mutations.\par
collections/assign/assign.js\par
\u8203? \tab\u8203?const\u8203? defaults = \{ author: \u8203?''\u8203?,\par
\u8203? \tab   title: \u8203?''\u8203?,\par
\u8203? \tab   year: 2017,\par
\u8203? \tab   rating: \u8203?null\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   author: \u8203?'Joe Morgan'\u8203?,\par
\u8203? \tab   title: \u8203?'Simplifying JavaScript'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? updated = Object.assign(\{\}, defaults, book);\par
\par
Now, there\rquote s one problem with copying objects using Object.assign(). When it copies over properties, it just copies the values. That may seem like it\rquote s not a problem, but it is.\par
\par
Up to this point, you\rquote ve been working with flat objects. Every key had a simple value: a string or an integer. And when all you have is a series of strings or integers, it copies them just fine, as you saw earlier. But when the value is another object, you start to have problems.\par
collections/assign/assign.js\par
\u8203? \tab\u8203?const\u8203? defaultEmployee = \{\par
\u8203? \tab   name: \{\par
\u8203? \tab     first: \u8203?''\u8203?,\par
\u8203? \tab     last: \u8203?''\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   years: 0,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? employee = Object.assign(\{\}, defaultEmployee);\par
\par
Copying objects that have nested objects is called \ldblquote deep copying\rdblquote  (or \ldblquote deep merging\rdblquote  or some variation). The property years will copy over just fine, but the property name isn\rquote t copied. All that\rquote s copied is a reference to the independent object that\rquote s assigned to the key name. The nested object essentially exists independently of the object that holds it. All the containing object has is a reference to that object. When you copy the reference, you aren\rquote t making a deep copy of the nested object. You\rquote re merely copying the location of the reference.\par
\par
So if you change a value of a nested object on either the original or the copy, it will change the value on both.\par
collections/assign/assign.js\par
\u8203? \tab employee.name.first = \u8203?'Joe'\u8203?;\par
\u8203? \tab\par
\u8203? \tab defaultEmployee;\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   name: \{\u8203?\par
\u8203? \tab\u8203?//     first:'Joe',\u8203?\par
\u8203? \tab\u8203?//     last: '',\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   years: 0\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
There are two ways around this problem: The first and simplest is to keep your objects flat\emdash don\rquote t have nested objects if you can avoid it.\par
\par
Unfortunately, that doesn\rquote t work in a situation where you start off with a nested object. Maybe the software was designed with nested objects. Maybe you\rquote re getting a result from an API that\rquote s nested. It doesn\rquote t matter. Nested objects are very common.\par
\par
In that case, you can copy the nested objects with Object.assign(); you just need a little more code. Whenever there is a nested object, copy that with Object.assign() and everything will be updated.\par
collections/assign/assign.js\par
\u8203? \tab\u8203?const\u8203? employee2 = Object.assign(\par
\u8203? \tab   \{\},\par
\u8203? \tab   defaultEmployee,\par
\u8203? \tab   \{\par
\u8203? \tab     name: Object.assign(\{\}, defaultEmployee.name),\par
\u8203? \tab   \},\par
\u8203? \tab );\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ defaults \};\par
\par
Of course, there are other options: A library like Lodash has a method called cloneDeep() that can do this for you. And by all means, take advantage of community libraries, but sometimes you may want to make a change without external code.\par
\par
If you\rquote re thinking that code is getting ugly fast, you\rquote re not wrong. It feels like it could be simpler. Sure, you can abstract it out into a helper function, but fortunately, you may not even need to do that. There\rquote s experimental syntax\par
\par
that, though not adopted, is widely used throughout the JavaScript community and will likely be part of the official spec soon. The best part is, it looks exactly like something you\rquote ve already seen. It\rquote s called the Object Spread operator, and it will give you the ability to make new objects with the now familiar spread operator.\par
\par
In the next tip, you\rquote ll learn how use the new syntax to update object information quickly and clearly.\par
\par
Tip 12\tab Update Information with Object Spread\par
\par
In this tip, you\rquote ll learn how the object spread operator gives you all the advantages of Object.assign() with reduced syntax.\par
\par
You saw in the previous tip how you can use Object.assign() to make copies of objects and how you can overwrite object values with new values from another object. It\rquote s a great tool that has a lot of value. But, wow\emdash it\rquote s ugly.\par
\par
The spread operator was such a popular addition in ES6 that similar syntax is being introduced for objects. The object spread operator is not officially part of the spec, but it\rquote s so widely used that it will likely be adopted in the future. You can check out the proposal on github.[12]\par
Using Proposed Syntax\par
\par
JavaScript developers love new syntax. In fact, they love it so much they often start using it before it\rquote s officially adopted. This is the case with the object spread operator and other things such as private methods in classes. You see them in many code bases even though the spec is not official.\par
\par
Deciding when to use proposed syntax is a matter of preference. I tend to be pretty conservative and only adopt proposed syntax when it\rquote s very clear that the community supports the change and the proposal is unlikely to change.\par
\par
Once you decide to use proposed syntax, you will need to make a few changes to your development environment. If you use Babel for compiling your code in order to be compatible across browsers, all you have to do is add a plugin and everything works fine. If you are on Node.js, it can be a little more difficult. Many features are supported using the --harmony flag when starting Node.js.\par
\par
Feel free to experiment, but be aware you may need to refactor code if the official proposal changes.\par
\par
How does the object spread operator work? Well, it\rquote s simple. It works like the array spread operator\emdash the key-values are returned as if in a list. You can easily add information by placing it either before or after the spread. And like the array spread, you must spread it out into something.\par
collections/objectSpread/objectSpread.js\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   title: \u8203?'Reasons and Persons'\u8203?,\par
\u8203? \tab   author: \u8203?'Derek Parfit'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? update = \{ ...book, year: 1984 \};\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{ title: 'Reasons and Persons', author: 'Derek Parfit', year: 1984\}\u8203?\par
\par
But it\rquote s different from the array spread in that if you add a value with the same key, it will use whatever value is declared last.\par
\par
In this way, it\rquote s like Object.assign() with much less typing.\par
collections/objectSpread/objectSpread.js\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   title: \u8203?'Reasons and Persons'\u8203?,\par
\u8203? \tab   author: \u8203?'Derek Parfit'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? update = \{ ...book, title: \u8203?'Reasons & Persons'\u8203? \};\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{ title: 'Reasons & Persons', author: 'Derek Parfit' \}\u8203?\par
\par
That\rquote s it! It takes the best existing features and combines them. You will not be surprised to learn that the JavaScript community embraces it enthusiastically.\par
\par
Now that you have some great new syntax, try rewriting the functions from the previous tip. I\rquote ll give you the original and then the updated version. But try it yourself. It\rquote s very simple.\par
\par
Here\rquote s the way to add or update information with Object.assign():\par
collections/assign/assign.js\par
\u8203? \tab\u8203?const\u8203? defaults = \{ author: \u8203?''\u8203?,\par
\u8203? \tab   title: \u8203?''\u8203?,\par
\u8203? \tab   year: 2017,\par
\u8203? \tab   rating: \u8203?null\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   author: \u8203?'Joe Morgan'\u8203?,\par
\u8203? \tab   title: \u8203?'Simplifying JavaScript'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? updated = Object.assign(\{\}, defaults, book);\par
\par
And here it is with the object spread operator:\par
collections/objectSpread/objectSpread.js\par
\u8203? \tab\u8203?const\u8203? defaults = \{\par
\u8203? \tab   author: \u8203?''\u8203?,\par
\u8203? \tab   title: \u8203?''\u8203?,\par
\u8203? \tab   year: 2017,\par
\u8203? \tab   rating: \u8203?null\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? book = \{\par
\u8203? \tab   author: \u8203?'Joe Morgan'\u8203?,\par
\u8203? \tab   title: \u8203?'ES6 Tips'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? bookWithDefaults = \{ ...defaults, ...book \};\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   author: 'Joe Morgan',\u8203?\par
\u8203? \tab\u8203?//   title: 'ES6 Tips',\u8203?\par
\u8203? \tab\u8203?//   year: 2017,\u8203?\par
\u8203? \tab\u8203?//   rating: null,\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
You\rquote ll have the same deep merge problems that you have with Object.assign(): you don\rquote t copy nested objects\emdash you only copy a reference creating a potential problem with mutations.\par
\par
Fortunately, the fix is less painful on the eyes. Here\rquote s the original.\par
collections/assign/assign.js\par
\u8203? \tab\u8203?const\u8203? employee2 = Object.assign(\par
\u8203? \tab   \{\},\par
\u8203? \tab   defaultEmployee,\par
\u8203? \tab   \{\par
\u8203? \tab     name: Object.assign(\{\}, defaultEmployee.name),\par
\u8203? \tab   \},\par
\u8203? \tab );\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ defaults \};\par
\par
Now, before you the look at the answer, really try this out. It\rquote s straightforward, but still a little more complex. Got it? Okay. Here\rquote s the same update with the object spread operator.\par
collections/objectSpread/objectSpread.js\par
\u8203? \tab\u8203?const\u8203? employee = \{\par
\u8203? \tab   ...defaultEmployee,\par
\u8203? \tab   name: \{\par
\u8203? \tab     ...defaultEmployee.name,\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\par
The advantages are clear. The code is more readable. You\rquote re signaling your intention to create an object in a clear way. You don\rquote t have to worry about mutations because you don\rquote t need to remember to start with an empty object.\par
\par
The object spread is fantastic\emdash it\rquote s great for your code and gives you an opportunity to integrate experimental features in your code base.\par
\par
That\rquote s all there is for existing collections. In the next tip, you will finally get to try out some completely new collections that should improve your code communication. First up, the Map object. \par
\par
Tip 13\tab Update Key-Value Data Clearly with Maps\par
\par
In this tip, you\rquote ll learn how to use the Map object for key-value collections of frequently updated data.\par
\par
In Tip 10, \u8203? Use Objects for Static Key-Value Lookups \u8203?, you learned that you should only use objects deliberately and not as a default collection. Now you\rquote re going to get a chance to look at an alternative: Map.\par
\par
Map is a special kind of collection that can do certain things very easily. The Mozilla Developer Network has a nice list of circumstances where Map is a better option for a collection than a plain object.[13] I encourage you to read the full list, but this tip examines two specific situations:\par
\par
    Key-value pairs are frequently added or removed.\par
    A key isn\rquote t a string.\par
\par
In the next tip, you\rquote ll see another big advantage: using Map for iterating over collections. For now, you just need to be familiar with adding or removing values to maps.\par
\par
First, think about what it means that key-value pairs are frequently added and removed. Consider a pet adoption website. The site has a list of all the adorable dogs that need homes. Because people have different expectations of their pets (some want big dogs, some like certain breeds), you\rquote ll need to include a way to filter the animals.\par
\par
You\rquote ll start off with a collection of animals:\par
\u8203? \tab\u8203?const\u8203? dogs = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'max'\u8203?,\par
\u8203? \tab     size: \u8203?'small'\u8203?,\par
\u8203? \tab     breed: \u8203?'boston terrier'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'don'\u8203?,\par
\u8203? \tab     size: \u8203?'large'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'shadow'\u8203?,\par
\u8203? \tab     size: \u8203?'medium'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'chocolate'\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab ]\par
\par
The collection of all dogs is an array, which makes sense because the shape of each item in the collection is the same.\par
\par
You\rquote ll need to create one more collection: your list of applied filters. The filters will be a collection containing a key (color) and a value (black). The user will need to be able to add a filter, remove a filter, and clear all filter values.\par
\par
If you added the key \ldblquote color\rdblquote  and the value \ldblquote black\rdblquote  to the collection, then somewhere else in the code base, you\rquote ll filter the objects using that information and be left with an array of two dogs. Don\rquote t worry about the implementation details. But if you\rquote re curious, take a look at Tip 23, \u8203? Pull Out Subsets of Data with filter() and find() \u8203? to see how to filter an array.\par
\par
To understand why Map was added to the spec, think of how you might solve the problem with standard objects.\par
\par
First, you\rquote d make an empty object that will hold the new information:\par
\u8203? \tab\u8203?let\u8203? filters = \{\};\par
\par
Then you\rquote d need three actions to update the information on the object: add filter, remove a filter, clear all filters.\par
collections/map/problem.js\par
\u8203? \tab\u8203?function\u8203? addFilters(filters, key, value) \{\par
\u8203? \tab   filters[key] = value;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? deleteFilters(filters, key) \{\par
\u8203? \tab   \u8203?delete\u8203? filters[key];\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? clearFilters(filters) \{\par
\u8203? \tab   filters = \{\};\par
\u8203? \tab   \u8203?return\u8203? filters;\par
\u8203? \tab\}\par
\par
The strange thing here is even though you\rquote re performing three basic actions on a collection\emdash setting a key-value, deleting a key-value, clearing all key-values\emdash you\rquote re using three different paradigms. The first, setting a key-value, uses a method on the object itself. The second, deleting a key-value pair, uses an operator defined by the language. The third, clearing all data, reassigns a variable. It\rquote s not even an action on the object. It\rquote s variable reassignment. When you \ldblquote clear\rdblquote  an object, you\rquote re really just writing filters = new Object();.\par
\par
By contrast, maps are designed specifically to update key-value pairs frequently. The interface is clear, methods have predictable names, and actions such as loops (as you\rquote ll see in the next tip) are built in. This will make you a more productive developer. The more you can predict, the faster you can create.\par
Browser Engines\par
\par
JavaScript code has to be interpreted by an engine but, complicating the process, there are many different engines. The most popular is the V8 engine, which powers Chrome and Node. But there\rquote s also SpiderMonkey (Firefox) and Chakra (Internet Explorer/Edge). Features can be implemented in different ways. And some syntax changes have advantages beyond code clarity.\par
\par
Because maps are a more specialized collection, the developers of JavaScript engines can optimize the code to make actions faster. Key lookups for objects will be linear, but when maps are implemented natively, their lookup time can be logarithmic.[14]\par
\par
In other words, big objects are more expensive than big maps.\par
\par
You can see some projects, such as React, switching to natively implemented maps purely for performance reasons.[15] You\rquote ll likely never need to make a choice between objects or maps for performance reasons, but it\rquote s good to know that the underlying engines do treat them differently.\par
\par
To begin, you need to create a new instance of Map and add some data.\par
\par
Unlike an object, which has a simple constructor shortcut using curly braces, you must always explicitly create a new instance of a Map.\par
\u8203? \tab\u8203?let\u8203? filters = \u8203?new\u8203? Map();\par
\par
Notice that you assigned the new map with let. let is a better choice because you\rquote ll be mutating the object by adding some data. You may be a little confused. After spending a lot of time learning how mutations are bad, here\rquote s an object that, by necessity, must be mutated whenever you add or remove data. For now, don\rquote t worry about the mutations. There is a way around mutating the object, and you\rquote ll see it in the next tip.\par
\par
After creating an instance, you add data with the set() method. To add a breed of \rquote labrador\rquote  to the filter list, you\rquote d pass in the key name \rquote breed\rquote  as the first argument and the value \rquote labrador\rquote  as the second argument.\par
\u8203? \tab filters.\u8203?set\u8203?(\u8203?'breed'\u8203?, \u8203?'labrador'\u8203?);\par
\par
To retrieve date, use the get() method, passing in the key as the only argument.\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'breed'\u8203?);\par
\u8203? \tab\u8203?// labrador\u8203?\par
\par
Getting and setting data is simple, but it can be tedious for a large map. Fortunately, the creators of the spec anticipated this and created a few shortcuts when setting data.\par
\par
You can easily add several values with chaining\emdash applying methods one after the other. You can even chain directly from the creation of the new instance. You\rquote ll see more about chaining methods in Tip 25, \u8203? Combine Methods with Chaining \u8203?.\par
\u8203? \tab\u8203?let\u8203? filters = \u8203?new\u8203? Map()\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'breed'\u8203?, \u8203?'labrador'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'size'\u8203?, \u8203?'large'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'chocolate'\u8203?);\par
\u8203? \tab\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'size'\u8203?);\par
\u8203? \tab\u8203?// 'large'\u8203?\par
\par
That\rquote s not the only way you can add data. You can also add information using an array.\par
\par
Remember in Tip 5, \u8203? Create Flexible Collections with Arrays \u8203?, you learned that key-value objects can be represented as an array of pairs. Here\rquote s a perfect use case. Instead of creating a new Map and then chaining setters, you can pass an array of pairs with the first element being a key and the second element being a value.\par
\u8203? \tab\u8203?let\u8203? filters = \u8203?new\u8203? Map(\par
\u8203? \tab     [\par
\u8203? \tab         [\u8203?'breed'\u8203?, \u8203?'labrador'\u8203?],\par
\u8203? \tab         [\u8203?'size'\u8203?, \u8203?'large'\u8203?],\par
\u8203? \tab         [\u8203?'color'\u8203?, \u8203?'chocolate'\u8203?],\par
\u8203? \tab     ]\par
\u8203? \tab )\par
\u8203? \tab\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\u8203?// 'chocolate'\u8203?\par
\par
If you want to remove values, you just need to use the delete() method rather than the language operator.\par
\u8203? \tab filters.\u8203?delete\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\u8203?// undefined\u8203?\par
\par
Similarly, you can delete all the key-value pairs with the clear() method.\par
\u8203? \tab filters.clear()\par
\u8203? \tab\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\u8203?// undefined\u8203?\par
\par
With these methods outlined, you have the foundation to change your functions to use a map instead of an object.\par
collections/map/map.js\par
\u8203? \tab\u8203?const\u8203? petFilters = \u8203?new\u8203? Map();\par
\u8203? \tab\u8203?function\u8203? addFilters(filters, key, value) \{\par
\u8203? \tab   filters.\u8203?set\u8203?(key, value);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? deleteFilters(filters, key) \{\par
\u8203? \tab   filters.\u8203?delete\u8203?(key);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? clearFilters(filters) \{\par
\u8203? \tab   filters.clear();\par
\u8203? \tab\}\par
\par
The change is subtle but very important. First, the code is much cleaner. That\rquote s a big advantage in itself. But you\rquote ll see far bigger advantages when you compare these functions to the ones you created with an object. With these functions:\par
\par
    You always use a method on a Map instance.\par
    You don\rquote t mix in language operators after you create the initial instance.\par
    You don\rquote t ever have to create a new instance to perform a simple action.\par
\par
These are the reasons why maps are so much easier to work with than objects when you\rquote re frequently changing the information. Every action and intention is very clear.\par
\par
In addition, with objects you\rquote re limited in the types of keys you can use. Objects can use only certain types of keys. Most significantly, you can\rquote t use integers as a string, which causes problems if you want to store information by a numerical ID. For example, if you have an object of error codes:\par
\u8203? \tab\u8203?const\u8203? errors = \{\par
\u8203? \tab   100: \u8203?'Invalid name'\u8203?,\par
\u8203? \tab   110: \u8203?'Name should only contain letters'\u8203?,\par
\u8203? \tab   200: \u8203?'Invalid color'\u8203?\par
\u8203? \tab\};\par
\par
you may innocently think you could retrieve error text by the numerical code.\par
\u8203? \tab\u8203?function\u8203? isDataValid(data) \{\par
\u8203? \tab   \u8203?if\u8203?(data.length < 10) \{\par
\u8203? \tab     \u8203?return\u8203? errors.100\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?true\u8203?;\par
\u8203? \tab\}\par
\par
This code would throw an Error. Integers as keys can\rquote t be accessed with dot syntax. You\rquote re still able to access the information using array notation errors[100]. But that\rquote s actually a bit of a trick. You get the right result because when you created the error array, it converted all the integers to strings. And when you use array syntax, it\rquote s also converting the integer to a string before lookup. If you tried to get the keys, it would return an array of strings:\par
\u8203? \tab Object.keys(errors);\par
\u8203? \tab\u8203?// ['100', '110', '200']\u8203?\par
\par
A Map wouldn\rquote t have that problem. It can take many different types as keys.\par
\u8203? \tab\u8203?let\u8203? errors = \u8203?new\u8203? Map([\par
\u8203? \tab     [100, \u8203?'Invalid name'\u8203?],\par
\u8203? \tab     [110, \u8203?'Name should only contain letters'\u8203?],\par
\u8203? \tab     [200, \u8203?'Invalid color'\u8203?]\par
\u8203? \tab ]);\par
\u8203? \tab\par
\u8203? \tab errors.\u8203?get\u8203?(100);\par
\u8203? \tab\u8203?// 'Invalid name'\u8203?\par
\u8203? \tab\}\par
\par
In case you\rquote re wondering, you can also get the keys from a Map as you could with an object.\par
\u8203? \tab errors.keys();\par
\u8203? \tab\par
\u8203? \tab\u8203?// MapIterator \{ 100, 110, 200 \}\u8203?\par
\u8203? \tab\}\par
\par
Notice something strange? When you asked for the keys, you didn\rquote t get an array, as you do with Object.keys(). You didn\rquote t get an object, or even another Map; the return value is something called MapIterator. Don\rquote t worry\emdash it\rquote s actually a great thing to have. The MapIterator is what will allow us to loop through data.\par
\par
In the next tip, you\rquote ll see how the MapIterator is the killer feature that will make you return to Map over and over again. \par
\par
Tip 14\tab Iterate Over Key-Value Data with Map and the Spread Operator\par
\par
In this tip, you\rquote ll learn how to iterate directly over key-value data in maps with either loops or the spread operator.\par
\par
In the previous tip, you saw how maps are an improved key-value collection when you\rquote re regularly adding or deleting items. As you saw, objects are very useful, but there are times when a map has distinct advantages. You can see those advantages on the Mozilla Developer Network.[16]\par
\par
You\rquote ve already explored several advantages pertaining to when keys are set. Now you\rquote re going to explore another suggested usage for maps: collections that are iterated.\par
\par
Objects are very frustrating to iterate over. In fact, there used to be no way to directly iterate over them. You were always forced to transform them before you could loop over the data. Things are a little better. You can now use a for...in loop to iterate over objects, but you\rquote ll have access only to the object key. In a way, it\rquote s not much different from looping over an array of keys. Check out Tip 27, \u8203? Reduce Loop Clutter with for...in and for...each \u8203? for more about the for...in loop.\par
\par
As you can see. Looping over objects is complicated. Conversely, you can iterate over maps directly.\par
\par
Start by returning to your filters. Suppose you have an object of filters and you want to list the applied filters. After all, you want your users to remember they\rquote re seeing a subset of information. How would you write code that translates the objects to a string?\par
\par
How would you, for example, transform all the key-values to be a string of the form \ldblquote key:value\rdblquote ?\par
\par
The odd thing is you won\rquote t iterate over the filters object. Instead, you\rquote ll pull out other information and then iterate over that.\par
collections/mapSpread/object.js\par
\u8203? \tab\u8203?const\u8203? filters = \{\par
\u8203? \tab   color: \u8203?'black'\u8203?,\par
\u8203? \tab   breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? keys = Object.keys(filters);\par
\u8203? \tab   \u8203?const\u8203? applied = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? key \u8203?of\u8203? keys) \{\par
\u8203? \tab     applied.push(\u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{filters[key]\}\u8203?`\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied.join(\u8203?', '\u8203?)\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// 'Your filters are: color:black, breed:labrador.'\u8203?\par
\par
Looking at the code, you see that the first step is pulling out a section of the object into an array with Object.keys() and then you iterate over the keys with a for loop. And during that for loop, you have to pull the value out by referencing the object again.\par
\par
Plus, there\rquote s no guarantee of order in an object. That means an object can\rquote t be sorted. If you wanted to get the filters in sorted order, you\rquote d first need to sort the keys.\par
collections/mapSpread/object.js\par
\u8203? \tab\u8203?function\u8203? getSortedAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? keys = Object.keys(filters);\par
\u8203? \tab   keys.sort();\par
\u8203? \tab   \u8203?const\u8203? applied = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? key \u8203?of\u8203? keys) \{\par
\u8203? \tab     applied.push(\u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{filters[key]\}\u8203?`\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied.join(\u8203?', '\u8203?)\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// 'Your filters are: breed:labrador, color:black.'\u8203?\par
\par
That\rquote s a lot to keep track of when you want to do a simple iteration. A Map, by contrast, has everything you need to sort and iterate built in as part of the MapIterator you saw at the end of the previous tip.\par
\par
To begin exploring the MapIterator, look at a simple for loop on your filters map. The for ... of syntax is also fairly new, but it\rquote s very simple. It returns each value in the collection one at a time. You\rquote ll explore it a little more in Tip 27, \u8203? Reduce Loop Clutter with for...in and for...each \u8203?.\par
collections/mapSpread/iterate.js\par
\u8203? \tab\u8203?const\u8203? filters = \u8203?new\u8203? Map()\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'black'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'breed'\u8203?, \u8203?'labrador'\u8203?);\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? checkFilters(filters) \{\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? entry \u8203?of\u8203? filters) \{\par
\u8203? \tab     console.log(entry);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// ['color', 'black']\u8203?\par
\u8203? \tab\u8203?// ['breed', 'labrador']\u8203?\par
\par
A few things should have immediately jumped out to you. The item you get from the iterator is neither the key nor the value. It\rquote s not even another Map. It\rquote s a pair of the key-value.\par
\par
Even though you created this map using the set() method, it still translated the information back to an array. You also used a specific variable name, entries(), because Map has a special method that will give you a MapIterator of the key-values of a map as a group of pairs:\par
\u8203? \tab filters.entries();\par
\u8203? \tab\u8203?// MapIterator \{ [ 'color', 'black' ], [ 'breed', 'labrador' ] \}\u8203?\par
\par
Keep that in mind\emdash you\rquote ll return to it in a moment. For now, just understand that a simple loop on a map will give you both the keys and the values in a pair. In fact, the ability to get entries is so convenient that it\rquote s being added to a method on objects in the next version of the JavaScript spec.[17]\par
\par
Of course, that means you\rquote ll be able to apply all the ideas you learn here to objects directly in the near future. That\rquote s another good reason to experiment with maps even if you don\rquote t adopt them often.\par
\par
Return to your original method for turning key-values into a string using a for loop. Because you can iterate directly over the map, you don\rquote t need to pull out the keys first. Plus, when you loop over the entries in a map, you get a pair of the key-values, which you can immediately assign to variables using destructuring. You\rquote ll explore this more in Tip 29, \u8203? Access Object Properties with Destructuring \u8203?.\par
\par
The result is more simple, and it helps you avoid breaking apart your data structure.\par
collections/mapSpread/iterate.js\par
\u8203? \tab\u8203?function\u8203? getAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? applied = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? [key, value] \u8203?of\u8203? filters) \{\par
\u8203? \tab     applied.push(\u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{value\}\u8203?`\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied.join(\u8203?', '\u8203?)\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// 'Your filters are: color:black, breed:labrador.'\u8203?\par
\par
Of course, you quickly realize that you have the same sorting problem as you did earlier. Well, there is good news and bad news for you: The good news is that Map does preserve order. The first item you have will always be the first item in the map. The bad news is that there isn\rquote t a built-in sort method as there is for an array.\par
\par
In other words, you can\rquote t do this:\par
\u8203? \tab filters.sort()\par
\par
All of a sudden, your map is looking less helpful. Fortunately, there\rquote s a very simple solution: the spread operator.\par
\par
The spread operator works on a map the same way it does on an array. The main difference is that it returns a list of pairs instead of single values.\par
\u8203? \tab ...filters;\par
\u8203? \tab\u8203?// ['color', 'black'], ['breed', 'labrador']\u8203?\par
\par
And like the spread operator on arrays, you have to spread it into something, which means you can easily make an array of pairs:\par
\u8203? \tab [...filters];\par
\u8203? \tab\u8203?// [['color', 'black'], ['breed', 'labrador']]\u8203?\par
\par
I hope this has given you an idea about how to solve your sort problem. Try it out and see what you come up with. The only catch is that, because you\rquote re sorting an array of arrays, you should supply an explicit compare function. This isn\rquote t strictly necessary because the default compare function will convert the array of pairs to a string, but it\rquote s better to be clear in your intentions. Once you learn how to make arrow functions in Tip 20, \u8203? Simplify Looping with Arrow Functions \u8203?, the compare function will be a one liner.\par
\par
I bet you came up with something simple like this.\par
collections/mapSpread/iterate.js\par
\u8203? \tab\u8203?function\u8203? sortByKey(a, b) \{\par
\u8203? \tab   \u8203?return\u8203? a[0] > b[0] ? 1 : -1;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getSortedAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? applied = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? [key, value] \u8203?of\u8203? [...filters].sort(sortByKey)) \{\par
\u8203? \tab     applied.push(\u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{value\}\u8203?`\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied.join(\u8203?', '\u8203?)\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// 'Your filters are: breed:labrador, color:black.'\u8203?\par
\par
Now look closely\emdash it can be easy to miss. In the for loop initiator when you\rquote re assigning variables, you quickly spread the map out into an array and then sorted that array. Now you\rquote re getting the results you wanted.\par
\par
There\rquote s a slight problem. If you read the code carefully, you may have noticed that something changed. You started off with a map, but your for loop didn\rquote t actually iterate over the map. It iterated over a new array.\par
\par
Honestly, this isn\rquote t much of a problem. There\rquote s nothing wrong with converting to an array. In fact, it gives you an opportunity to simplify your function even more.\par
\par
Now that you can move easily to an array, you might as well use all of the array methods at your disposal. Because you\rquote re changing every value of the array in the same way, you don\rquote t need to create a new array to collect the results as you did with let applied = []. You can simply use the map() method. If that\rquote s new to you, jump ahead to Tip 22, \u8203? Create Arrays of a Similar Size with map() \u8203?. Try rewriting your initial function to use the map() method.\par
collections/mapSpread/mapSpread.js\par
\u8203? \tab\u8203?function\u8203? getAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? applied = [...filters].map(([key, value]) => \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{value\}\u8203?`\u8203?;\par
\u8203? \tab   \});\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied.join(\u8203?', '\u8203?)\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// 'Your filters are: color:black, breed:labrador.'\u8203?\par
\par
And because everything is now an array, you can combine your sort() function and your join() function using chaining to get everything nice and simple.\par
collections/mapSpread/mapSpread.js\par
\u8203? \tab\u8203?function\u8203? getSortedAppliedFilters(filters) \{\par
\u8203? \tab   \u8203?const\u8203? applied = [...filters]\par
\u8203? \tab     .sort(sortByKey)\par
\u8203? \tab     .map(([key, value]) => \{\par
\u8203? \tab       \u8203?return\u8203? \u8203?`\u8203?$\{key\}\u8203?:\u8203?$\{value\}\u8203?`\u8203?;\par
\u8203? \tab     \})\par
\u8203? \tab     .join(\u8203?', '\u8203?);\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Your filters are: \u8203?$\{applied\}\u8203?.`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// 'Your filters are: breed:labrador, color:black.'\u8203?\par
\par
If you\rquote re getting lost, here\rquote s a summary of the steps:\par
\par
    Convert your map to an array.\par
    Sort the array.\par
    Convert each pair to a string of the form key:value.\par
    Join the array items creating a string.\par
    Combine the string with other information using a template literal.\par
\par
It\rquote s worth repeating that a strong knowledge of arrays can help you create very simple and efficient code. Now that you know that you can move between a map and array with three simple dots, you\rquote ve opened yourself up to many more opportunities for creatively using maps.\par
In the next tip, you\rquote ll see how you can use the spread operator to avoid side effects and mutations. \par
Tip 15\tab Create Maps Without Side Effects\par
\par
In this tip, you\rquote ll learn how to avoid side effects by creating new maps from an array of pairs.\par
\par
Up to this point, you\rquote ve always worked on a single instance of a map. You\rquote ve either added data or removed data directly from an instance of a Map object.\par
\par
Working on the instance of a map can lead to a few problems. How do you create copies of a map? How can you make changes without side effects?\par
\par
Fortunately, you can solve those problems by applying a few principles you\rquote ve learned from arrays and objects.\par
\par
To start, look at an example that combines the problems of copying and mutations: applying a set of defaults to a map.\par
\par
In your pet adoption code, you have filters that users have selected, but perhaps you want to add a set of default filters. Any additional filters will be overridden by the user, but any not explicitly set by the user will be the default.\par
collections/mapSideEffects/sideEffects.js\par
\u8203? \tab\u8203?const\u8203? defaults = \u8203?new\u8203? Map()\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'brown'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'breed'\u8203?, \u8203?'beagle'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'state'\u8203?, \u8203?'kansas'\u8203?);\par
\u8203? \tab\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? filters = \u8203?new\u8203? Map()\par
\u8203? \tab   .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'black'\u8203?);\par
\par
Now you\rquote re in a bind. How can you make a new collection of filters, including the defaults and the user-applied filters?\par
\par
If you didn\rquote t care about side effects (and I really hope you do by now), you might be tempted to check to see if the map has a key using the has() method. If no key exists, set the key value. If the key already exists, you can ignore it.\par
collections/mapSideEffects/sideEffects.js\par
\u8203? \tab\u8203?function\u8203? applyDefaults(map, defaults) \{\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? [key, value] \u8203?of\u8203? defaults) \{\par
\u8203? \tab     \u8203?if\u8203? (!map.has(key)) \{\par
\u8203? \tab       map.\u8203?set\u8203?(key, value);\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ applyDefaults \};\par
\par
If your goal is solely to combine defaults and user data, you\rquote ve succeeded. But by now, your skepticism about mutations should get to you. Consider how you want to use the filters object. You use it to filter data, but you also use it to alert the user to the filters they\rquote ve applied (as you did by creating a string in the previous tip).\par
\par
Now that you\rquote ve mutated the object, it will appear to the user that they applied a bunch of defaults they never selected. Notice that the defaults include a state. You want your users to see only the animals in their state, but you don\rquote t want them to change the state directly. You\rquote d rather they visit the pet adoption page for that state.\par
\par
The simplest way around this problem is to create a copy of the map. As you may recall, you can create a new map by passing in an array of pairs. And you can create a list of pairs with the spread operator.\par
\par
With that in mind, try to update the code to create a copy before it\rquote s mutated.\par
collections/mapSideEffects/copy.js\par
\u8203? \tab\u8203?function\u8203? applyDefaults(map, defaults) \{\par
\u8203? \tab   \u8203?const\u8203? copy = \u8203?new\u8203? Map([...map]);\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? [key, value] \u8203?of\u8203? defaults) \{\par
\u8203? \tab     \u8203?if\u8203? (!copy.has(key)) \{\par
\u8203? \tab       copy.\u8203?set\u8203?(key, value);\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? copy;\par
\u8203? \tab\}\par
\par
If you got something like this, great work! You got the copy of the filters, and you applied the defaults to that (note that it\rquote s okay to mutate something that\rquote s scoped to the function), and then you returned the new map. Now you can be sure that your current filters map is safe from side effects while your new map contains all the defaults and all the applied information.\par
\par
Yet it gets even better. You\rquote re still manually checking a bunch of keys for existence. Fortunately, that\rquote s not even necessary. Maps, like objects, can only have a key once. So if you tried to create a map with a new key, it will use whatever value for that key is declared last. It\rquote s as if you were updating the value instead of setting it.\par
\u8203? \tab\u8203?const\u8203? filters = \u8203?new\u8203? Map()\par
\u8203? \tab .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'black'\u8203?)\par
\u8203? \tab .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'brown'\u8203?);\par
\u8203? \tab\par
\u8203? \tab filters.\u8203?get\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\u8203?// brown\u8203?\par
\par
With this knowledge, you can combine what you know about the object spread operator to create a combination of two maps in one line.\par
\u8203? \tab\u8203?let\u8203? filters = \u8203?new\u8203? Map()\par
\u8203? \tab .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'black'\u8203?);\par
\u8203? \tab\par
\u8203? \tab\u8203?let\u8203? filters2 = \u8203?new\u8203? Map()\par
\u8203? \tab .\u8203?set\u8203?(\u8203?'color'\u8203?, \u8203?'brown'\u8203?);\par
\u8203? \tab\par
\u8203? \tab\u8203?let\u8203? update =  \u8203?new\u8203? Map([...filters, ...filters2]);\par
\u8203? \tab\par
\u8203? \tab update.\u8203?get\u8203?(\u8203?'color'\u8203?);\par
\u8203? \tab\par
\u8203? \tab\u8203?// brown\u8203?\par
\par
Now when you update the function again, you realize you don\rquote t even need the function at all. Combining and creating maps becomes a one liner.\par
collections/mapSideEffects/map.js\par
\u8203? \tab\u8203?function\u8203? applyDefaults(map, defaults) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?new\u8203? Map([...defaults, ...map]);\par
\u8203? \tab\}\par
\par
Maps really do combine some of the best ideas from many other data structures. This should give you some ideas for how you can start using them in your code.\par
\par
In the next tip, you\rquote ll learn about another new collection, Set, which does one thing very well: creating a list of unique items.\par
\par
Tip 16\tab Keep Unique Values with Set\par
\par
In this tip, you\rquote ll learn how to quickly pull unique items from an array with Set.\par
\par
Set is a fairly simple collection that can do only one thing, but it does it very well. Set is like a specialized array that can contain only one instance of each unique item. You\rquote ll often want to collect values from a large array of objects, but you only need to know the unique values. There are other use cases as well, but collecting a list of distinct information from a group of objects is very, very common.\par
\par
In that spirit, return once again to our set of filters that you\rquote re building. To even know what a user can filter on, you need to gather all the possible values. Recall the array of dogs that you worked with earlier.\par
\u8203? \tab\u8203?const\u8203? dogs = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'max'\u8203?,\par
\u8203? \tab     size: \u8203?'small'\u8203?,\par
\u8203? \tab     breed: \u8203?'boston terrier'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'don'\u8203?,\par
\u8203? \tab     size: \u8203?'large'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'shadow'\u8203?,\par
\u8203? \tab     size: \u8203?'medium'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'chocolate'\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab ]\par
\par
How would you get a list of all the color options? In this case, the answer is obvious, but what if the list grows into several hundred dogs? How can you be sure we get all the potential choices from golden retrievers to blue pit bulls to mottled border collies?\par
\par
One simple way to get a collection of all the colors is to use the map() array method. You\rquote ll explore this more in Tip 22, \u8203? Create Arrays of a Similar Size with map() \u8203?, but for now, all you need to know is that it will return an array of only the colors.\par
collections/set/unique.js\par
\u8203? \tab\u8203?function\u8203? getColors(dogs) \{\par
\u8203? \tab   \u8203?return\u8203? dogs.map(dog => dog.color);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getColors(dogs);\par
\u8203? \tab\par
\u8203? \tab\u8203?// ['black', 'black', 'chocolate']\u8203?\par
\par
The problem is that this is only the first part. Now that you have all the colors, you need to reduce that to an array of unique values. You could pull those out in a number of different ways. There are for loops and reduce() functions. But for now, stick with a simple for loop.\par
collections/set/unique.js\par
\u8203? \tab\u8203?function\u8203? getUnique(attributes) \{\par
\u8203? \tab   \u8203?const\u8203? unique = [];\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? attribute \u8203?of\u8203? attributes) \{\par
\u8203? \tab     \u8203?if\u8203? (!unique.includes(attribute)) \{\par
\u8203? \tab       unique.push(attribute);\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? unique;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? colors = getColors(dogs);\par
\u8203? \tab getUnique(colors);\par
\u8203? \tab\u8203?// ['black', 'chocolate']\u8203?\par
\par
Seems easy enough, but fortunately now you don\rquote t even need to write that much code. You can use the Set object to handle the work of pulling out unique values. A set is a common data type and you may be familiar with it from other languages.\par
\par
The interface is very simple and resembles Map in many ways. The main difference is that instead of taking an array of pairs, you can create a new instance of Set by passing a flat array as an argument.\par
\par
If you pass your array of colors into a set, you\rquote re nearly there.\par
\u8203? \tab\u8203?const\u8203? colors = [\u8203?'black'\u8203?, \u8203?'black'\u8203?, \u8203?'chocolate'\u8203?];\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? unique = \u8203?new\u8203? Set(colors);\par
\u8203? \tab\u8203?// Set \{'black', 'chocolate'\}\u8203?\par
\par
You probably noticed that the value of the object is a Set containing only one instance of each color. And that may seem like a problem. You don\rquote t want a Set\emdash you want an array of unique items.\par
\par
Well, by now you may have guessed the solution: the spread operator. You can use the spread operator on Set much like you did with Map. The only difference is that Set returns an array. Exactly what you want! Now you can refactor the getUnique() function to a one liner. Notice that you can even use the spread operator on instance creation\emdash you don\rquote t even need to assign it to a variable.\par
collections/set/set.js\par
\u8203? \tab\u8203?function\u8203? getUnique(attributes) \{\par
\u8203? \tab   \u8203?return\u8203? [...\u8203?new\u8203? Set(attributes)];\par
\u8203? \tab\}\par
\par
Maybe this code still doesn\rquote t sit well with you. Good! That means your intuition is sharpening. If it seems like you\rquote re being inefficient, you\rquote re correct. You\rquote re first looping over the array of dogs to get an array of colors; then you\rquote re manipulating that array to get a list of unique values. Can\rquote t you do both at once?\par
\par
You sure can. Set, again, is similar to Map in that you have methods to add and check for values. For a set, you can add a value with add() and check a value with has(). You also have delete() and clear(), which work exactly as they do in Map.\par
\par
This all means means that you can add items to a set individually as you go through a loop instead of all at once by passing an array of values. A set can keep only one of each value. If you try to add a value that isn\rquote t yet in the set, it will be added. If you try to add a value that already exists, it will be ignored. Order is preserved, and the initial point a value is added will remain. If you try to add an item that\rquote s there already, it keeps the original position.\par
\u8203? \tab\u8203?let\u8203? names = \u8203?new\u8203? Set();\par
\u8203? \tab names.add(\u8203?'joe'\u8203?);\par
\u8203? \tab\u8203?// Set \{ 'joe'\}\u8203?\par
\u8203? \tab\par
\u8203? \tab names.add(\u8203?'bea'\u8203?);\par
\u8203? \tab\u8203?// Set \{ 'joe', 'bea'\}\u8203?\par
\u8203? \tab\par
\u8203? \tab names.add(\u8203?'joe'\u8203?);\par
\u8203? \tab\u8203?// Set \{ 'joe', 'bea'\}\u8203?\par
\par
You now have the tools to get the unique values in one pass through the array of dogs. There\rquote s no need to first get all colors and then get all the unique items. You can get them in one loop.\par
collections/set/set.js\par
\u8203? \tab\u8203?function\u8203? getUniqueColors(dogs) \{\par
\u8203? \tab   \u8203?const\u8203? unique = \u8203?new\u8203? Set();\par
\u8203? \tab   \u8203?for\u8203? (\u8203?const\u8203? dog \u8203?of\u8203? dogs) \{\par
\u8203? \tab     unique.add(dog.color);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? [...unique];\par
\u8203? \tab\}\par
\par
In this code, you used a simple for loop. But you can easily simplify this action to a one liner with a reduce() function. Reduce functions are awesome and you\rquote ll love them, but they\rquote re a little more complicated. You\rquote ll get a chance to explore them thoroughly in Tip 26, \u8203? Transform Array Data with reduce() \u8203?, but here\rquote s a sample of how you can get the unique values in one line.\par
collections/set/set.js\par
\u8203? \tab [...dogs.reduce((colors, \{ color \}) => colors.add(color), \u8203?new\u8203? Set())];\par
\par
By now you\rquote re probably feeling excited about all the new ways you can experiment with collections in your code. There are a few more you haven\rquote t touched, such as WeakMap and WeakSet, and you should try them out. The best place for JavaScript documentation is always The Mozilla Developer Network.[18]\par
\par
But that\rquote s enough talk about collections. It\rquote s time to start building things. The next step is learning to use control structures to handle conditional actions.\par
\par
In the next chapter, you\rquote ll look at how you can apply the same standards of simplicity and readability to conditional statements.\par
Footnotes\par
\par
[12]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/tc39/proposal-object-rest-spread }}{\fldrslt{https://github.com/tc39/proposal-object-rest-spread\ul0\cf0}}}}\f1\fs22\par
[13]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\ul0\cf0}}}}\f1\fs22\par
[14]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Keyed_collections_Maps_Sets_WeakMaps_WeakSets }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Keyed_collections_Maps_Sets_WeakMaps_WeakSets\ul0\cf0}}}}\f1\fs22\par
[15]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/facebook/react/pull/7232#issuecomment-231516712 }}{\fldrslt{https://github.com/facebook/react/pull/7232#issuecomment-231516712\ul0\cf0}}}}\f1\fs22\par
[16]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\ul0\cf0}}}}\f1\fs22\par
[17]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/tc39/proposal-object-values-entries }}{\fldrslt{https://github.com/tc39/proposal-object-values-entries\ul0\cf0}}}}\f1\fs22\par
[18]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org }}{\fldrslt{https://developer.mozilla.org\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 4\par
Write Clear Conditionals\par
\par
Have you ever been sucked into a round of spring cleaning? I don\rquote t mean the kind where you put \ldblquote Scrub the floors\rdblquote  on your to-do list and then you actually do it. Rather, say it\rquote s a nice day so you open the window, but as soon as you do, a pile of papers blows off your desk. That\rquote s fine, you\rquote ve been meaning to organize those anyway. So you start filing, but without that stack of papers hiding everything, now you notice that your computer cables look all tangled and sloppy, and how long has that coffee mug been hiding back there? Before you know it, you\rquote re taking your whole office apart. Once you start removing clutter, it\rquote s hard to stop.\par
\par
By now, you\rquote ve likely started getting a taste for clean and simple JavaScript. And that\rquote s wonderful. The new syntax allows you to do so much more with much less code. But you don\rquote t need to wait for new syntax before you make a positive change to your code.\par
\par
Let\rquote s take a quick detour from new syntax to explore some older ideas, but with a new goal: making clean and predictable JavaScript code.\par
\par
In this chapter, you\rquote re going to clean up conditional expressions. You\rquote ll revisit basic ideas, such as truthy and falsy values, ternary expressions, and short circuiting, with the goal of keeping everything simple and clean.\par
\par
There\rquote s also a practical side: Now that you have more tools to assign and work with data, you can reuse old ideas to further leverage the new syntax.\par
\par
Here\rquote s a basic example: Let\rquote s say you wanted to set the color on a value. If the value is a negative number, you want the color to be red. If the value is positive, you want it to be green.\par
\u8203? \tab\u8203?const\u8203? transactions = [...spending, ...income];\par
\u8203? \tab\u8203?const\u8203? balance = calculateBalance(transactions);\par
\u8203? \tab\par
\u8203? \tab\u8203?let\u8203? color;\par
\u8203? \tab\par
\u8203? \tab\u8203?if\u8203?(balance > 0) \{\par
\u8203? \tab     color = \u8203?'green'\u8203?;\par
\u8203? \tab\} \u8203?else\u8203? \{\par
\u8203? \tab     color = \u8203?'red'\u8203?;\par
\u8203? \tab\}\par
\par
The first two lines are like my newly cleaned desk. They\rquote re clear and expressive, and are assigned with const, so you know they aren\rquote t changing. But as with spring cleaning, you look down and suddenly things seem awfully messy.\par
\par
Where did that let come from? Oh, right. You need it to set the color, which will be mutated by the conditional. I guess it\rquote s okay, but it just doesn\rquote t feel as clean as the rest of the code.\par
\par
All of a sudden, that block of code just doesn\rquote t look right. Fortunately, you don\rquote t need to leave it like that. You can rewrite it with the same simple syntax as before. No new syntax necessary.\par
\par
To start off, you\rquote ll look at truthy and falsy values in JavaScript. Many techniques to simplify code involve truthy and falsy values, so you\rquote ll want a firm foundation. Next, you\rquote ll look at ternaries, a simple method for reducing if/else conditionals to a single line. Finally, you\rquote ll learn to write extremely concise conditionals and variable assignment with short circuiting.\par
\par
It\rquote s time to clean up the clutter in your conditionals. Between truthy values, ternaries, and short circuiting, you\rquote ll be writing conditionals that fit with your modern JavaScript code. And as you move into array methods and functions, you\rquote ll see these ideas return over and over.\par
\par
Let\rquote s get started putting your house in order. \par
\par
Tip 17\tab Shorten Conditionals with Falsy Values\par
\par
In this tip, you\rquote ll learn how to use falsy and truthy values to check for information from different types.\par
\par
Can you remember the first line of code you ever wrote? I can\rquote t, but I wouldn\rquote t be surprised if it was some sort of conditional. Responding one way to some information and a different way to other information is about as basic as programming can get.\par
\par
I still write a lot of conditionals every day, and I bet you do, too. Fortunately, JavaScript, along with many other languages, gives you many tools for checking information and reassigning or standardizing information very quickly with minimal code.\par
\par
The secret to being able to check values quickly is to understand the subtle difference between the primitive values true and false (also called Boolean types) and the many so-called truthy and falsy values\emdash values that aren\rquote t identical to the Boolean values true or false but act like they are in most cases.\par
\par
I bet you thought we were about to dig into that idea. Well, give me just one more moment to review another concept: equivalency and identity\emdash a value that\rquote s equivalent if it\rquote s the same, but of a different type and is checked with \lquote ==\lquote .\par
\u8203? \tab 1 == \u8203?'1'\u8203? \u8203?// true\u8203?\par
\par
Identical values, or values with strict equality, mean that they must be of the same type.\par
\u8203? \tab 1 === \u8203?'1'\u8203? \u8203?// false\u8203?\par
\u8203? \tab 1 === 1 \u8203?// true\u8203?\par
\par
Objects, including instances of arrays, are checked by their reference (remember reference from Object.assign()?).\par
\par
The topic can get much deeper, but for now we want to identify values that are equivalent to false or true but not identical.\par
\par
Okay. Back to truthy and falsy values. An empty string is equal to false (but not identical). In other words, it\rquote s falsy.\par
\u8203? \tab\u8203?''\u8203? == \u8203?false\u8203? \u8203?// true\u8203?\par
\u8203? \tab\u8203?if\u8203?(\u8203?''\u8203?) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?'I am not false!'\u8203?\par
\u8203? \tab\} \u8203?else\u8203? \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?'I am false :( !'\u8203?\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// I am false :(\u8203?\par
\par
Here\rquote s a quick list of values that are falsy courtesy of Mozilla Developer Network:[19]\par
\par
    false\par
    null\par
    0\par
    NaN (not a number)\par
    \rdblquote\par
    ""\par
\par
The ones that are worth memorizing are 0, null, and an empty string. Let\rquote s hope you can remember that false is a falsy value.\par
\par
Notice a few things conspicuously absent? If you wondered about the absence of arrays and objects (not to mention the other collection types), good eye. Arrays and objects, even empty arrays and objects, are always truthy. So you\rquote ll have to find another way to check emptiness with either [].length or Object.keys(\{\}).length, which will give you either 0 or a nice truthy number.\par
\par
Okay, you may be wondering why you should care about falsy values and truthy values (whatever is not falsy is truthy, of course). They\rquote re important because you can shorten a lot of otherwise lengthy expressions.\par
\u8203? \tab\u8203?const\u8203? employee = \{\par
\u8203? \tab   name: \u8203?'Eric'\u8203?,\par
\u8203? \tab   equipmentTraining: \u8203?''\u8203?,\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?if\u8203?(!employee.equipmentTraining) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?'Not authorized to operate machinery'\u8203?;\par
\u8203? \tab\}\par
\par
You don\rquote t need the code to know anything about when they received their equipment training. The code doesn\rquote t need to know if it\rquote s a date or a certificate name. All that the code needs to know is that the value exists and there\rquote s something there.\par
\par
But there are a few catches. Here\rquote s where things get tricky. It can be easy to create a falsy value unintentionally. The most common problem occurs when you\rquote re testing existence in an array by checking the index of a value:\par
\u8203? \tab [\u8203?'a'\u8203?, \u8203?'b'\u8203?].indexOf(\u8203?'a'\u8203?)\par
\u8203? \tab\u8203?// 0 which is falsy\u8203?\par
\par
You already saw this problem when you explored Array.includes(), so it should sneak up on you less often than it might have before. A much more subtle problem arises when you look for key-value data that\rquote s not defined. If you try to pull a value from a key that\rquote s not defined, you\rquote ll get undefined, which may cause a problem if an object or map were to change elsewhere in the code.\par
\par
Let\rquote s change the object just a bit to make equipmentTraining a Boolean.\par
\u8203? \tab\u8203?const\u8203? employee = \{\par
\u8203? \tab   name: \u8203?'Eric'\u8203?,\par
\u8203? \tab   equipmentTraining: \u8203?true\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? listCerts(employee) \{\par
\u8203? \tab     \u8203?if\u8203?(employee.equipmentTraining) \{\par
\u8203? \tab         employee.certificates = [\u8203?'Equipment'\u8203?];\par
\u8203? \tab\par
\u8203? \tab         \u8203?// Mutation!\u8203?\par
\u8203? \tab         \u8203?delete\u8203? employee.equipmentTraining;\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?// More code.\u8203?\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab checkAuthorization() \{\par
\u8203? \tab     \u8203?if\u8203?(!employee.equipmentTraining) \{\par
\u8203? \tab         \u8203?return\u8203? \u8203?'Not authorized to operate machinery'\u8203?;\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?return\u8203? \u8203?'Hello, $\{employee.name\}'\u8203?\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab listCerts(employee);\par
\u8203? \tab\par
\u8203? \tab checkAuthorization(employee);\par
\u8203? \tab\u8203?// 'Not authorized to operate machinery'\u8203?\par
\par
What happened here? The function listCerts() mutated the object and removed the key-value data. In the next function, you tried to check a value on the object. On objects, if the key isn\rquote t defined, you don\rquote t get an error\emdash you get undefined (the same is true for maps). This would be a puzzling bug because when you inspect the code, it looks like the employee has certifications and should pass the conditional. Once again, be very careful with mutations.\par
\par
How can you solve the problem? There are actually two answers. Can you guess both of them?\par
\par
The first, and far superior, solution is to not mutate the data. Falsy statements are way too valuable to give up. If a function is mutating the data, change the function.\par
\par
If, for some reason, you\rquote re unable to do that, you can use a strict equivalency check to make sure the value is there and it\rquote s in the format you want. If you use strict equivalency, you can guard against a situation where someone sets employee.equipmentTraining to \rquote Not Trained\rquote , which is truthy.\par
\u8203? \tab checkAuthorization() \{\par
\u8203? \tab     \u8203?if\u8203?(employee.equipmentTraining !== \u8203?true\u8203?) \{\par
\u8203? \tab         \u8203?return\u8203? \u8203?'Not authorized to operate machinery'\u8203?;\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?return\u8203? \u8203?'Hello, $\{employee.name\}'\u8203?\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab checkAuthorization(employee);\par
\u8203? \tab\u8203?// 'Not authorized to operate machinery'\u8203?\par
\par
More code, but that\rquote s okay. Things happen. You don\rquote t need to chain yourself to falsy values, but you should certainly understand them. They\rquote re about to play a big role.\par
\par
In the next tip, you\rquote ll learn how to use falsy and truthy values to make quick data checks.\par
\par
Tip 18\tab Check Data Quickly with the Ternary Operator\par
\par
In this tip, you\rquote ll learn how to avoid reassignment with the ternary operator.\par
\par
By now, you may have noticed that I love simple code. I\rquote ll always try to get an expression reduced down to the fewest characters I can. I blame a former coworker who reviewed some code I wrote at one of my first jobs.\par
\u8203? \tab\u8203?if\u8203?(active) \{\par
\u8203? \tab     \u8203?var\u8203? display = \u8203?'bold'\u8203?\par
\u8203? \tab\} \u8203?else\u8203? \{\par
\u8203? \tab     \u8203?var\u8203? display = \u8203?'normal'\u8203?\par
\u8203? \tab\}\par
\par
He took one glance and casually said, \ldblquote You should just make that a ternary.\rdblquote\par
\par
\ldblquote Of course,\rdblquote  I agreed, not quite sure what he was talking about. After looking it up, I simplified the code to a one-line expression and my code has never been the same.\par
\u8203? \tab\u8203?var\u8203? display = active ? \u8203?'bold'\u8203? : \u8203?'normal'\u8203?;\par
\par
Chances are you\rquote ve worked with ternary operators before. They\rquote re common in most languages, and they allow you to do a quick if/then check. (Although they aren\rquote t exclusively for this purpose, it is by far the most common usage.)\par
\par
If the ternary operator isn\rquote t new, why should it interest you? In returning to some of the larger themes we\rquote ve been exploring, ternary expressions allow your code to be not just more simple as I\rquote ve mentioned, but also more predictable. They do this because they cut down on the number of variables that are being reassigned.\par
\par
Besides, with new variable types, we hit some problems with excessive if/else statements. If you try to check a variable and you\rquote re using a block scoped variable, you won\rquote t be able to access the variable outside of the check.\par
conditionals/ternary/if.js\par
\u8203? \tab\u8203?if\u8203? (title === \u8203?'manager'\u8203?) \{\par
\u8203? \tab   \u8203?const\u8203? permissions = [\u8203?'time'\u8203?, \u8203?'pay'\u8203?];\par
\u8203? \tab\} \u8203?else\u8203? \{\par
\u8203? \tab   \u8203?const\u8203? permissions = [\u8203?'time'\u8203?];\par
\u8203? \tab\}\par
\u8203? \tab permissions;\par
\u8203? \tab\u8203?// ReferenceError: permissions is not defined\u8203?\par
\par
Now you\rquote re forced to either use var, which is accessible outside the block scope, or you have to define the variable with let and then reassign it inside the if/else block. Here\rquote s how it would look with the assignment before the block:\par
conditionals/ternary/if.js\par
\u8203? \tab\u8203?let\u8203? permissions;\par
\u8203? \tab\u8203?if\u8203? (title === \u8203?'manager'\u8203?) \{\par
\u8203? \tab   permissions = [\u8203?'time'\u8203?, \u8203?'pay'\u8203?];\par
\u8203? \tab\} \u8203?else\u8203? \{\par
\u8203? \tab   permissions = [\u8203?'time'\u8203?];\par
\u8203? \tab\}\par
\par
Before let and const, you didn\rquote t have to worry so much about when variables were created. Now, in addition to excessive code, there\rquote s a potential for scope conflicts.\par
\par
Ternary expressions solve these problems. Clearly, they cut down on a lot of extra code. But they also allow you to be more predictable by assigning a value directly to const. How could you rewrite the preceding code to use const and a ternary?\par
conditionals/ternary/ternary.js\par
\u8203? \tab\u8203?const\u8203? permissions = title === \u8203?'manager'\u8203? ? [\u8203?'time'\u8203?, \u8203?'pay'\u8203?] : [\u8203?'time'\u8203?];\par
\par
Much cleaner and you now have a predictable value.\par
\par
There\rquote s one caution you should keep in mind: Though you can chain multiple ternary expressions together, you should avoid doing so. Imagine that there\rquote s another user type called supervisor that couldn\rquote t see the pay rate but could authorize overtime. You might be tempted to just add another ternary expression. What\rquote s the harm, right?\par
conditionals/ternary/ternaryProblem.js\par
\u8203? \tab\u8203?const\u8203? permissions = title === \u8203?'supervisor'\u8203? || title === \u8203?'manager'\u8203? ?\par
\u8203? \tab   title === \u8203?'manager'\u8203? ?\par
\u8203? \tab     [\u8203?'time'\u8203?, \u8203?'overtimeAuthorization'\u8203?, \u8203?'pay'\u8203?] : [\u8203?'time'\u8203?, \u8203?'overtimeAuthorization'\u8203?]\par
\u8203? \tab   : [\u8203?'time'\u8203?];\par
\par
At that point, the ternary becomes unreadable and loses the value of simplicity. Instead, you should move the check completely out of the block into a standalone function (with a nice test, of course). That way, you can still use const without worrying about excessive code.\par
conditionals/ternary/ternaryProblem.js\par
\u8203? \tab\u8203?function\u8203? getTimePermissions(\{ title \}) \{\par
\u8203? \tab   \u8203?if\u8203? (title === \u8203?'manager'\u8203?) \{\par
\u8203? \tab     \u8203?return\u8203? [\u8203?'time'\u8203?, \u8203?'overtimeAuthorization'\u8203?, \u8203?'pay'\u8203?];\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?if\u8203? (title === \u8203?'supervisor'\u8203?) \{\par
\u8203? \tab     \u8203?return\u8203? [\u8203?'time'\u8203?, \u8203?'overtimeAuthorization'\u8203?];\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? [\u8203?'time'\u8203?];\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? permissions = getTimePermissions(\{ title: \u8203?'employee'\u8203? \});\par
\u8203? \tab\u8203?// ['time']\u8203?\par
\par
There\rquote s no harm in making short functions that have a single non-abstract purpose. In fact, it\rquote s a good step to writing clean code. You still get the value of assigning the return value to const and everything is clear and readable. Ternary expressions can simplify things, but use them when they add value and go back to standard if blocks if they create too much ambiguity.\par
\par
In the next tip, you\rquote ll make quick data checks even easier with short circuiting.\par
\par
Tip 19\tab Maximize Efficiency with Short Circuiting\par
\par
In this tip, you\rquote ll learn to reduce conditionals to the smallest possible expression with short circuiting.\par
\par
You\rquote ve been simplifying conditional expressions a lot in the last few tips. But there\rquote s one more level of simplification you can use: short circuiting.\par
\par
As the name implies, the goal of short circuiting is to bypass information checks by placing the most relevant information first.\par
\par
Consider the following ternary, which would fit in well with the discussion from the previous chapter.\par
conditionals/shortCircuiting/ternary.js\par
\u8203? \tab\u8203?function\u8203? getIconPath(icon) \{\par
\u8203? \tab   \u8203?const\u8203? path = icon.path ? icon.path : \u8203?'uploads/default.png'\u8203?;\par
\u8203? \tab   \u8203?return\u8203? \u8203?`https://assets.foo.com/\u8203?$\{path\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
The goal here is fairly clear. If an icon has a truthy path (in this case, that means it\rquote s defined and isn\rquote t an empty string), then you want to use the path. If it\rquote s falsy, undefined, or \rdblquote , then you want to use the default.\par
\u8203? \tab\u8203?const\u8203? icon = \{\par
\u8203? \tab     path: \u8203?'acme/bar.png'\u8203?\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getIconPath(icon);\par
\u8203? \tab\par
\u8203? \tab\u8203?// '{{\field{\*\fldinst{HYPERLINK https://assets.foo.com/acme/bar.png }}{\fldrslt{https://assets.foo.com/acme/bar.png\ul0\cf0}}}}\f1\fs22 ';\u8203?\par
\par
Did you see any clues that suggest you can clean up this code a bit?\par
\par
You probably noticed that you\rquote re writing the information check, icon.path, twice. Let\rquote s assume that data is always going to be valid, which means there\rquote s no difference between the information we\rquote re checking and the information we want. If it\rquote s truthy, we\rquote re going to use it.\par
\par
Before updating the code, take a moment to think about how logical operators work. The or operator, symbolized as ||, will return true if any of the possible values are true. That means that as soon as one thing\emdash anything\emdash returns true, you don\rquote t care what the other values might be.\par
\par
Now here\rquote s where it gets exciting. Because you can use truthy values to test a Boolean expression, true or false, there\rquote s no incentive for the language to change the value from something truthy to true. So if one value in an || check returns true, you get that truthy value and not true.\par
\par
Lost? Don\rquote t worry. That\rquote s a long way of saying you can assign values directly from a Boolean check.\par
\u8203? \tab\u8203?const\u8203? name = \u8203?'joe'\u8203? || \u8203?'I have no name'\u8203?;\par
\u8203? \tab name\par
\u8203? \tab\u8203?// 'joe'\u8203?\par
\par
Now you have all of the tools you need to rewrite the ternary to something concise.\par
conditionals/shortCircuiting/shortCircuiting.js\par
\u8203? \tab\u8203?function\u8203? getIconPath(icon) \{\par
\u8203? \tab   \u8203?const\u8203? path = icon.path || \u8203?'uploads/default.png'\u8203?;\par
\u8203? \tab   \u8203?return\u8203? \u8203?`https://assets.foo.com/\u8203?$\{path\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
As you may have noticed, the best part is that you can append a default value to the end of the expression. This means that you never have to worry about a variable being falsy because you know there\rquote s a truthy value waiting at the end.\par
\par
There you have it. You can use short circuiting to bypass information once something truthy occurs. How about the other way around? How can you halt an expression once something false occurs? That\rquote s possible as well.\par
\par
Another popular usage of short circuiting is to prevent errors, particularly when you plan to use a method or action on a particular collection.\par
\par
Consider a slight change to the problem of getting an icon. Instead of finding an icon set, you need to get a set of images from a user. The first image will be used as a thumbnail.\par
\par
Because there are many images, the images collection will be an array. And your code needs to be able to handle the following representations:\par
\u8203? \tab\u8203?// No array specified\u8203?\par
\u8203? \tab\u8203?const\u8203? userConfig1 = \{\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?// An array with no elements\u8203?\par
\u8203? \tab\u8203?const\u8203? userConfig2 = \{\par
\u8203? \tab     images: []\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// An array with elements\u8203?\par
\u8203? \tab\u8203?const\u8203? userConfig3 = \{\par
\u8203? \tab     images: [\par
\u8203? \tab         \u8203?'me.png'\u8203?,\par
\u8203? \tab         \u8203?'work.png'\u8203?\par
\u8203? \tab     ]\par
\u8203? \tab\}\par
\par
You may start off by thinking you could use short circuiting with the || operator to get the value you want. But that won\rquote t work for instances where the property isn\rquote t defined.\par
\u8203? \tab\u8203?const\u8203? userConfig1 = \{\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? img = userConfig1.images[0] || \u8203?'default.png'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?//TypeError: Cannot read property '0' of undefined\u8203?\par
\par
The next step might be to use a series of nested conditionals.\par
conditionals/shortCircuiting/conditional.js\par
\u8203? \tab\u8203?function\u8203? getFirstImage(userConfig) \{\par
\u8203? \tab   \u8203?let\u8203? img = \u8203?'default.png'\u8203?;\par
\u8203? \tab   \u8203?if\u8203? (userConfig.images) \{\par
\u8203? \tab     img = userConfig.images[0];\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? img;\par
\u8203? \tab\}\par
\par
At least in that example, you won\rquote t get an error if the images array isn\rquote t defined. But it will create a problem if there are no elements of the array.\par
\u8203? \tab\u8203?const\u8203? userConfig = \{\par
\u8203? \tab     images: []\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? img = getFirstImage(userConfig);\par
\u8203? \tab\par
\u8203? \tab\u8203?//undefined\u8203?\par
\par
Now to solve that problem, you might add another nested conditional.\par
conditionals/shortCircuiting/conditional.js\par
\u8203? \tab\u8203?function\u8203? getImage(userConfig) \{\par
\u8203? \tab   \u8203?let\u8203? img = \u8203?'default.png'\u8203?;\par
\u8203? \tab   \u8203?if\u8203? (userConfig.images) \{\par
\u8203? \tab     \u8203?if\u8203? (userConfig.images.length) \{\par
\u8203? \tab       img = userConfig.images[0];\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? img;\par
\u8203? \tab\}\par
\par
Things are already starting to get a little ugly and unreadable.\par
\par
Fortunately, short circuiting can help. Combining conditionals with the && operator will allow you to avoid the TypeError you saw earlier. A logical string built with an && operator will cease as soon as a false value occurs. This means that you don\rquote t have worry about a TypeError when you try to call a method that doesn\rquote t exist. You can safely check for the existence of a collection and then call a method on it.\par
conditionals/shortCircuiting/shortCircuiting.js\par
\u8203? \tab\u8203?function\u8203? getImage(userConfig) \{\par
\u8203? \tab   \u8203?if\u8203? (userConfig.images && userConfig.images.length > 0) \{\par
\u8203? \tab     \u8203?return\u8203? userConfig.images[0];\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \u8203?'default.png'\u8203?;\par
\u8203? \tab\}\par
\par
Now, this isn\rquote t perfect because you\rquote re just checking for a truthy value, which means that if there\rquote s bad data and images is set to a string, you\rquote ll get a weird result (the first letter of the string). But I\rquote d leave it the way it is. At some point, you have to have a little trust in your data or you need to find a way to normalize the data higher up the stream.\par
\par
Finally, you can combine your short circuiting back with a ternary to get this check down to a one liner. Start by pulling the images property into its own variable. Remember that if it\rquote s not there, the variable will merely be undefined.\par
conditionals/shortCircuiting/ternary.js\par
\u8203? \tab\u8203?function\u8203? getImage(userConfig) \{\par
\u8203? \tab   \u8203?const\u8203? images = userConfig.images;\par
\u8203? \tab   \u8203?return\u8203? images && images.length ? images[0] : \u8203?'default.png'\u8203?;\par
\u8203? \tab\}\par
\par
Be careful when combining ternaries and short circuiting. Things can get out of hand very quickly. Say, for example, that you want to make sure the image didn\rquote t have a GIF extension. You\rquote d still have to make sure there are elements in the array, or else you\rquote d get another TypeError by checking for an index value on undefined. The resulting code is getting crazy.\par
conditionals/shortCircuiting/ternary.js\par
\u8203? \tab\u8203?const\u8203? images = userConfig.images;\par
\u8203? \tab\u8203?return\u8203? images &&\par
\u8203? \tab             images.length &&\par
\u8203? \tab             images[0].indexOf(\u8203?'gif'\u8203?) < 0\par
\u8203? \tab   ? images[0] : \u8203?'default.png'\u8203?;\par
\par
You could refactor your code to check for an image. Or you could check the extension with a regular expression instead of an index. There are lots of ways around the problem. At some point, you need to make sure your conditionals are making code more clear and not just shorter for the sake of being short.\par
\par
There\rquote s no explicit rule about how many conditionals are too many. It\rquote s more a matter of taste and team agreement. But when things get long (usually around three conditional checks), it\rquote s better to make it a standalone function.\par
\par
Simplicity is great. And it\rquote s fun to try and find clever ways to reduce things to one line. But the goal is always communication and readability. Use short circuiting to make things readable\emdash not to make code artificially small.\par
\par
Now that you can make simple conditionals, it\rquote s time to put that knowledge into action.\par
\par
In the next chapter, you\rquote ll explore loops and how you can create simplified loops that avoid mutations, return predictable results, and can be as short as a single line of code.\par
Footnotes\par
\par
[19]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Glossary/Falsy }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Glossary/Falsy\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 5\par
Simplify Loops\par
\par
My auto mechanics teacher in high school once started off class by holding up a large adjustable wrench. \ldblquote Some people think this is the only tool they need,\rdblquote  he said. He demonstrated how someone could use the wrench to unscrew a bolt, take off a screw, and pry off a gasket like a set of pliers. \ldblquote They even use it as a hammer,\rdblquote  he said as he swung the wrench in the air.\par
\par
\ldblquote But if all you use is a wrench, you\rquote ll round off your bolts. You\rquote ll snap off fan blades, dent your car, and generally make things worse.\rdblquote  As he finished, he placed the wrench on the bench. \ldblquote And that\rquote s why we have specialized tools,\rdblquote  he said as he showed us how to use ratchet wrenches, torque wrenches, spark plug gap gauges, and all the other tools a good mechanic keeps at hand.\par
\par
You\rquote re about to get your specialized set of tools for looping through data in JavaScript. When you use the right tool, your code will be more clear, and you\rquote ll signal your intentions to other developers.\par
\par
You\rquote ve almost certainly used a for loop before. If you wanted to convert an array of integers to strings, you could easily use a for loop. You simply need to create an empty array, loop through the values one at a time using the index from the for loop, and push the new values into new array.\par
\par
But you know that will just create problems. You\rquote ll have more variables to keep track of. You\rquote ll have mutations. And other developers will have no clue what you\rquote re trying to accomplish. When you use one type of loop, other developers won\rquote t know if you\rquote re returning all results of an original array or just a subset. They won\rquote t know at a glance if you\rquote re converting data types or changing the collection from an array to an object.\par
\par
If you try to solve every problem with one tool, your code will be complex and hard to use. You need better tools.\par
\par
We\rquote re going to start off by jumping ahead a bit to see how to use arrow functions. Arrow functions turn simple loops into one-liners. Next, you\rquote ll get an in-depth look at how array methods simplify loops and how you can know what to expect based on the specialized loop. From there, we\rquote ll explore several different array methods one at a time. We\rquote ll start with map(), which pulls the same information out from each collection. We\rquote ll look at a series of specialized loops that do one task well, finishing with the most flexible loop, reduce(), which can do pretty much anything. We\rquote ll wrap up by exploring the updated for...of and for...in loops, which use clear variable names instead of indexes.\par
\par
The best mechanics can always grab the right tool for the job. Coding is no different. If you look at the best code, you\rquote ll notice the developers always use the loop that fits their intentions. These new loops take practice and can be confusing. But before you know it, you\rquote ll be able to use them with ease, and you\rquote ll love how clear and expressive you\rquote ve made your code. Special tools exist for a reason. Time to learn how to use them. To start, take a look at one of the most beloved new features in JavaScript: arrow functions. \par
\par
Tip 20\tab Simplify Looping with Arrow Functions\par
\par
In this tip, you\rquote ll learn to cut out extraneous information with arrow functions.\par
\par
In JavaScript, you see a lot of callback functions. Those are functions that are passed as a parameter to other functions. Most of the loops you\rquote re about to learn depend on callbacks.\par
\par
Like most pre-ES6 code, functions are wordy. You have to explicitly declare that you\rquote re creating a function with the function keyword, add curly braces to signify the body, use return statements to end the function, and so on. It\rquote s not unusual for the callback to be longer than the function you inject it into.\par
\par
Arrow functions changed that and made writing functions simple and short. And learning about them now will make all the loops you see in future tips much more interesting. It will come as no surprise that arrow functions combined with array methods have led some to abandon for loops altogether.\par
\par
Well then, what are arrow functions? Arrow functions strip away as much extraneous information as possible.\par
\par
How much extraneous information is there in a function? Quite a bit. It turns out, you can communicate a function without:\par
\par
    The word function\par
    Parentheses around arguments\par
    The word return\par
    Curly braces\par
\par
All you need to do is use the fat arrow => to indicate that you\rquote ll be building a function. You might be thinking that you\rquote ve just lost everything that makes a function a function. It\rquote s true you can get functions to a minimal state, but there are still a few rules you must follow.\par
\par
Before you begin, you should know that arrow functions look simple, but they actually have a lot of subtle quirks. Fortunately, you don\rquote t need to understand subtleties now. You\rquote ll get to those when you explore them more in Tip 36, \u8203? Prevent Context Confusion with Arrow Functions \u8203?. To start, look at a function that still has most of the extra stuff (parentheses, curly braces, return statements).\par
\par
Here\rquote s a simple function that takes an argument and returns a slightly modified value. In this case, it takes a name and returns the name with a capitalized first letter.\par
loops/arrow/full.js\par
\u8203? \tab\u8203?function\u8203? capitalize(name) \{\par
\u8203? \tab   \u8203?return\u8203? name[0].toUpperCase() + name.slice(1);\par
\u8203? \tab\}\par
\par
Easy, right? But before you can translate this into an arrow function, you should notice that this is a named function. All that means is the name is declared as part of a function, like this:\par
\u8203? \tab\u8203?function\u8203? namedFunction() \{\par
\u8203? \tab\par
\u8203? \tab\}\par
\par
That\rquote s not the only way to create a function. You can also create an anonymous function\emdash a function that doesn\rquote t have a name\emdash and assign it to a variable:\par
\u8203? \tab\u8203?const\u8203? assignedFunction = \u8203?function\u8203?() \{\par
\u8203? \tab\par
\u8203? \tab\}\par
\par
Here\rquote s the same function as an anonymous function. Everything is the same except you\rquote re assigning it to a variable.\par
loops/arrow/anonymous.js\par
\u8203? \tab\u8203?const\u8203? capitalize = \u8203?function\u8203? (name) \{\par
\u8203? \tab   \u8203?return\u8203? name[0].toUpperCase() + name.slice(1);\par
\u8203? \tab\};\par
\par
An arrow function version uses the same idea: an anonymous function you assign to a variable. You can remove the function keyword and replace it with a fat arrow. As a bonus, if you have exactly one parameter (which will be the case for many array methods), you can dispense with the parentheses.\par
loops/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? capitalize = name => \{\par
\u8203? \tab   \u8203?return\u8203? name[0].toUpperCase() + name.slice(1);\par
\u8203? \tab\};\par
\par
That\rquote s all there is to it. You\rquote ll dive deep into where and how to use arrow functions later. For now, look at how normal functions translate to regular functions. To keep it quick, you\rquote ll get a rule, then a named function version, then an arrow version. But please try and write it out before you look at the translation. This feature is supported right now in many browsers, so open up a Chrome console and try it out.\par
\par
That last example took one parameter, which means that you don\rquote t need the parameters. But if you have no parameters, you still need parentheses.\par
\par
Before:\par
loops/arrow/full.js\par
\u8203? \tab\u8203?function\u8203? key() \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?'abc123'\u8203?;\par
\u8203? \tab\}\par
\par
After:\par
loops/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? key = () => \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?'abc123'\u8203?;\par
\u8203? \tab\};\par
\par
If you have more than one parameter, you\rquote ll also need to use parentheses\par
\par
Before:\par
loops/arrow/full.js\par
\u8203? \tab\u8203?function\u8203? greet(first, last) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Oh, hi \u8203?$\{capitalize(first)\}\u8203? \u8203?$\{capitalize(last)\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
After:\par
loops/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? greet = (first, last) => \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Oh, hi \u8203?$\{capitalize(first)\}\u8203? \u8203?$\{capitalize(last)\}\u8203?`\u8203?;\par
\u8203? \tab\};\par
\par
When the body of your function (the part normally inside the curly braces) is only one line, you can move everything\emdash the fat arrow, the parameters, the return statement\emdash to a single line.\par
\par
And if the function itself is only one line, you don\rquote t even need to use the return keyword. In other words, you return the result of the function body line automatically.\par
\par
Before:\par
loops/arrow/full.js\par
\u8203? \tab\u8203?function\u8203? formatUser(name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{capitalize(name)\}\u8203? is logged in.`\u8203?;\par
\u8203? \tab\}\par
\par
After:\par
loops/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? formatUser = name => \u8203?`\u8203?$\{capitalize(name)\}\u8203? is logged in.`\u8203?;\par
\par
Finally, you can use arrow functions as anonymous functions without needing to assign them to variables. This is how you\rquote ll be using it the most in the upcoming tips, so it\rquote s worth a look on its own.\par
\par
In JavaScript, you can pass a function as an argument to another function. Functions are just another form of data. Passing a function as an argument is very common for functions that take a callback, a function that will be executed at the end of the logic of the original function.\par
\par
Here you have a simple function that will apply a custom greeting. You\rquote re passing in a function to return a custom greeting as a callback. This is sometimes called injecting a function.\par
loops/arrow/full.js\par
\u8203? \tab\u8203?function\u8203? applyCustomGreeting(name, callback) \{\par
\u8203? \tab   \u8203?return\u8203? callback(capitalize(name));\par
\u8203? \tab\}\par
\par
It\rquote s perfectly okay to create a named function and pass that in. But often, it\rquote s just more convenient to create an anonymous function when you call the original function. In other words, you can call the function applyCustomGreeting() and pass in an anonymous function that you write on the spot. You never assign it to a variable first.\par
loops/arrow/full.js\par
\u8203? \tab applyCustomGreeting(\u8203?'mark'\u8203?, \u8203?function\u8203? (name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Oh, hi \u8203?$\{name\}\u8203?!`\u8203?;\par
\u8203? \tab\});\par
\par
What do you have here? You have a simple anonymous function that takes a single parameter with a body that\rquote s a single line long, and that single line is just a return statement. This is exactly the situation where arrow functions excel. That anonymous function has so much of that extra fluff you don\rquote t need.\par
\par
Now that you have the tools, try rewriting the anonymous function as an arrow function. You\rquote ll get something like this:\par
loops/arrow/arrow.js\par
\u8203? \tab applyCustomGreeting(\u8203?'mark'\u8203?, name => \u8203?`Oh, hi \u8203?$\{name\}\u8203?!`\u8203?);\par
\par
I hope you like the look of that because you\rquote re about to see a lot more of that kind of function as you work through array methods. Array methods and arrow functions are convenient ways to update a collection of data.\par
\par
In the next tip, you\rquote ll learn why array methods prevent a lot of mutations and extraneous variables. You\rquote ll start to see why they\rquote ve become so popular in JavaScript. \par
\par
Tip 21\tab Write Shorter Loops with Array Methods\par
\par
In this tip, you\rquote ll learn to reduce long loops to single lines with array methods.\par
\par
Before we begin, I want you to know that for loops and for...of loops are good. You\rquote ll want to use them, and you should use them. They\rquote re never going away.\par
\par
But you should use them less. Why? Well, the reason is simple: They\rquote re unnecessary clutter. You\rquote re writing modern JavaScript, which means you\rquote re going for simplicity, readability, and predictability, and traditional loops don\rquote t meet those goals. Array methods do. Mastering array methods is the fastest way to improve your JavaScript code.\par
\par
Look at this basic loop that converts an array of price strings into floating point values.\par
loops/methods/problem.js\par
\u8203? \tab\u8203?const\u8203? prices = [\u8203?'1.0'\u8203?, \u8203?'2.15'\u8203?];\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? formattedPrices = [];\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < prices.length; i++) \{\par
\u8203? \tab   formattedPrices.push(parseFloat(prices[i]));\par
\u8203? \tab\}\par
\par
It\rquote s short, sure. The whole thing takes four lines. Not bad. But consider a file that has five functions. And each function has a loop. You just added 20 lines to the file.\par
\par
And this function is pretty short to begin with. What if you had an array that contained some non-numerical strings and you wanted only parsable numbers? Your function starts to grow.\par
loops/methods/problem.js\par
\u8203?1: \tab\u8203?const\u8203? prices = [\u8203?'1.0'\u8203?, \u8203?'negotiable'\u8203?, \u8203?'2.15'\u8203?];\par
\u8203?2: \tab\par
\u8203?3: \tab\u8203?const\u8203? formattedPrices = []; \par
\u8203?4: \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < prices.length; i++) \{ \par
\u8203?5: \tab   \u8203?const\u8203? price = parseFloat(prices[i]);\par
\u8203?6: \tab   \u8203?if\u8203? (price) \{ \par
\u8203?7: \tab     formattedPrices.push(price);\par
\u8203?8: \tab   \}\par
\u8203?9: \tab\}\par
\par
Clutter. Clutter. Clutter. Just look at all the extra stuff you need just to get the float prices. On line 3, you declare a new collection before you even begin working with the data. And before you even enter the for loop, you\rquote re facing a paradox. Because let is block scoped, you have to declare the collection outside of the loop. Now you have an extraneous array with no members sitting outside the loop.\par
\par
Next, you have to follow the crazy three-part pattern to declare the iterator on line 4. You can often get around that with a for...of loop, but many times, you still need to declare the iterator.\par
\par
And finally, you\rquote re mixing two different concerns: transforming the value and filtering out bad values with your conditional on line 6. This isn\rquote t a horrible problem, but it does hurt predictability. Is the code standardizing the values in the array or is it filtering out unwanted values? In this case, it does both.\par
\par
Is it simple? No. It takes multiple lines and several variable declarations.\par
\par
Is it readable? Sure. But as the number of lines grows, the file decreases in readability.\par
\par
Is it predictable? No. It creates an empty array that may or may not be changed later because it\rquote s not a constant (and yes, you can push to a variable defined with const, but that\rquote s a no-no). Besides, we can\rquote t predict at a glance if formattedPrices will include everything. In this case, it won\rquote t. In the first case, it will. There\rquote s no clue inherent in the action.\par
\par
Array methods are a great way to get clean predictable code with no extraneous data. Some find them intimidating, but with a little effort, you\rquote ll master them quickly and find your code better than ever.\par
\par
The most popular array methods change either the size array or the shape of the data in the array. There\rquote s one big exception: the reduce() method. But you\rquote ll get to that soon enough.\par
\par
What does size and shape even mean? Look at a simple array of members of a digital marketing team.\par
\u8203? \tab\u8203?const\u8203? team = [\par
\u8203? \tab     \{\par
\u8203? \tab         name: \u8203?'melinda'\u8203?,\par
\u8203? \tab         position: \u8203?'ux designer'\u8203?\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab         name: \u8203?'katie'\u8203?,\par
\u8203? \tab         position: \u8203?'strategist'\u8203?\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab         name: \u8203?'madhavi'\u8203?,\par
\u8203? \tab         position: \u8203?'developer'\u8203?\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab         name: \u8203?'justin'\u8203?,\par
\u8203? \tab         position: \u8203?'manager'\u8203?\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab         name: \u8203?'chris'\u8203?,\par
\u8203? \tab         position: \u8203?'developer'\u8203?\par
\u8203? \tab     \}\par
\u8203? \tab ]\par
\par
At a glance, you can clearly see that this array has a size of five objects. You can also see that every item has a shape: a name and a position.\par
\par
Nearly any array method you choose will alter either the size or the shape of the return array. You simply need to decide if you want to change the size or the shape (or both).\par
\par
Do you want to change the size by reducing the number of members in the array by removing them? Do you want to change the shape by only getting the names of the team members? Do you want to do both and get the names of just the developers?\par
\par
You\rquote ll explore all these in upcoming tips, but here\rquote s a cheat sheet:\par
\par
    map()\par
        Action: Changes the shape, but not the size.\par
        Example: Get the name of everyone on the team.\par
        Result: [\rquote melinda\rquote , \rquote katie\rquote , \rquote madhavi\rquote , \rquote justin\rquote , \rquote chris\rquote ]\par
         \par
    sort()\par
        Action: Changes neither the size nor the shape, but changes the order.\par
        Example: Get the team members in alphabetical order.\par
        Result: [\{name: \rquote chris\rquote , position: \rquote developer\rquote\}, \{name: \rquote justin\rquote  ...\}]\par
         \par
    filter()\par
        Action: Changes the size, but not the shape.\par
        Example: Get the developers.\par
        Result: [\{name: \rquote madhavi\rquote , position: \rquote developer\rquote\}, \{name: \rquote chris\rquote , position:\rquote developer\rquote\}]\par
         \par
    find()\par
        Action: Changes the size to exactly one, but not the shape. Does not return an array.\par
        Example: Get the manager.\par
        Result: \{name: \rquote justin\rquote , position: \rquote manager\rquote\}\par
         \par
    forEach()\par
        Action: Uses the shape, but returns nothing.\par
        Example: Give all members a bonus!\par
        Result: Melinda gets a bonus! Katie get a bonus!\'85 (but no return value).\par
         \par
    reduce()\par
        Action: Changes the size and the shape to pretty much anything you want.\par
        Example: Get the total developers and non-developers.\par
        Result: \{developers: 2, non-developers: 3\}\par
         \par
\par
Now that you can see all the options ahead, I\rquote m sure you\rquote re excited to get started. Well, you don\rquote t have to wait any longer! Here\rquote s how you can rewrite the for loop using an array method.\par
loops/methods/methods.js\par
\u8203? \tab\u8203?const\u8203? prices = [\u8203?'1.0'\u8203?, \u8203?'2.15'\u8203?];\par
\u8203? \tab\u8203?const\u8203? formattedPrices = prices.map(price => parseFloat(price));\par
\u8203? \tab\u8203?// [1.0, 2.15];\u8203?\par
\par
Try evaluating the code using the usual criteria: simple, readable, predictable.\par
\par
Is it simple? Yes. Everything fits on a single line.\par
\par
Is it readable? Yes. You can see the action on one line. As the file grows, the number of lines won\rquote t grow any faster than the number of simple actions.\par
\par
Is it predictable? Yes. The value is assigned with const so you know it won\rquote t change. And because you used a map, you know that you\rquote ll have an array of exactly the same size. At a glance, you can tell that the goal is to get the float values with parseFloat(). So you also know that the array will be the exact size as the original with only float values.\par
\par
I know what you\rquote re going to say: You may have solved the simple loop, but what about the more complicated loop that removes false values?\par
\par
Fortunately, array methods can be chained. That means you can call one right after the other and it will pass the result down to the next item.\par
loops/methods/methods.js\par
\u8203? \tab\u8203?const\u8203? prices = [\u8203?'1.0'\u8203?, \u8203?'negotiable'\u8203?, \u8203?'2.15'\u8203?];\par
\u8203? \tab\u8203?const\u8203? formattedPrices = prices.map(price => parseFloat(price))\par
\u8203? \tab\u8203?// [1.0, NaN, 2.15]\u8203?\par
\u8203? \tab   .filter(price => price);\par
\u8203? \tab\u8203?// [1.0, 2.15]\u8203?\par
\par
First you convert values to floating point while keeping the array the same size. Then you change the size, but not shape, by pulling out false values.\par
\par
The process is much easier to follow, and because you can chain them together, you can still assign the resulting array with const.\par
\par
Do I have your interest now? Awesome. Because it\rquote s time to dive into writing your own array methods. You\rquote ll find you\rquote ll use the same methods over and over. But remember\emdash they each have their strengths. If you become frustrated trying to fit an action into a method, try using a different method or think about how you can break the action into pieces and chain it together.\par
\par
Now that you have the foundation, it\rquote s time to jump in. In the next tip, you\rquote ll start changing the shape of members of an array with map().\par
\par
Tip 22\tab Create Arrays of a Similar Size with map()\par
\par
In this tip, you\rquote ll learn how to pull out a subset of information from an array using map().\par
\par
In the previous tip, you saw how you could rewrite a simple for loop with an array method. Now you\rquote re going to start exploring how to use specific array methods.\par
\par
You\rquote ll begin with map() (not to be confused with the Map object). It\rquote s fairly common, and your new array receives the information you return in a brand new array. In other words, the return value is transparent, which isn\rquote t the case with other array methods. Here\rquote s another good reason to start with map(): the name \ldblquote map\rdblquote  isn\rquote t very expressive. What does that even mean? When I first learned it, I needed a fair amount of experience before I could see and understand a map function at a glance.\par
\par
Your goal is to get an idea of how most array methods work. And your secondary goal is to gain enough experience with map() that you\rquote ll start to see why it\rquote s one of the most popular methods.\par
\par
Start with a simple map function. A map function takes a piece of information from an input array and returns something new. Sometimes it returns part of the information. Other times, it transforms the information and returns the new value. That means it can take a single property from an array, or it can take a value in an array and return an altered version. For example, it can return an array with all the values capitalized or converted from integers to currency.\par
\par
The easiest example is pulling specific information from an object. Let\rquote s start with a collection of musicians.\par
loops/map/map.js\par
\u8203? \tab\u8203?const\u8203? band = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'corbett'\u8203?,\par
\u8203? \tab     instrument: \u8203?'guitar'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'evan'\u8203?,\par
\u8203? \tab     instrument: \u8203?'guitar'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'sean'\u8203?,\par
\u8203? \tab     instrument: \u8203?'bass'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'brett'\u8203?,\par
\u8203? \tab     instrument: \u8203?'drums'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
You have the band, but what you really want is just a list of instruments the band members play.\par
\par
Every array method takes a callback function that you\rquote ll apply to each member of the array. These functions are very simple by design. They can only take one argument: the individual member of an array (the reduce() method is an exception that we\rquote ll discuss later).\par
\par
Before you dive into building a map function, create a basic for loop to use as a comparison. Once you have that loop, you\rquote ll start slowly refactoring it until you get to a working map function. This will help you gain an understanding for how a map() function is just a simplified loop.\par
\par
Okay, here\rquote s a simple for loop to get the band instruments:\par
loops/map/full.js\par
\u8203?1: \tab\u8203?const\u8203? instruments = [];\par
\u8203?2: \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < band.length; i++) \{\par
\u8203?3: \tab   \u8203?const\u8203? instrument = band[i].instrument; \par
\u8203?4: \tab   instruments.push(instrument); \par
\u8203?5: \tab\}\par
\par
Now it\rquote s time to start refactoring. The first thing to do is to combine line 3 and line 4. Instead of getting the instrument and passing it to the push method, you\rquote ll get the instrument as part of the argument for push(). To keep things readable, put the logic to retrieve the instrument into a separate function.\par
\par
You\rquote ll get a function that looks like this:\par
loops/map/full.js\par
\u8203? \tab\u8203?function\u8203? getInstrument(member) \{\par
\u8203? \tab   \u8203?return\u8203? member.instrument;\par
\u8203? \tab\}\par
\par
Sure it doesn\rquote t shorten things up much, but it helps. And more important, you\rquote ve made a huge step by separating the iterator band[i] and the information you want from the individual member: member.instrument. Remember that with map() methods, you want to think about the individual pieces, not the whole array.\par
\par
Here\rquote s how your new method fits into the current for loop:\par
loops/map/full.js\par
\u8203? \tab\u8203?const\u8203? instruments = [];\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < band.length; i++) \{\par
\u8203? \tab   instruments.push(getInstrument(band[i]));\par
\u8203? \tab\}\par
\par
At this point, you\rquote ve pretty much written your map function.\par
\par
With map(), there\rquote s no need to set up a return array\emdash that\rquote s included as part of the array method. There\rquote s also no need to push information. map() pushes the result of the function into its own return array.\par
\par
The only thing you need for map() is a function that takes each item as an argument and returns something to put in the return array. What do you know\emdash you already have that written out!\par
\par
Most of the time, you\rquote ll just write an anonymous function for an array method, but that\rquote s not a requirement. You can name a function if you want (and sometimes that\rquote s a smart move for testing purposes). That means you can reuse the getInstrument() function you already have and pass it directly to map(). At this point, you can abandon your for loop.\par
loops/map/map.js\par
\u8203? \tab\u8203?function\u8203? getInstrument(member) \{\par
\u8203? \tab   \u8203?return\u8203? member.instrument;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? instruments = band.map(getInstrument);\par
\u8203? \tab\u8203?// ['guitar', 'guitar', 'bass', 'drums']\u8203?\par
\par
Look at what you\rquote ve accomplished. You removed excess code while keeping things more transparent:\par
\par
    You know you\rquote re going to get an array. You don\rquote t need to define one ahead of time.\par
\par
    You know it will be the same size as the original array.\par
\par
    You know it will contain the instruments and nothing else.\par
\par
Predictable and simple.\par
\par
If you understand this, congratulations\emdash you understand most array methods. All array methods are just methods that take a callback that act on each member of an array. The type of array method determines what happens with the return value of that function. But writing the function itself is very similar for each array method.\par
\par
Now that you\rquote ve refactored your for loop to a map method, you can take the next step and convert the named function to an anonymous function. Remember those arrow functions you just learned? Now is a perfect time to use them.\par
\par
You\rquote re taking a single argument, so you don\rquote t need parentheses. And the body of the function is only one line long, so you don\rquote t need curly braces or a return statement. Go ahead and try writing it out. These functions become much easier with practice.\par
loops/map/map.js\par
\u8203? \tab\u8203?const\u8203? instruments = band.map(member => member.instrument);\par
\u8203? \tab\u8203?// ['guitar', 'guitar', 'bass', 'drums']\u8203?\par
\par
map() is fairly simple, but it\rquote s flexible. You can use it for anything\emdash yes, anything\emdash when the goal is to have an array of the same size. Up to now, you\rquote ve only been elevating data from an array of objects. But you can also transform information, as you saw when you converted strings to values with parseInt() in the previous tip.\par
\par
In the next tip, you\rquote ll see an array method that does something a little different. You\rquote ll maintain the shape of the array items, but you\rquote ll return only a subset by performing a true or false check on each item. \par
\par
Tip 23\tab Pull Out Subsets of Data with filter() and find()\par
\par
In this tip, you\rquote ll learn how to change the size of an array while retaining the shape of the items.\par
\par
In the previous tip, you created a new array by pulling out only the relevant information from the original array. You\rquote ll likely encounter situations where you want to keep the shape of the data, but you only want a subset of the total items. Maybe you only want users that live in a certain city, but you still need all their information. The array method filter() will perform this exact action. Unlike the map() method, you aren\rquote t changing any information in the array\emdash you\rquote re just reducing what you get back.\par
\par
As an example, let\rquote s filter a simple array of strings. You have a team of people, and you want only people named some form of Dave (David, Davis, Davina, and so on). In my hometown, there\rquote s a sandwich shop that gives out a free sandwich once a year to anyone named Joe/Joseph/Joanna, so being able to filter people by name variant is a crucial task. You wouldn\rquote t want to deprive your Daves or Joes of a delicious lunch.\par
\par
Start with a list of coworkers that you want to reduce down.\par
loops/filter/full.js\par
\u8203? \tab\u8203?const\u8203? team = [\par
\u8203? \tab   \u8203?'Michelle B'\u8203?,\par
\u8203? \tab   \u8203?'Dave L'\u8203?,\par
\u8203? \tab   \u8203?'Dave C'\u8203?,\par
\u8203? \tab   \u8203?'Courtney B'\u8203?,\par
\u8203? \tab   \u8203?'Davina M'\u8203?,\par
\u8203? \tab ];\par
\par
You\rquote ll need to check to see if the string contains a form of \ldblquote Dav\rdblquote  using the match() method on a string. This method will return an array of information if the string matches a regular expression matches and null if there\rquote s no match. In other words, match() will return a truthy value, an array, if there\rquote s a regex match and a falsy value, null, if there is none.\par
\u8203? \tab\u8203?'Dave'\u8203?.match(\u8203?/Dav/\u8203?);\par
\u8203? \tab\u8203?// ['Dav', index: 0, input: 'Dave']\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?'Michelle'\u8203?.match(\u8203?/Dav/\u8203?);\par
\u8203? \tab\u8203?// null\u8203?\par
\par
Traditionally, you\rquote d solve the problem with a for loop. And as you\rquote ve probably guessed by now, the solution isn\rquote t pretty.\par
loops/filter/full.js\par
\u8203? \tab\u8203?const\u8203? daves = [];\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < team.length; i++) \{\par
\u8203? \tab   \u8203?if\u8203? (team[i].match(\u8203?/Dav/\u8203?)) \{\par
\u8203? \tab     daves.push(team[i]);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
A filter function can do the exact same thing in a single line. Like the map() method, you call the method on an array and you get an array back.\par
\par
There\rquote s one trick. Unlike the map() method, the function you pass into the filter() method must return a truthy value. When you iterate over each item, if it returns something truthy, it\rquote s retained. If it doesn\rquote t return a truthy value, it isn\rquote t retained. See why it\rquote s important to have a solid grasp of truthiness (the programmer kind, not the Colbert kind). Say you want to get the passing scores from an array. The filter function would take each score and say whether it was above the threshold (60) and keeps it if it is.\par
loops/filter/filter.js\par
\u8203? \tab\u8203?const\u8203? scores = [30, 82, 70, 45];\par
\u8203? \tab\u8203?function\u8203? getNumberOfPassingScores(scores) \{\par
\u8203? \tab   \u8203?const\u8203? passing = scores.filter(score => score > 59);\par
\u8203? \tab   \u8203?// [70, 82]\u8203?\par
\u8203? \tab   \u8203?return\u8203? passing.length;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// 2\u8203?\par
\par
The function returns either true or false, but the final array contains the actual values of 82 and 70. The function checked each score one at a time, retaining the score (not the return value) if the return value was true. Note also, the return array preserves the order of the original.\par
\par
Most important, filter() will always return an array, even if nothing matches the values. If you wanted to see how many perfect scores you\rquote d get, you may be a little disappointed. But you can still confidently call the length property knowing you\rquote ll have an array of some sort. Simple and predictable.\par
loops/filter/filter.js\par
\u8203? \tab\u8203?function\u8203? getPerfectScores(scores) \{\par
\u8203? \tab   \u8203?const\u8203? perfect = scores.filter(score => score === 100);\par
\u8203? \tab   \u8203?// []\u8203?\par
\u8203? \tab   \u8203?return\u8203? perfect.length;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?// 0\u8203?\par
\par
To return to your hungry Daves: In the previous anonymous functions you pass to filter(), you\rquote re returning a Boolean\emdash true or false\emdash while in this one, you want to check a string. Because match() returns truthy and falsy values, you can use it directly in the filter function.\par
\par
Here\rquote s your simplified loop:\par
loops/filter/filter.js\par
\u8203? \tab\u8203?const\u8203? daves = team.filter(member => member.match(\u8203?/Dav/\u8203?));\par
\par
Filter is so easy to use that there\rquote s not much left to say. Still, there\rquote s one variation that can be very useful.\par
\par
On occasion, you might be lucky enough to know that there will be at most one match (or you\rquote re only interested in one match) in your array. In that case, you can use a method that\rquote s similar to filter() called find(). The find() method takes a function as argument, a function that returns a truthy or falsy value, and returns only the first result that evaluates to true. If there\rquote s no true value, it returns undefined.\par
\par
This is great when you know there will only be one value\emdash looking for an entry with a specific ID, for example. Or if you want the first instance of a particular item\emdash getting the last update to a page by a particular user on a sorted array.\par
\par
Here\rquote s a good way to think about this: If you\rquote d normally use a break statement in a loop, the action is a good candidate for find().\par
\par
Let\rquote s say you\rquote re writing a scheduling app for library instructors. Each instructor works in several locations, but no location has more than one instructor.\par
\par
Your array of instructors would look like this:\par
loops/filter/full.js\par
\u8203? \tab\u8203?const\u8203? instructors = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Jim'\u8203?,\par
\u8203? \tab     libraries: [\u8203?'MERIT'\u8203?],\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Sarah'\u8203?,\par
\u8203? \tab     libraries: [\u8203?'Memorial'\u8203?, \u8203?'SLIS'\u8203?],\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Eliot'\u8203?,\par
\u8203? \tab     libraries: [\u8203?'College Library'\u8203?],\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
If you were to write a for loop to check it, you\rquote d go through each one and break when you get to the correct result.\par
loops/filter/full.js\par
\u8203? \tab\u8203?let\u8203? memorialInstructor;\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < instructors.length; i++) \{\par
\u8203? \tab   \u8203?if\u8203? (instructors[i].libraries.includes(\u8203?'Memorial'\u8203?)) \{\par
\u8203? \tab     memorialInstructor = instructors[i];\par
\u8203? \tab     \u8203?break\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
This loop will check the first instructor and see that he doesn\rquote t meet the criteria. The second instructor does meet the criteria, saving the incredible labor of looking at the third instructor. Of course, in real-world data, there may be hundreds or even thousands of results. Stopping at the first instance is a nice little optimization to avoid iterating over the whole set.\par
\par
How does this translate into a find() function? It\rquote s simple: The if block contains everything you need to change this into a find() function. Using the ideas from filter(), try to write it out.\par
\par
You probably came up with something like this:\par
loops/filter/filter.js\par
\u8203? \tab\u8203?const\u8203? librarian = instructors.find(instructor => \{\par
\u8203? \tab   \u8203?return\u8203? instructor.libraries.includes(\u8203?'Memorial'\u8203?);\par
\u8203? \tab\});\par
\par
Once again, you\rquote ve reduced several lines down to a simple expression (could be a one-liner, but it runs off the printed page!) while simultaneously removing an unstable let with a predictable const. The only down-side to using find() is that you can\rquote t be absolutely sure of the return value. If there\rquote s no match, you get undefined, while with filter() you\rquote d get an empty array if there were no matches. But using your knowledge of short circuiting, you can always add an or statement combined with a default.\par
\u8203? \tab\u8203?const\u8203? image = [\par
\u8203? \tab     \{\par
\u8203? \tab         path: \u8203?'./me.jpg'\u8203?,\par
\u8203? \tab         profile:\u8203?false\u8203?\par
\u8203? \tab     \}\par
\u8203? \tab ];\par
\u8203? \tab\u8203?const\u8203? profile = images.find(image => image.profile) || \{path:\par
\u8203? \tab\u8203?'./default.jpg'\u8203?\};\par
\par
There may be one thing bothering you about that find() function: You had to hard code the name of the library, Memorial. The challenge with an array function is that it takes a single argument, the item being checked. This is a problem if you want to add a second parameter, a variable to check the item against.\par
\par
What do you do if you want to check against another location? Fortunately, you don\rquote t need to write a function for every library. Rather, you\rquote d use a technique called currying to reduce the number of arguments down to one. You\rquote ll see this a lot more in Tip 34, \u8203? Maintain Single Responsibility Parameters with Partially Applied Functions \u8203?, but it\rquote s one of my favorite techniques, so I\rquote ll go ahead and give you a taste.\par
loops/filter/filter.js\par
\u8203? \tab\u8203?const\u8203? findByLibrary = library => instructor => \{\par
\u8203? \tab   \u8203?return\u8203? instructor.libraries.includes(library);\par
\u8203? \tab\};\par
\u8203? \tab\u8203?const\u8203? librarian = instructors.find(findByLibrary(\u8203?'MERIT'\u8203?));\par
\u8203? \tab\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   name: 'Jim',\u8203?\par
\u8203? \tab\u8203?//   libraries: ['MERIT'],\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
But don\rquote t get too far ahead. There are more array methods to explore.\par
\par
In the next tip, you\rquote ll break the pattern of returning a new array by using forEach() to perform an action on each array without getting any return values. \par
\par
Tip 24\tab Apply Consistent Actions with forEach()\par
\par
In this tip, you\rquote ll learn how to apply an action to each member of an array with forEach().\par
\par
Things are going to get a little different in this tip. The two array methods you\rquote ve explored so far return a new, altered array. You either changed the shape by pulling out a subset of information on each item, or you changed the size by returning only part of the total number of items.\par
\par
In this tip, you aren\rquote t changing the input array at all. Instead, you\rquote re going to perform an action on every member. This is common when you finally get an array to the size and shape you want and then you want to do something with that data.\par
\par
As an example, say you have a club with a group of members and you want to write a script to send an invitation to every club member when the next meeting is scheduled. You want a function that takes each member individually so that you can use other information\emdash name, email, and so on\emdash to customize the message.\par
\par
Here\rquote s a list of members:\par
loops/forEach/forEach.js\par
\u8203? \tab\u8203?const\u8203? sailingClub = [\par
\u8203? \tab   \u8203?'yi hong'\u8203?,\par
\u8203? \tab   \u8203?'andy'\u8203?,\par
\u8203? \tab   \u8203?'darcy'\u8203?,\par
\u8203? \tab   \u8203?'jessi'\u8203?,\par
\u8203? \tab   \u8203?'alex'\u8203?,\par
\u8203? \tab   \u8203?'nathan'\u8203?,\par
\u8203? \tab ];\par
\par
Don\rquote t worry about the implementation details of the email function. All you need to know is that it takes a member object. As always, you could easily achieve your goal with a simple for loop.\par
loops/forEach/full.js\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < sailingClub.length; i++) \{\par
\u8203? \tab   sendEmail(sailingClub[i]);\par
\u8203? \tab\}\par
\par
You really can\rquote t get much simpler than that. Unlike other methods, forEach() isn\rquote t valuable because it makes your code simpler. It\rquote s valuable because it\rquote s predictable and because it works like other array methods so it can be chained together (you\rquote ll see more about that in the next tip) with other methods.\par
\par
The forEach() method, like all you\rquote ve seen before, takes a function that takes a single argument: the individual member of the array. Unlike the other methods, the return statement (whether explicitly or implicitly defined) does absolutely nothing. Any action you take must affect something outside the function. Changing something outside the scope of the function is called a side effect, and though it\rquote s not horrible, it should be exercised with caution.\par
\par
In other words, if you use forEach() to transform some names to uppercase, you\rquote d get no results. This method does nothing unless you have a side effect of some sort. (By the way, this is why you should always test your code.) This code would effectively do nothing:\par
loops/forEach/forEach.js\par
\u8203? \tab\u8203?const\u8203? names = [\u8203?'walter'\u8203?, \u8203?'white'\u8203?];\par
\u8203? \tab\u8203?const\u8203? capitalized = names.forEach(name => name.toUpperCase());\par
\u8203? \tab\par
\u8203? \tab capitalized;\par
\u8203? \tab\u8203?// undefined\u8203?\par
\par
You could have a container array to collect the change result, but by now, you know that\rquote s bad because it mutates the capitalized array. Besides, that isn\rquote t even necessary because map() does the same thing.\par
loops/forEach/forEach.js\par
\u8203? \tab\u8203?const\u8203? names = [\u8203?'walter'\u8203?, \u8203?'white'\u8203?];\par
\u8203? \tab\u8203?let\u8203? capitalized = [];\par
\u8203? \tab names.forEach(name => capitalized.push(name.toUpperCase()));\par
\u8203? \tab\par
\u8203? \tab capitalized;\par
\u8203? \tab\u8203?// ['WALTER', 'WHITE'];\u8203?\par
\par
So when should you use forEach()? The best time is precisely when you want to perform an action outside the scope of the function. In other words, when you know you must cause a side effect, you should use forEach().\par
\par
As it happens, that\rquote s exactly what you\rquote re doing when you send an invitation. You\rquote re causing a side effect\emdash sending an email\emdash but you aren\rquote t mutating any data (you assume).\par
\par
Here\rquote s the updated action:\par
loops/forEach/forEach.js\par
\u8203? \tab sailingClub.forEach(member => sendEmail(member));\par
\par
Three lines down to one line isn\rquote t bad, but it\rquote s certainly no cause for celebration.\par
\par
So what\rquote s the point? The point is that you do get some predictability. When you see a forEach(), you know there\rquote s going to be a side effect. And as you learned in Tip 1, \u8203? Signal Unchanging Values with const \u8203?, if you can\rquote t be certain of something, the next best option is knowing that there might be instability.\par
\par
Even with that, the best reason to keep forEach() in your toolbox is that you can combine it with other array methods in a process called chaining. That means that you can perform multiple actions on the same array without needing to save the output to variables each time.\par
\par
In the next tip, you\rquote ll use chaining to combine several actions into one process.\par
\par
Tip 25\tab Combine Methods with Chaining\par
\par
In this tip, you\rquote ll learn to perform multiple array methods with chaining.\par
\par
Chaining is an old concept in programming. You can find it in many object-oriented languages.[20] Like a lot of programming concepts, it actually sounds more complicated than it is in practice.\par
\par
Here\rquote s a quick definition: Chaining is immediately calling a method on a returned object (which in some cases is the original object) without reassigning the value first.\par
\par
Okay, now forget that definition. For our purposes, chaining means that you can call several array methods in a row (as long as you get an array back). It\rquote s a convenient way to perform several actions in a very clear manner.\par
\par
Think back to the last example: sending notifications to club members. The example was simplified (as examples always are). An actual array of club members would have a lot more data. It would have member status, email addresses, mailing addresses, position, and so on.\par
\par
To keep things simple, let\rquote s add just two fields: active and email.\par
loops/chain/chain.js\par
\u8203? \tab\u8203?const\u8203? sailors = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'yi hong'\u8203?,\par
\u8203? \tab     active: \u8203?true\u8203?,\par
\u8203? \tab     email: \u8203?'yh@yhproductions.io'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'alex'\u8203?,\par
\u8203? \tab     active: \u8203?true\u8203?,\par
\u8203? \tab     email: \u8203?''\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'nathan'\u8203?,\par
\u8203? \tab     active: \u8203?false\u8203?,\par
\u8203? \tab     email: \u8203?''\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
There\rquote s not much more information, but you have enough that you can be more sophisticated about whom you email. First, you can filter out all the inactive members\emdash they won\rquote t want an invitation.\par
loops/chain/full.js\par
\u8203? \tab\u8203?const\u8203? active = sailors.filter(sailor => sailor.active);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'yi hong',\u8203?\par
\u8203? \tab\u8203?//     active: true,\u8203?\par
\u8203? \tab\u8203?//     email: 'yh@yhproductions.io',\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?//   \{\u8203?\par
\u8203? \tab\u8203?//     name: 'alex',\u8203?\par
\u8203? \tab\u8203?//     active: true,\u8203?\par
\u8203? \tab\u8203?//     email: '',\u8203?\par
\u8203? \tab\u8203?//   \},\u8203?\par
\u8203? \tab\u8203?// ];\u8203?\par
\par
Next, you can normalize the email addresses. If members have an email set, use that. Otherwise, use their default club email address.\par
loops/chain/full.js\par
\u8203? \tab\u8203?const\u8203? emails = active.map(member => member.email\par
\u8203? \tab                || \u8203?`\u8203?$\{member.name\}\u8203?@wiscsail.io`\u8203?);\par
\u8203? \tab\par
\u8203? \tab\u8203?// [ 'yh@yhproductions.io', 'alex@wiscsail.io' ]\u8203?\par
\par
Finally, after the inactive members are removed and the email addresses are normalized, you can call sendInvitation() with the correct member information.\par
loops/chain/full.js\par
\u8203? \tab emails.forEach(sailor => sendEmail(sailor));\par
\par
Notice that you assigned the result to a variable each time. With chaining, that\rquote s not necessary. Instead, you can remove the intermediate step of assigning to a variable by calling a method directly on the result.\par
\par
Because filter() always returns an array (even if it\rquote s an empty array), you know that you can call any other array method on it. Similarly, because map() always returns an array, you can call another array method on it. Crucially, though, the final method\emdash forEach()\emdash doesn\rquote t return an array, so you can\rquote t call another method. In fact, it returns nothing, so you can\rquote t even assign the output of the whole group of actions to a variable.\par
\par
Removing the intermediate steps, you get an identical set of actions without any variable declarations.\par
loops/chain/chain.js\par
\u8203? \tab sailors\par
\u8203? \tab   .filter(sailor => sailor.active)\par
\u8203? \tab   .map(sailor => sailor.email || \u8203?`\u8203?$\{sailor.name\}\u8203?@wiscsail.io`\u8203?)\par
\u8203? \tab   .forEach(sailor => sendEmail(sailor));\par
\par
Now you\rquote re sending an email to the preferred email address of only active members. The best part is that because each array method does one very specific thing, you can understand the code at a glance.\par
\par
The only downside to chaining array methods is that each time you call a new method, you\rquote re iterating over the whole returned array. Instead of three iterations\emdash one for each member\emdash if you performed all actions with a for loop, you\rquote re performing seven iterations (three on the original array plus two more when mapping plus two more when calling forEach()). Don\rquote t pay too much attention to this. It\rquote s not terribly important unless you\rquote re working with large data sets. Sometimes the minor performance increase is worth extra readability. Sometimes it\rquote s not. It\rquote s just something to keep in mind.\par
\par
There are a few tricks to chaining methods: First, notice how there are no semicolons until the final statement. The whole action is like a sentence. It\rquote s not over until you hit the period, even when it spans multiple lines.\par
\par
This is one reason that many style guides still prefer semicolons even though they aren\rquote t strictly necessary in JavaScript. If you mess up and include a semicolon earlier, you\rquote ll get a SyntaxError so it\rquote s unlikely you\rquote ll get too far with that mistake.\par
\par
More important, order does matter. You couldn\rquote t, for example, flip the filter() and the map() methods because the map() method would remove the property the filter() method would need to check. With this example at least, that would be very bad. You wouldn\rquote t get an error because sailor.active would return undefined for everything. The resulting array would be empty, which isn\rquote t an error. In other words, syntactically, everything makes sense even if you provide an empty array to forEach().\par
\par
This is why it always pays to have a test. Check out the test suite for this book to see examples.[21]\par
\par
Chaining isn\rquote t limited to array methods, but because arrays have so many methods that return arrays, they\rquote re very convenient examples to explore. You\rquote ll see more chaining as you continue. It pops up again and again. You may remember seeing using it with the Map object in Tip 13, \u8203? Update Key-Value Data Clearly with Maps \u8203? when you chained multiple set() methods. And you\rquote ll see it again when you work with promises in Tip 43, \u8203? Retrieve Data Asynchronously with Promises \u8203?. It\rquote s a simple but important concept that\rquote s worth reviewing several times.\par
\par
In the next tip, you\rquote ll go back and look at one more array method, reduce(). It\rquote s the most flexible and interesting, but it\rquote s also the most unpredictable. \par
\par
Tip 26\tab Transform Array Data with reduce()\par
\par
In this tip, you\rquote ll learn how use reduce() to generate a new array with a different size and shape.\par
\par
You\rquote re probably tired of hearing me say that good code is predictable. But it\rquote s true. Array methods are wonderful because you have an idea of the result at a glance without even understanding the callback function. Not only that, but array methods are easier to test and, as you\rquote ll see in Tip 32, \u8203?Write Functions for Testability \u8203?, it\rquote s much easier to write testable code than it is to add tests to complex code.\par
\par
Still, there are times when you need to create a new, radically different piece of data from an array. Maybe you need to get a count of certain items. Maybe you want to transform the array to a different structure, such as an object. That\rquote s where reduce() comes in. The reduce() method is different from other array methods in several ways, but the most important is that it can change both the size and the shape of data (or just one or just the other). And it doesn\rquote t necessarily return an array.\par
\par
As usual, it\rquote s much easier to see than to explain. Here\rquote s a reduce function that returns the exact same array. It\rquote s useless, but it lets you see how a reduce() function is built.\par
loops/reduce/reduce.js\par
\u8203?1: \tab\u8203?const\u8203? callback = \u8203?function\u8203? (collectedValues, item) \{ \par
\u8203?2: \tab   \u8203?return\u8203? [...collectedValues, item];\par
\u8203?3: \tab\};\par
\u8203?4: \tab\par
\u8203?5: \tab\u8203?const\u8203? saying = [\u8203?'veni'\u8203?, \u8203?'vedi'\u8203?, \u8203?'veci'\u8203?];\par
\u8203?6: \tab\u8203?const\u8203? initialValue = [];\par
\u8203?7: \tab\u8203?const\u8203? copy = saying.reduce(callback, initialValue); \par
\par
What\rquote s going on here? To start, notice that you pass two arguments into the reduce() callback function on line 1: the return item (called collectedValues) and the individual item. The return value, sometimes called the carry, is what makes reduce() unique. It can range from an integer to a collection such as Set.\par
\par
The reduce() method itself on line 7 takes two values: the callback function and the initial value. Although the initial value is optional, it\rquote s usually included because you need something to hold the return values and, as a bonus, it gives other developers a clue about what they\rquote ll get back. The trickiest part of a reduce method is that the callback function must always return the carry item.\par
\par
It\rquote s really worth reading the documentation to see more examples, but many of those examples are abstract ideas using numbers.[22] Consider a situation that\rquote s much more common: getting the unique values from an array.\par
\par
You probably remember that this is a problem you already solved with Set in Tip 16, \u8203? Keep Unique Values with Set \u8203?. You\rquote re absolutely correct, but you\rquote re going to expand on the solution to get several sets of unique values.\par
\par
As in the previous example, you\rquote re going to get a list of unique values from a collection of dogs for an adoption website.\par
loops/reduce/reduce.js\par
\u8203? \tab\u8203?const\u8203? dogs = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'max'\u8203?,\par
\u8203? \tab     size: \u8203?'small'\u8203?,\par
\u8203? \tab     breed: \u8203?'boston terrier'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'don'\u8203?,\par
\u8203? \tab     size: \u8203?'large'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'shadow'\u8203?,\par
\u8203? \tab     size: \u8203?'medium'\u8203?,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     color: \u8203?'chocolate'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
If you want to see a few approaches using a for loop or Set directly, flip back to that earlier tip. For now, you\rquote ll jump right into getting the values with the reduce() method.\par
\par
If all you wanted was the set of unique colors, you\rquote d write a reduce method that loops through the objects checking the colors and saving the unique values.\par
loops/reduce/reduce.js\par
\u8203?1: \tab\u8203?const\u8203? colors = dogs.reduce((colors, dog) => \{ \par
\u8203?2: \tab   \u8203?if\u8203? (colors.includes(dog.color)) \{ \par
\u8203?3: \tab     \u8203?return\u8203? colors;\par
\u8203?4: \tab   \}\par
\u8203?5: \tab   \u8203?return\u8203? [...colors, dog.color]; \par
\u8203?6: \tab\}, []); \par
\par
When you see a reduce method, the best place to start is at the end so you can see what kind of item you\rquote ll end up with. Remember that it can be anything\emdash  a string, a Boolean, an object. Make no assumptions.\par
\par
If you look at line 6, you can see that you\rquote re initializing the function with an empty array.\par
\par
The next trick to grasping a reduce function is understanding what the name of that initial value is after it enters the function. Generically, it\rquote s often called a \ldblquote carry,\rdblquote  but you can name it whatever you want because it\rquote s just a parameter. In this function on line 1, you name it something a little more revealing: colors.\par
\par
Without going any further into the body of the function, you already know that you\rquote ll be getting back another array. That\rquote s valuable information, and it\rquote s the reason you should always start with an explicit carry value. You want the next developer to have as many clues as possible.\par
\par
You have to be careful, though, because if you forget to return the carry value, it will effectively disappear. If you were to run the following function, you\rquote d get a TypeError: Cannot read property \rquote includes\rquote  of undefined. When you forget to return the carry on line 5, the function will return undefined. This means the parameter colors is now undefined and doesn\rquote t have an includes() method.\par
loops/reduce/mistake.js\par
\u8203?1: \tab\u8203?const\u8203? colors = dogs.reduce((colors, dog) => \{\par
\u8203?2: \tab   \u8203?if\u8203? (colors.includes(dog.color)) \{\par
\u8203?3: \tab     \u8203?return\u8203? colors;\par
\u8203?4: \tab   \}\par
\u8203?5: \tab   [...colors, dog.color]; \par
\u8203?6: \tab\}, []);\par
\par
Moving in to the body of the initial unique colors function, you start to see the value of reduce() over other methods. On line 2, you check to see if the value is already in the array. If it is, no need to add it. Return the collection so far. If it\rquote s a new value, then you add it to the other colors on line 5 and return the updated array.\par
\par
Let that sink in a moment. You\rquote re doing two things: You\rquote re returning a subset of data (changing the size) and you\rquote re returning modified data (changing the shape). More important, you\rquote re changing the size based on information contained inside the array itself. That\rquote s not something you can do with filter() or find().\par
\par
Now here\rquote s the interesting part. Because you can change both the size and the shape of the data, you can recreate any other array method with reduce().\par
\par
As a quick example, if you wanted to just get the colors of the dogs, you could use the map() method like this:\par
loops/reduce/map.js\par
\u8203? \tab\u8203?const\u8203? colors = dogs.map(dog => dog.color);\par
\par
You could get the same value with a reduce function that takes an empty array to start and returns the array on every iteration.\par
loops/reduce/reduce.js\par
\u8203? \tab\u8203?const\u8203? colors = dogs.reduce((colors, dog) => \{\par
\u8203? \tab   \u8203?return\u8203? [...colors, dog.color];\par
\u8203? \tab\}, []);\par
\par
As an exercise, try writing filter() and find() with reduce(). You\rquote ll learn about each of them in the process.\par
\par
By no means should you rebuild methods in your code. Use the best tool for the job. Still, the fact that you can shows the power of reduce().\par
\par
But back to our unique value reducer. You may be wondering why you should bother with a reducer at all when you just pass the results of the map() method in to Set and get the same result?\par
\par
That\rquote s easy. Reducers give you the flexibility to handle more values with ease. And if you were getting the values for one set of properties, map() would make more sense. Remember that flexibility is good, but you should use it only when you\rquote ve exhausted simpler options. When you need it, though, it\rquote s good to have.\par
\par
For example, what if you wanted to get the unique values for all the keys in the dog object? You could run multiple map functions and pass those to Set. Or, you can use a reduce function that starts with empty sets and fills the objects in as you go.\par
\par
There are many ways to do this, but the easiest would be to start with an object that contains empty sets. In the body of the reduce function, add each item to the set (remember that it will keep only the unique items). When you\rquote re finished, you have a collection of unique properties.\par
loops/reduce/reduce.js\par
\u8203? \tab\u8203?const\u8203? filters = dogs.reduce((filters, item) => \{\par
\u8203? \tab   filters.breed.add(item.breed);\par
\u8203? \tab   filters.size.add(item.size);\par
\u8203? \tab   filters.color.add(item.color);\par
\u8203? \tab   \u8203?return\u8203? filters;\par
\u8203? \tab\},\par
\u8203? \tab\{\par
\u8203? \tab   breed: \u8203?new\u8203? Set(),\par
\u8203? \tab   size: \u8203?new\u8203? Set(),\par
\u8203? \tab   color: \u8203?new\u8203? Set(),\par
\u8203? \tab\});\par
\par
Now you have the benefit of keeping iterations low while also signaling the shape of the transformed data to other developers.\par
\par
And it\rquote s precisely because you can change the size and shape of data that the possibilities are nearly endless.\par
\par
Look at another example. In this case, you have a list of developers, and along with language specialty, you want a count by speciality.\par
loops/reduce/reduce.js\par
\u8203? \tab\u8203?const\u8203? developers = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Jeff'\u8203?,\par
\u8203? \tab     language: \u8203?'php'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Ashley'\u8203?,\par
\u8203? \tab     language: \u8203?'python'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Sara'\u8203?,\par
\u8203? \tab     language: \u8203?'python'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Joe'\u8203?,\par
\u8203? \tab     language: \u8203?'javascript'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
You could easily get a count by incrementing the language specialty on each iteration.\par
loops/reduce/reduce.js\par
\u8203? \tab\u8203?const\u8203? aggregated = developers.reduce((specialities, developer) => \{\par
\u8203? \tab   \u8203?const\u8203? count = specialities[developer.language] || 0;\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     ...specialities,\par
\u8203? \tab     [developer.language]: count + 1,\par
\u8203? \tab   \};\par
\u8203? \tab\}, \{\});\par
\par
Notice that the initial value is just an empty object. In this case, you don\rquote t know what languages are going to be used so you\rquote ll need to add them dynamically. In case you\rquote re wondering: Yes, you can build this reduce function with Map instead of an object. Try it out and see what you come up with.\par
\par
That\rquote s all for array methods. They provide a lot of value, and when you get comfortable with them, you\rquote ll appreciate how quickly you can reduce the lines of code while being even more transparent about the information you\rquote re returning. Don\rquote t be surprised that you turn to them more and more.\par
\par
Still, there are times when normal for loops are the way to go. In the next tip, you\rquote ll look at a slight variation to the for loop called a for...in loop that lets you ignore all the annoying declarations of iterators and length by taking each item directly from the iterable.\par
\par
\f0 Tip 27\tab Reduce Loop Clutter with for...in and for...each\par
\par
In this tip, you\rquote ll learn how to maintain clarity with loops over iterables using for...in and over objects using for...of.\par
\par
Hopefully by now you\rquote re convinced that array methods can handle most of your iterations in clear and predictable ways. Sometimes, however, an array method may be either inefficient or cumbersome.\par
\par
There may be times you want to exit out of a loop when a result doesn\rquote t match what you need. In those cases, it makes no sense to keep iterating over information.\par
\par
Alternatively, an array method may be overly complex when you\rquote re working with a collection that isn\rquote t an array. Remember that just because a structure isn\rquote t an array doesn\rquote t mean you can\rquote t use array methods. If you\rquote re working with an object, you can use Object.keys() to create an array of keys and then perform whatever method you want. Or you can use the spread operator to convert a Map to an array of pairs. If you need a refresher, head back to Tip 14, \u8203? Iterate Over Key-Value Data with Map and the Spread Operator \u8203?.\par
\par
In fact, those are great approaches. The popular Airbnb style guide, for example, insists that you always use array methods and restricts the use of the for...of and for...in loops.[23]\par
\par
That opinion isn\rquote t shared by all. Sometimes it\rquote s not worth the hassle to convert structures to arrays and it\rquote s worth knowing other options.\par
\par
Consider an application where you can select and compare multiple sets of information. Perhaps you\rquote re building an application that has a list of consulting firms. A user can select multiple firms and compare and contrast services.\par
\par
Knowing what you know now, you\rquote d probably use a Map to hold the various firms as users click on options. After all, you\rquote re constantly adding and deleting information, which is an action a Map can handle easily.\par
\par
As the user clicks on firms they\rquote re interested in, you could add the firms to a simple map that uses the ID of the firm as a key and the name of the firm as the value.\par
loops/for/for.js\par
\u8203? \tab\u8203?const\u8203? firms = \u8203?new\u8203? Map()\par
\u8203? \tab   .\u8203?set\u8203?(10, \u8203?'Ivie Group'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(23, \u8203?'Soundscaping Source'\u8203?)\par
\u8203? \tab   .\u8203?set\u8203?(31, \u8203?'Big 6'\u8203?);\par
\par
You can do a lot with that small amount of information. You could select details from a database. You could check availability or create a comparison chart. In all cases, you\rquote d need to act on the collection one piece at a time.\par
\par
For this example, loop through the firms a user has selected to check and see if they\rquote re available. (For the purposes of this example, you\rquote ll use a generic isAvailable() function that would be defined elsewhere.) If one isn\rquote t available, return a message saying the firm is unavailable. Otherwise, return a message saying all are available.\par
\par
If you try writing this out, you\rquote ll immediately notice a problem. You can\rquote t use a traditional for loop because the collection isn\rquote t an array. You can easily bypass that problem by converting the map to an array with the spread operator before looping.\par
loops/for/traditional.js\par
\u8203? \tab\u8203?const\u8203? entries = [...firms];\par
\u8203? \tab\u8203?for\u8203? (\u8203?let\u8203? i = 0; i < entries.length; i++) \{\par
\u8203? \tab   \u8203?const\u8203? [id, name] = entries[i];\par
\u8203? \tab   \u8203?if\u8203? (!isAvailable(id)) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{name\}\u8203? is not available`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\u8203?return\u8203? \u8203?'All firms are available'\u8203?;\par
\par
That loop is pretty straightforward. It gets the information you need in a fairly transparent way. By now, though, you know there are better ways to loop. And you probably noticed that because you have to convert to an array, you might as well use an array method.\par
\par
But there\rquote s no good array method to perform the action. Sure, there are plenty of options that you could try. You might use find() to see if there\rquote s a firm that\rquote s unavailable.\par
loops/for/full.js\par
\u8203? \tab\u8203?const\u8203? unavailable = [...firms].find(firm => \{\par
\u8203? \tab   \u8203?const\u8203? [id] = firm;\par
\u8203? \tab   \u8203?return\u8203? !isAvailable(id);\par
\u8203? \tab\});\par
\u8203? \tab\par
\u8203? \tab\u8203?if\u8203? (unavailable) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{unavailable[1]\}\u8203? is not available`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?return\u8203? \u8203?'All firms are available'\u8203?;\par
\par
You might also write a reduce() method that returns a string with the success message as a default.\par
loops/for/full.js\par
\u8203? \tab\u8203?const\u8203? message = [...firms].reduce((availability, firm) => \{\par
\u8203? \tab   \u8203?const\u8203? [id, name] = firm;\par
\u8203? \tab   \u8203?if\u8203? (!isAvailable(id)) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{name\}\u8203? is not available`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? availability;\par
\u8203? \tab\}, \u8203?'All firms are available'\u8203?);\par
\u8203? \tab\u8203?return\u8203? message;\par
\par
There are many ways to solve the problem. Maybe those solutions are fine for you and your team. Still, they\rquote re a little clunky. You\rquote d probably have to read them twice to understand what\rquote s happening.\par
\par
The problem is the find() approach is a two-step process (find if there are unavailable firms, and then build a message), and the reduce() approach is a little difficult to understand.\par
\par
There\rquote s also the problem that the find() function will give you only the first unavailable firm and the reduce() function will give you only the last.\par
\par
To be fair, you won\rquote t solve that problem here. Try to find a solution both with array methods and with other loops. (Hint: Chain filter() and map() to make an array of messages.) For now, however, ignore that optimization and focus instead on whether all are available or not.\par
\par
You\rquote ve seen three ways to solve the exact same problem with the same result. They all share a common feature: They all require you to first convert the map to an array. Turns out that\rquote s not even necessary. The property on the Map that lets you use the spread operator, the MapIterator, is the same property that will let you iterate over a map directly.\par
\par
In the tip on using the spread operator with Map, you learned about the MapIterator. It\rquote s just a specific instance of the more generalized Iterator, which designates a specific type of object that can access pieces one at a time. You can find them on maps, arrays, and sets, and you can even make your own, as you\rquote ll see in Tip 41, \u8203? Create Iterable Properties with Generators \u8203?.\par
\par
Most important, you can use the iterator with a special loop called a for...of loop. This loop is very similar to the for loop except that you don\rquote t iterate over the indexes (that let i = 0 part). Instead, you loop directly over the members of the collection.\par
\par
In the loop parameters, you declare a name for the individual item and then use that in the body.\par
\par
Instead of converting a specialized object to an array, you use the exact same idea of a for loop while removing reference to indexes. You effectively use the callback method from an array method. Here\rquote s a translation of the functions you saw earlier.\par
loops/for/for.js\par
\u8203? \tab\u8203?for\u8203? (\u8203?const\u8203? firm \u8203?of\u8203? firms) \{\par
\u8203? \tab   \u8203?const\u8203? [id, name] = firm;\par
\u8203? \tab   \u8203?if\u8203? (!isAvailable(id)) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{name\}\u8203? is not available`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\u8203?return\u8203? \u8203?'All firms are available'\u8203?;\par
\par
Notice a few things: First, you declare the variable, firm with const. Because const is block scoped, this variable won\rquote t exist outside the loop so you don\rquote t have to worry about polluting the rest of the code. Next, using the same ideas from array methods, you act on the item directly. You don\rquote t need to reference the full collection as you do with entries[i] in the for loop. It\rquote s a combination of array callback methods and for loops.\par
\par
As a bonus, you also gain a slight optimization by not converting an iterable to an array before then iterating over it again. You don\rquote t have to avoid array methods to gain that micro-optimization, but it\rquote s something to consider.\par
\par
What are the trade-offs? The most obvious is that because the loop can do anything, you lose some predictability. Honestly, that\rquote s about the only problem as long as you don\rquote t mutate the collection as you loop through it (which you could easily do). But you can mutate collections with array methods, too. Avoiding side effects and mutations requires discipline more than syntax.\par
\par
With all those advantages you may wonder, should you always loop directly? In short, no. As a rule, use array methods when they\rquote re clear fits and you prefer them as the default. When you\rquote re filtering data in a map, for example, you should use filters. When you\rquote re converting a map to an array of values, use the map() method. Otherwise, you\rquote ll be stuck creating a container array and mutating it on each loop. Use for...of when it makes the most sense.\par
\par
There\rquote s another slight complication\f1\emdash or benefit, depending on how you think about it\emdash to for...of loops. There\rquote s a similar but different loop that only works on key-value objects. It\rquote s called the for...in loop.\par
\par
The for...in loop is very similar to the for...of loop. You don\rquote t need to convert an object\rquote s keys to an array with Object.keys() because you operate directly on the object itself. Specifically, you loop over the properties of an object.\par
\par
If you\rquote ve worked with JavaScript objects in-depth, you\rquote ll likely know there are some complications with object properties because they can be inherited from other objects in a prototype chain. In addition, objects have non-enumerable properties that are also skipped during iteration.\par
\par
In short, properties on objects can be complex. You can read more about it on the Mozilla Developer Network.[24]\par
\par
Most times, though, you\rquote re working with simple things, and that\rquote s what you\rquote ll focus on here. To start off, convert your map of firms to an object. It\rquote s almost identical, but because keys have to be strings, you\rquote ll need to convert them from numbers. In reality, you can use numbers as keys in object literal syntax and they\rquote ll be covertly converted to strings, but that\rquote s a problem with objects, not an advantage.\par
loops/for/forin.js\par
\u8203? \tab\u8203?const\u8203? firms = \{\par
\u8203? \tab   \u8203?'10'\u8203?: \u8203?'Ivie Group'\u8203?,\par
\u8203? \tab   \u8203?'23'\u8203?: \u8203?'Soundscaping Source'\u8203?,\par
\u8203? \tab   \u8203?'31'\u8203?: \u8203?'Big 6'\u8203?,\par
\u8203? \tab\};\par
\par
When using a for...in loop, you\rquote ll get each property one at a time. Unlike the for...of loop, you don\rquote t get the values, and you\rquote ll have to reference the full collection using the key on each iteration. Everything else should be familiar. You name the variable, preferably with const, and then you use that in the body, knowing it will change on each iteration.\par
\par
Try and convert the last for...of loop and see what you get.\par
\par
You probably came up with something like this:\par
loops/for/forin.js\par
\u8203? \tab\u8203?for\u8203? (\u8203?const\u8203? id \u8203?in\u8203? firms) \{\par
\u8203? \tab   \u8203?if\u8203? (!isAvailable(parseInt(id, 10))) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{firms[id]\}\u8203? is not available`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\u8203?return\u8203? \u8203?'All firms are available'\u8203?;\par
\par
Because you\rquote re getting the property and not a pair, you don\rquote t need to extract the name and value separately. Any time you need the value, you can grab it using array notation on the individual item. If you need the key to be an integer, which you do in this case, you\rquote ll need to convert it using parseInt(). This is why the subtle conversions that happen with object keys can be so confusing.\par
\par
As with the for...of loop, use the for...in loop when it makes sense, but try not to use it as the default. If you\rquote re only going to use the keys, it may make more sense to pull them out with Object.keys() before using an array method. The same is true if you just plan on using the values. You can use Object.values() to convert those to an array, though that\rquote s less common.\par
\par
One other precaution: Don\rquote t mutate the object as you loop over it. That can be very dangerous, and bugs can creep in quickly, especially if you add or modify properties other than the property currently being iterated.\par
\par
Now you have a whole new set of tools for iterating over collections. As you saw in this example, you can solve most problems with multiple methods, so it often comes down to a matter of personal and team preference. Over time, you\rquote ll find that you prefer some methods over the others, and that\rquote s fine. There are fewer right and wrong answers in development than people think.\par
\par
In the next chapter, you\rquote ll be moving from the nuts and bolts of working with data into composing functions. You\rquote ll start with simply exploring new ways of working with parameters. And yes, there are enough changes that we\rquote ll need a whole chapter to explore them. JavaScript can do a lot of interesting things with functions, so it\rquote s exciting that even simple parameters are now more flexible. This is where the fun really begins.\par
Footnotes\par
\par
[20]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://en.wikipedia.org/wiki/Method_chaining }}{\fldrslt{https://en.wikipedia.org/wiki/Method_chaining\ul0\cf0}}}}\f1\fs22\par
[21]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/jsmapr1/simplifying-js }}{\fldrslt{https://github.com/jsmapr1/simplifying-js\ul0\cf0}}}}\f1\fs22\par
[22]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\ul0\cf0}}}}\f1\fs22\par
[23]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/airbnb/javascript/issues/851 }}{\fldrslt{https://github.com/airbnb/javascript/issues/851\ul0\cf0}}}}\f1\fs22\par
[24]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Iterating_over_own_properties_only }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Iterating_over_own_properties_only\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 6\par
Clean Up Parameters and Return Statements\par
\par
I\rquote m famous for assuming I can always find a shortcut. If I\rquote m driving down the highway and hit construction, I\rquote ll take the first off ramp, determined to find a quick way around the delay. Exiting the highway requires that I ignore the protests of my wife, who thinks it would just be easier to slow down and follow the orange cones.\par
\par
Well, my wife is usually right. I pull off and take a side road that suddenly veers even further off course. I don\rquote t mind. I grew up in the middle of nowhere, so I have an intuition for county roads. At least I think I do, until the paved road turns into a dirt road before coming to a dead end at a wheat field. Giving in, I take out my phone to turn on the GPS. Oh wait. I\rquote m in the middle of a wheat field. There\rquote s no signal.\par
\par
Simple actions can spiral out of control quickly. This happens all the time with function arguments. You start with the best of intentions. The function will take two arguments and return a simple value. Suddenly, edge cases pop up. Data inconsistencies creep in. Before you know it, you need eight different parameters to cover dozens of situations. You\rquote d like to give up, but by now, you\rquote re too afraid of breaking all the code downstream that depends on this function.\par
\par
In this chapter, you\rquote ll learn how to plan for changing function arguments and how to create parameters that will be clean and give you flexibility.\par
\par
First, you\rquote ll see how to add default parameters to cover situations where information may not be available. Next, you\rquote ll learn how to pull information out of objects using destructuring and how destructuring can be combined with function parameters to accommodate a range of options. Using that knowledge, you\rquote ll combine information back into new objects, creating return statements that share plenty of information in usable bundles. After that, you\rquote ll return to parameters to see how you can create functions without even knowing the number of arguments to expect.\par
\par
There\rquote s no problem with being adventurous as long as you have a plan for the inevitable contingencies. In this chapter, you\rquote ll see how functions can be built to handle unexpected changes. Learn the lesson I never did as a driver: Leap into the unknown, but plan for the unforeseen.\par
\par
Tip 28\tab Create Default Parameters\par
\par
In this tip, you\rquote ll learn how to use default parameters to set values when a parameter is absent.\par
\par
No matter how much planning you do, things change. This is especially true of function parameters. When you write a function, you expect a few parameters. Then, as code grows and edge cases emerge, suddenly the parameters you supplied aren\rquote t enough.\par
\par
In the next several tips, you\rquote ll learn different techniques for handling parameters. Nearly all of these techniques can help you cope in some way with changing requirements. But to start, you\rquote ll learn the easiest trick: setting default parameters.\par
\par
Consider a basic helper function. All you want to do is convert pounds to kilograms. That seems simple. You simply need to take the weight as an input and divide the weight in pounds by 2.2 to get kilograms. (Apologies to non-Americans who don\rquote t have to deal with this silliness. I\rquote m sure you also get stuck converting other measurements.)\par
params/defaults/simple.js\par
\u8203? \tab\u8203?function\u8203? convertWeight(weight) \{\par
\u8203? \tab   \u8203?return\u8203? weight / 2.2;\par
\u8203? \tab\}\par
\par
That code seems easy enough. And you use it throughout the app. Before you know it, a ticket comes in because someone needs to be able to pass ounces. And because there are 16 ounces in a pound, you\rquote ll need to convert that number to a decimal before adding it to the pounds.\par
\par
Fine. You add in a parameter for ounces, but now you\rquote re in a bind. Do you track down every instance of the function and add in a zero for the ounces? Or do you try to handle cases where a value wasn\rquote t provided?\par
\par
You can try the first approach and update every function, but there\rquote s always the chance that you\rquote ll miss one. Fortunately, in JavaScript, you don\rquote t need to pass all the parameters to a function. They can be optional. If you\rquote re missing a parameter, the value is set to undefined.\par
\par
Knowing that, you go for the second approach and add a little bit of code to set the value if it doesn\rquote t exist.\par
params/defaults/more.js\par
\u8203? \tab\u8203?function\u8203? convertWeight(weight, ounces) \{\par
\u8203? \tab   \u8203?const\u8203? oz = ounces ? ounces / 16 : 0;\par
\u8203? \tab   \u8203?const\u8203? total = weight + oz;\par
\u8203? \tab   \u8203?return\u8203? total / 2.2;\par
\u8203? \tab\}\par
\par
When you run convertWeight(44,11), you get 20.3125, which isn\rquote t bad, but nearly every other conversion returns a long decimal string. convertWeight(44, 8) returns 20.22727....\par
\par
Stranger still, when you run convertWeight(6.6), you expect to get 3 and instead you get 2.999999.... You can thank floating point arithmetic for that.[25]\par
\par
Great\emdash now you need to round up to handle cases where the floating point arithmetic doesn\rquote t match user expectations. And because you\rquote re rounding anyway, you should make the number of decimal points an option, too, with a default of two decimal places.\par
\par
You add some more code to handle the missing parameter. You also add in a helper function, roundTo, to handle the rounding (see the book code for implementation details).\par
\par
But there\rquote s a complication. To make the default two decimal places, you can\rquote t just check to see if the parameter roundTo is truthy. You can\rquote t, for example, write const round = roundTo || 2; because if the user were to pass in 0 as the number of decimal places they wanted, it would default to falsy and go back to two places.\par
\par
Instead, you\rquote d have to explicitly check that the value was undefined, which means that no value was submitted.\par
params/defaults/problem.js\par
\u8203? \tab\u8203?function\u8203? convertWeight(weight, ounces, roundTo) \{\par
\u8203? \tab   \u8203?const\u8203? oz = ounces / 16 || 0;\par
\u8203? \tab   \u8203?const\u8203? total = weight + oz;\par
\u8203? \tab   \u8203?const\u8203? conversion = total / 2.2;\par
\u8203? \tab\par
\u8203? \tab   \u8203?const\u8203? round = roundTo === \u8203?undefined\u8203? ? 2 : roundTo;\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? roundToDecimalPlace(conversion, round);\par
\u8203? \tab\}\par
\par
Every time, the function becomes a little more complex. That\rquote s unavoidable in a world with changing requirements. What you don\rquote t want to do is create problems by having undefined variables. That means every time you add a new parameter, you end up adding a new ternary or short circuiting to create a default value.\par
\par
Changing requirements are part of life. There\rquote s nothing any syntax can do about that. But you can minimize a bunch of variable checks with default parameters.\par
\par
All this means is that if the value isn\rquote t passed, it takes the placeholder value. It\rquote s that simple. You\rquote ve probably seen it in countless other languages. You define the default parameter by putting an equal sign (=) after the parameter name along with the value. If there\rquote s no value for that parameter, it falls back to the default.\par
\par
The updated function still has the additional logic to handle the new requirements (adding ounces, rounding decimals), but at least you can be confident you\rquote ll get something.\par
params/defaults/default.js\par
\u8203? \tab\u8203?function\u8203? convertWeight(weight, ounces = 0, roundTo = 2) \{\par
\u8203? \tab   \u8203?const\u8203? total = weight + (ounces / 16);\par
\u8203? \tab   \u8203?const\u8203? conversion = total / 2.2;\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? roundToDecimalPlace(conversion, roundTo);\par
\u8203? \tab\}\par
\par
As a bonus, you give a clue to other developers that you\rquote re looking for a particular data type. They\rquote d know, for example, that ounces is an integer. This isn\rquote t a substitute for a proper type system, but it\rquote s a nice little extra.\par
JavaScript and Type Checking\par
\par
You don\rquote t need a type system, but if you like one, there are more options now than ever. The most obvious example is TypeScript, which is a superset of JavaScript (it includes all of JavaScript and then some). It\rquote s a good tool, and it\rquote s popular with developers who love a good type system.\par
\par
If you want to write ordinary JavaScript but with a type system, you should check out flow, a static type system developed by Facebook.[26] It\rquote s flexible enough to incorporate into individual files, giving you a chance to try types without having to fully switch over to TypeScript.\par
\par
Default parameters aren\rquote t a perfect solution. Parameter order still matters. If you didn\rquote t want to include ounces but you did want to specify the number of decimal points, you would still need to clarify the number\emdash in this case, it would be 0.\par
params/defaults/default.js\par
\u8203? \tab convertWeight(4, 0, 2);\par
\par
If you absolutely don\rquote t want to pass in a value, you can pass in undefined and the function would use the default parameter, but use this approach with caution. It\rquote s too easy to make mistakes when you pass in undefined. If you passed in null, for example, you wouldn\rquote t get the default value. Besides, if you really don\rquote t care what the default is, you should just use the value set as the default parameter. It\rquote s more clear to others reading the code and it\rquote s less likely to break later if the function changes slightly.\par
params/defaults/default.js\par
\u8203? \tab convertWeight(4, \u8203?undefined\u8203?, 2);\par
\par
A common way around this problem is to pass an object as a second parameter. Because an object can have multiple key-value pairs, you won\rquote t need to change the function parameters every time a new option is added. You will, however, need to pull the information from the object.\par
\par
In the next tip, you\rquote ll see how it\rquote s easier to use objects in parameters by pulling out data with destructuring. \par
\par
Tip 29\tab Access Object Properties with Destructuring\par
\par
In this tip, you\rquote ll learn how to pull information out of objects and arrays quickly with destructuring.\par
\par
In the previous tip, you learned how to create default parameters, which are a great addition to the language, but they still have one big problem: Parameters always have to be given in order. If you wanted to specify the third parameter but you didn\rquote t care about the second, you\rquote d still be forced to enter a value. Default parameters aren\rquote t helpful if you want to skip a parameter.\par
\par
What about situations where you need a large number of arguments for a function? What about situations where you know that the needs of a functions are likely to change? In JavaScript, most developers add extra arguments to an object and pass the object as the last parameter to a function.\par
\par
For example, what if you wanted to display a number of photos and needed to translate the values into an HTML string? Specifically, you want to include the image, title, photographer, and location in that order in your string, but you also want any additional information. Some photographs include equipment, image type, lenses information, and any other customizations. You don\rquote t know what it all will be, but you still want to display it.\par
\par
There is a lot of information associated with a photograph. Passing that information as individual parameters would be excessive\emdash you could end up with about ten parameters. Besides, the information is already structured. What\rquote s the point in changing it? Here\rquote s an example of some information about a photograph.\par
params/destructuring/destructuring.js\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   title: \u8203?'Landscape'\u8203?,\par
\u8203? \tab   photographer: \u8203?'Nathan'\u8203?,\par
\u8203? \tab   equipment: \u8203?'Canon'\u8203?,\par
\u8203? \tab   format: \u8203?'digital'\u8203?,\par
\u8203? \tab   src: \u8203?'/landscape-nm.jpg'\u8203?,\par
\u8203? \tab   location: [32.7122222, -103.1405556],\par
\u8203? \tab\};\par
\par
In this case, it makes sense to pass the whole photo object directly into a function. Of course, once you have it in the function, what do you do with it? You can either pull the information directly from the object when needed using dot syntax\emdash photo.title\emdash or you can assign the information to variables and then use the variables later in the code.\par
\par
Getting the values you know ahead of time is easy. The real trick is getting the excess information\emdash information that you don\rquote t know about ahead of time. The only way to get it is to remove the key-value pairs you\rquote re using elsewhere and then keep whatever is leftover.\par
\par
Fortunately, you\rquote re smart enough to know that you should copy the object before mutating it (good work). And after you copy it, you can delete the keys you don\rquote t need one at a time. The end result is a lot of object assignments for a very small action. Nearly two-thirds of the function is pulling information from an object.\par
params/destructuring/problem.js\par
\u8203? \tab\u8203?function\u8203? displayPhoto(photo) \{\par
\u8203? \tab   \u8203?const\u8203? title = photo.title;\par
\u8203? \tab   \u8203?const\u8203? photographer = photo.photographer || \u8203?'Anonymous'\u8203?;\par
\u8203? \tab   \u8203?const\u8203? location = photo.location;\par
\u8203? \tab   \u8203?const\u8203? url = photo.src;\par
\u8203? \tab\par
\u8203? \tab   \u8203?const\u8203? copy = \{ ...photo \};\par
\u8203? \tab   \u8203?delete\u8203? copy.title;\par
\u8203? \tab   \u8203?delete\u8203? copy.photographer;\par
\u8203? \tab   \u8203?delete\u8203? copy.location;\par
\u8203? \tab   \u8203?delete\u8203? copy.src;\par
\u8203? \tab\par
\u8203? \tab   \u8203?const\u8203? additional = Object.keys(copy).map(key => \u8203?`\u8203?$\{key\}\u8203?: \u8203?$\{copy[key]\}\u8203?`\u8203?);\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? (\u8203?`\u8203?\par
\u8203? \tab\u8203?    <img alt="Photo of \u8203?$\{title\}\u8203? by \u8203?$\{photographer\}\u8203?" src="\u8203?$\{url\}\u8203?" />\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{title\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{photographer\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>Latitude: \u8203?$\{location[0]\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>Longitude: \u8203?$\{location[1]\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{additional.join(\u8203?' <br/> '\u8203?)\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?  `\u8203?);\par
\u8203? \tab\}\par
\par
Remember back in Tip 10, \u8203? Use Objects for Static Key-Value Lookups \u8203? where you learned that objects are great for passing around static information? You\rquote re about to learn why.\par
\par
In JavaScript, you can assign variables directly from an object using a process called destructuring assignment.\par
\par
It works like this: Destructuring allows you to create a variable with the same name as an object\rquote s key assigned with the value from the object.\par
\par
As usual, it\rquote s always easier to see. In this case, you have an object with a key of photographer and you\rquote re going to create a variable named photographer from that object.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   photographer: \u8203?'Nathan'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? \{ photographer \} = landscape;\par
\u8203? \tab photographer\par
\u8203? \tab\u8203?// Nathan\u8203?\par
\par
Notice a few things. First, you still have to declare a variable type. As usual, you should prefer const. Second, the assignment variable must match the key in the object. Finally, it\rquote s set against the object. You are merely assigning a variable. The curly braces merely signal the value that variable should use is inside an object.\par
\par
That\rquote s the bare bones\emdash set a variable using the key. Of course, nothing is ever that simple. What happens when a key doesn\rquote t exist? Well, in that case, the value is merely undefined, but you can also set a default value while destructuring.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab\};\par
\u8203? \tab\u8203?const\u8203? \{ photographer = \u8203?'Anonymous'\u8203?, title\} = landscape;\par
\u8203? \tab\par
\u8203? \tab photographer\par
\u8203? \tab\u8203?// Anonymous\u8203?\par
\u8203? \tab\par
\u8203? \tab title\par
\u8203? \tab\u8203?// undefined\u8203?\par
\par
At this point, you\rquote ve caught up to regular parameters. You can set a variable from a key. You can set default values. But what do you do if you don\rquote t know the key name? How do you get the leftover information? Remember that you want any additional information from a photograph and you have no clue what that will be.\par
\par
Good news: Your favorite three dots are back. You can collect any additional values into a new variable using three dots (...) followed by the variable name. When you use the three-dot syntax to collect information, it\rquote s no longer called the spread operator. It\rquote s called the rest operator, and you\rquote ll see more of it in upcoming tips.\par
\par
You can name the variable anything you want. It doesn\rquote t need to match a key (in fact, it shouldn\rquote t match a key). And the value of the variable will be an object of the remaining key-value pairs.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   photographer: \u8203?'Nathan'\u8203?,\par
\u8203? \tab   equipment: \u8203?'Canon'\u8203?,\par
\u8203? \tab   format: \u8203?'digital'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab j\par
\u8203? \tab\u8203?const\u8203? \{\par
\u8203? \tab     photographer,\par
\u8203? \tab     ...additional\par
\u8203? \tab\} = landscape;\par
\u8203? \tab\par
\u8203? \tab additional;\par
\u8203? \tab\u8203?// \{ equipment: 'Canon', format: 'digital'\}\u8203?\par
\par
photographer is pulled out from the object, and the remaining fields go into a new object. You essentially copied the photograph object and deleted the photographer key.\par
\par
Notice how the variable assignments are on different lines: photographer is on one line and ...additional is on the next. It\rquote s simply a style preference to keep things more readable. You can keep both assignments on the same line as you do above.\par
\par
Now you can pull information from an object, assign default parameters, and collect additional key-values. As if that weren\rquote t enough to celebrate, you can also assign a key to a different variable name. This is useful in situations where the key name is taken by a previously defined variable or you just don\rquote t like the key name and you want something more expressive.\par
\par
In the original code, you assign the information from photo.src to the variable name url. To accomplish that with destructuring, you simply put the key name first with a colon followed by the value you want to assign it to.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   src: \u8203?'/landscape-nm.jpg'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? \{ src: url \} = landscape;\par
\u8203? \tab src\par
\u8203? \tab\u8203?// ReferenceError: src is not defined\u8203?\par
\u8203? \tab url\par
\u8203? \tab\u8203?// '/landscape-nm.jpg'\u8203?\par
\par
You still must use the key name to signal which value you want to use, but you are not bound to that key name.\par
\par
Finally, you can also use destructuring assignment with arrays, with one big exception: Because there are no keys in arrays, you can use any variable name you want, but you must assign the information in order. If you want to assign the third item to a variable, you must first assign the previous two values to a variable. Otherwise, it\rquote s simple. Destructuring is a great way to work with array pairs in a situation where the order denotes some information. For example, if you had an array of latitude and longitude, you\rquote d always know the first value corresponds to latitude and the second to longitude.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   location: [32.7122222, -103.1405556],\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? \{ location \} = landscape;\par
\u8203? \tab\u8203?const\u8203? [latitude, longitude] = location\par
\u8203? \tab latitude\par
\u8203? \tab\u8203?// 32.7122222\u8203?\par
\u8203? \tab longitude\par
\u8203? \tab\u8203?// -103.1405556\u8203?\par
\par
Of course, in the preceding situation, you pulled out location first from an object and then latitude and longitude from the array. There\rquote s no need to make it a two-step process. You can combine the assignments during destructuring.\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   location: [32.7122222, -103.1405556],\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? \{ location: [latitude, longitude] \} = landscape;\par
\u8203? \tab latitude\par
\u8203? \tab\u8203?// 32.7122222\u8203?\par
\u8203? \tab longitude\par
\u8203? \tab\u8203?// -103.1405556\u8203?\par
\par
All right, that was a lot to think about. But it really can clean things up fast. Remember the original function? Here it is with destructuring:\par
params/destructuring/alternate.js\par
\u8203? \tab\u8203?function\u8203? displayPhoto(photo) \{\par
\u8203? \tab   \u8203?const\u8203? \{\par
\u8203? \tab     title,\par
\u8203? \tab     photographer = \u8203?'Anonymous'\u8203?,\par
\u8203? \tab     location: [latitude, longitude],\par
\u8203? \tab     src: url,\par
\u8203? \tab     ...other\par
\u8203? \tab   \} = photo;\par
\u8203? \tab   \u8203?const\u8203? additional = Object.keys(other).map(key => \u8203?`\u8203?$\{key\}\u8203?: \u8203?$\{other[key]\}\u8203?`\u8203?);\par
\u8203? \tab   \u8203?return\u8203? (\u8203?`\u8203?\par
\u8203? \tab\u8203?    <img alt="Photo of \u8203?$\{title\}\u8203? by \u8203?$\{photographer\}\u8203?" src="\u8203?$\{url\}\u8203?" />\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{title\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{photographer\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>Latitude: \u8203?$\{latitude\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>Longitude: \u8203?$\{longitude\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{additional.join(\u8203?' <br/> '\u8203?)\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?  `\u8203?);\par
\u8203? \tab\}\par
\par
Looks good, doesn\rquote t it? But you\rquote re probably wondering what this is doing in a chapter about cleaning up parameters.\par
\par
The best part about destructuring is that you can move it right into the parameters of a function. The information will be assigned just as it was in the body of the function, but there\rquote s no need to declare the variable type. If you\rquote re curious, it\rquote ll be assigned with let so it\rquote s possible to reassign the variable.\par
\par
In other words, you can clean up the original code even more:\par
params/destructuring/destructuring.js\par
\u8203? \tab\u8203?function\u8203? displayPhoto(\{\par
\u8203? \tab   title,\par
\u8203? \tab   photographer = \u8203?'Anonymous'\u8203?,\par
\u8203? \tab   location: [latitude, longitude],\par
\u8203? \tab   src: url,\par
\u8203? \tab   ...other\par
\u8203? \tab\}) \{\par
\u8203? \tab   \u8203?const\u8203? additional = Object.keys(other).map(key => \u8203?`\u8203?$\{key\}\u8203?: \u8203?$\{other[key]\}\u8203?`\u8203?);\par
\u8203? \tab   \u8203?return\u8203? (\u8203?`\u8203?\par
\u8203? \tab\u8203?    <img alt="Photo of \u8203?$\{title\}\u8203? by \u8203?$\{photographer\}\u8203?" src="\u8203?$\{url\}\u8203?" />\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{title\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{photographer\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?    <div>Latitude: \u8203?$\{latitude\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>Longitude: \u8203?$\{longitude\}\u8203? </div>\u8203?\par
\u8203? \tab\u8203?    <div>\u8203?$\{additional.join(\u8203?' <br/> '\u8203?)\}\u8203?</div>\u8203?\par
\u8203? \tab\u8203?  `\u8203?);\par
\u8203? \tab\}\par
\par
Notice that you still need the curly braces, but otherwise everything is the same. Now when you call the function, you can just pass the object and everything will be assigned to the proper parameters: displayPhoto(landscape).\par
\par
Not only did you save yourself all the assignment problems, but by passing an object as a parameter, you don\rquote t have to worry about the order of the key-values.\par
\par
And if you wanted to pull out another key-value, it\rquote s just a matter of adding the new variable to the destructuring. Say you wanted to assign equipment explicitly. All you need to do is add in the new variable name in the list of variables and you\rquote ll be good to go. There\rquote s no need to worry about other times when the function is called. If equipment isn\rquote t part of another object, it will merely be undefined.\par
\par
That was probably a whirlwind, but it should give you a taste for how easily you can pull information from objects. The only downside is this only works on objects used as key-value pairs or object instances of a class.\par
\par
Destructuring won\rquote t work on Map, which is fine because this is primarily useful when you\rquote re sending information between functions, meaning you shouldn\rquote t be looping or reassigning values. In other words, the data is static, so an object is a great choice.\par
\par
As if that wasn\rquote t overwhelming enough, you\rquote ve only seen half of it. In the next tip, you\rquote re going to go in the other direction and put information back into an object. \par
\par
Tip 30\tab Simplify Key-Value Assignment\par
\par
In this tip, you\rquote ll learn how to make objects quickly with shortened key-value assignment.\par
\par
You just learned how to pull apart objects in a clear and clean way. Now that you have all those pieces laying out on your proverbial work bench, you need to put them back together. It wouldn\rquote t be any good if the writers of the spec gave you a clean interface to take objects apart while leaving you no way to put them back together.\par
\par
Well, you\rquote re in luck. The same technique you\rquote d use to take objects apart works in reverse. It\rquote s time to build new objects using similar syntax that will leave your code clear and predictable.\par
\par
Start with a similar object of photo information:\par
params/assignment/assignment.js\par
\u8203? \tab\u8203?const\u8203? landscape = \{\par
\u8203? \tab   title: \u8203?'Landscape'\u8203?,\par
\u8203? \tab   photographer: \u8203?'Nathan'\u8203?,\par
\u8203? \tab   location: [32.7122222, -103.1405556],\par
\u8203? \tab\};\par
\par
In this case, you have the location information in latitude and longitude, but what you need is the city and state names.\par
\par
Elsewhere in the code, you have a helper function that looks up regional information (city, state, county) from the geographical coordinates. The implementation details aren\rquote t important. What matters here is that you get back another object of information.\par
params/assignment/assignment.js\par
\u8203? \tab\u8203?const\u8203? region = \{\par
\u8203? \tab   city: \u8203?'Hobbs'\u8203?,\par
\u8203? \tab   county: \u8203?'Lea'\u8203?,\par
\u8203? \tab   state: \{\par
\u8203? \tab     name: \u8203?'New Mexico'\u8203?,\par
\u8203? \tab     abbreviation: \u8203?'NM'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\par
Now you just need to take the city and state from the return object and assign it to the new object. Fortunately, adding information into objects is very simple.\par
\par
If you want to add a key-value pair to an object where the key is the same name as the variable, simply put in the variable. That\rquote s it. You don\rquote t need any extra colons.\par
\par
You can also mix it up\emdash have some key-value pairs defined with a variable and some defined the traditional way.\par
params/assignment/assignment.js\par
\u8203? \tab\u8203?function\u8203? getCityAndState(\{ location \}) \{\par
\u8203? \tab   \u8203?const\u8203? \{ city, state \} = determineCityAndState(location);\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     city,\par
\u8203? \tab     state: state.abbreviation,\par
\u8203? \tab   \};\par
\u8203? \tab   \u8203?// \{\u8203?\par
\u8203? \tab   \u8203?//   city: 'Hobbs',\u8203?\par
\u8203? \tab   \u8203?//   state: 'NM'\u8203?\par
\u8203? \tab   \u8203?// \}\u8203?\par
\u8203? \tab\}\par
\par
In this case, you\rquote re adding a key of city with destructuring assignment and a key of state with normal key-value assignment.\par
\par
What if you just want to sub out one piece of information in an object but keep everything else? For example, say you want to use getCityAndState() to translate the coordinates into strings, but you want to keep everything else from the original object.\par
\par
You can combine the object spread operator with regular key-value assignment to swap out one piece of information while retaining everything else.\par
params/assignment/assignment.js\par
\u8203? \tab\u8203?function\u8203? setRegion(\{ location, ...details \}) \{\par
\u8203? \tab   \u8203?const\u8203? \{ city, state \} = determineCityAndState(location);\par
\u8203? \tab   \u8203?return\u8203? \{\par
\u8203? \tab     city,\par
\u8203? \tab     state: state.abbreviation,\par
\u8203? \tab     ...details,\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\par
Don\rquote t gloss over this code too quickly. There\rquote s actually something interesting happening. When you use destructuring to pull out the location key-value pair, you\rquote re also assigning everything else except location to the variable name details. You\rquote re essentially copying the object and then running delete photo.location.\par
\par
When you recombine the object by spreading out details along with new key value pairs, you\rquote re doing some subtle but powerful manipulation of objects to get exactly the information you want.\par
\par
The result will have no location, but it will include all the original information along with the city and state.\par
params/assignment/assignment.js\par
\u8203? \tab\{\par
\u8203? \tab   title: \u8203?'Landscape'\u8203?,\par
\u8203? \tab   photographer: \u8203?'Nathan'\u8203?,\par
\u8203? \tab   city: \u8203?'Hobbs'\u8203?,\par
\u8203? \tab   state: \u8203?'NM'\u8203?,\par
\u8203? \tab\};\par
\par
As you know, the spread operator is my favorite ES6 feature. But I know several developers who say destructuring is their favorite feature and that it\rquote s changed the way they work with objects and functions. It will change the way you work, too.\par
\par
Now that you have the tools you need to pull objects apart and put them back together, be sure to think twice before you create objects by assigning each key-value explicitly. If you\rquote re going to assign a value to a variable, you might as well use the key name. Before long, destructuring will become second nature, and you\rquote ll love how it transforms your code.\par
\par
In the next tip, you\rquote ll learn how to have a variable number of parameters with rest parameters using your favorite three-dot syntax.\par
\par
Tip 31\tab Pass a Variable Number of Arguments with the Rest Operator\par
\par
In this tip, you\rquote ll learn to collect an unknown number of parameters with the rest operator.\par
\par
In the previous tips, you saw how object destructuring would let you combine several parameters into a single argument.\par
\par
Using objects to hold parameters is a great technique, but it\rquote s really only useful in situations where the parameters are different and you know them ahead of time. In other words, it only makes sense in situations with objects.\par
\par
That may seem obvious, but it raises the question: How do you handle an unknown number of similar parameters?\par
\par
Think back to the photo display application. What if you wanted to allow your users to tag photos but you only wanted the tags to be a certain length? You could easily write a very short validation function that takes a size and an array of tags and returns true if all are valid.\par
params/rest/simple.js\par
\u8203? \tab\u8203?function\u8203? validateCharacterCount(max, items) \{\par
\u8203? \tab   \u8203?return\u8203? items.every(item => item.length < max);\par
\u8203? \tab\}\par
\par
Notice the every() method? It\rquote s another simple array method you haven\rquote t seen before. As with filter(), you pass a callback that returns a truthy or falsy value. The every() method returns true if every item in an array passed to the callback returns truthy. Otherwise, it returns false.\par
\par
Running the function is simple. Just pass in an array of strings.\par
params/rest/simple.js\par
\u8203? \tab validateCharacterCount(10, [\u8203?'Hobbs'\u8203?, \u8203?'Eagles'\u8203?]);\par
\u8203? \tab\u8203?// true\u8203?\par
\par
This code is great because it\rquote s so generic. You can easily reuse it elsewhere. The only down side to this code is that it locks the users of your function into a particular collection type. Another developer might, for example, want to test that a single username isn\rquote t too long. To use the code, they\rquote d have to know that they\rquote d need to pass an array. If they didn\rquote t, they would get an error.\par
params/rest/simple.js\par
\u8203? \tab   validateCharacterCount(10, \u8203?'wvoquine'\u8203?);\par
\u8203? \tab\u8203?// TypeError: items.every is not a function\u8203?\par
\par
You could write some documentation to communicate the parameters, but there\rquote s a better way. Previously, JavaScript developers solved this problem by using the built-in arguments object. This handy object gives you an array-like collection of all the arguments that are passed to a function.\par
params/rest/problem.js\par
\u8203? \tab\u8203?function\u8203? getArguments() \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?arguments\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab getArguments(\u8203?'Bloomsday'\u8203?, \u8203?'June 16'\u8203?);\par
\u8203? \tab\u8203?// \{ '0': 'Bloomsday', '1': 'June 16' \}\u8203?\par
\par
You may have noticed the phrase \ldblquote array-like.\rdblquote  Unfortunately, arguments is an object, so you\rquote ll need to do some converting to get it to an array. Specifically, you\rquote ll need to statically call a method on the Array object (as opposed to an array instance) as you see in line 2 in the code that follows. This line of code takes all arguments after the first one, the character count, and combines them into an array.\par
params/rest/problem.js\par
\u8203?1: \tab\u8203?function\u8203? validateCharacterCount(max) \{\par
\u8203?2: \tab   \u8203?const\u8203? items = Array.prototype.slice.call(\u8203?arguments\u8203?, 1); \par
\u8203?3: \tab   \u8203?return\u8203? items.every(item => item.length < max);\par
\u8203?4: \tab\}\par
\par
Now you can pass as many arguments as you want knowing you\rquote ll have an array inside the function.\par
\par
What about situations where you already have an array? Because you are converting the arguments into an array, you\rquote ll need to convert your array into a list of arguments.\par
\par
Think back to when you learned about the spread operator. At the time, you learned you always need to spread into something. Up until now, you\rquote ve only spread it into another array. You can also spread it as a list of parameters. In other words, when you collect parameters into a list, you can easily handle cases of strings or arrays.\par
\par
Using these techniques, you can now use your function with a variety of parameters.\par
params/rest/problem.js\par
\u8203? \tab validateCharacterCount(10, \u8203?'wvoquie'\u8203?);\par
\u8203? \tab\u8203?// true\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? tags = [\u8203?'Hobbs'\u8203?, \u8203?'Eagles'\u8203?];\par
\u8203? \tab validateCharacterCount(10, ...tags);\par
\u8203? \tab\u8203?// true\u8203?\par
\par
This is more flexible, but it\rquote s far from perfect. The biggest problem is that the syntax to work with the arguments object is a little convoluted. As a result, few developers (except the most hard-core JavaScript developers) used it. Not to mention that when you use the arguments object, there are absolutely no clues in the function parameters that you accept a list of arguments. Another developer would have to dig into the function body to understand what they can pass to the function.\par
\par
Enter rest parameters. Rest parameters enable you to pass a list of arguments and assigns them to a variable.\par
JavaScript and Functional Languages\par
\par
JavaScript was highly influenced by a variety of languages including Java (an object-oriented language), Scheme (a lisp or functional language), and Self (a prototype language).[27] This means that JavaScript can handle multiple paradigms. As a result, JavaScript is a great environment to explore ideas from other paradigms, especially concepts from functional languages.\par
\par
You\rquote ve already explored a number of functional concepts such as pure functions, side effects, and currying. Rest arguments themselves are a carryover from Lisp dialects (such as Scheme). You\rquote ll see even more functional concepts when you explore higher-order functions. JavaScript is a great way to break out of an object-oriented mold to try new ideas.\par
\par
You declare rest operators using your favorite three dots (...) followed by the variable you\rquote d like to assign them to. Any parameters passed beyond that point are collected into the variable as an array.\par
params/rest/rest.js\par
\u8203? \tab\u8203?function\u8203? getArguments(...args) \{\par
\u8203? \tab   \u8203?return\u8203? args;\par
\u8203? \tab\}\par
\u8203? \tab getArguments(\u8203?'Bloomsday'\u8203?, \u8203?'June 16'\u8203?);\par
\u8203? \tab\u8203?// ['Bloomsday', 'June 16']\u8203?\par
\par
It\rquote s that simple. Try rewriting the validateCharacterCount() function using rest arguments.\par
\par
It probably took you no time at all to come up with this:\par
params/rest/rest.js\par
\u8203? \tab\u8203?function\u8203? validateCharacterCount(max, ...items) \{\par
\u8203? \tab   \u8203?return\u8203? items.every(item => item.length < max);\par
\u8203? \tab\}\par
\par
In addition to being simpler and cleaner, it is more predictable. Now a developer can tell that this function takes at minimum two arguments. Even those unfamiliar with the rest operator have enough clues that a quick Stack Overflow search would fill in the details.\par
\par
You\rquote d call the function exactly the same way as you did with the previous function, by either passing a list of arguments or spreading an array of arguments into a list. This is no different from the previous code when you used the arguments object.\par
params/rest/rest.js\par
\u8203? \tab validateCharacterCount(10, \u8203?'wvoquie'\u8203?);\par
\u8203? \tab\u8203?// true\u8203?\par
\u8203? \tab\par
\u8203? \tab validateCharacterCount(10, ...[\u8203?'wvoquie'\u8203?]);\par
\u8203? \tab\u8203?// true\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? tags = [\u8203?'Hobbs'\u8203?, \u8203?'Eagles'\u8203?];\par
\u8203? \tab validateCharacterCount(10, ...tags);\par
\u8203? \tab\u8203?// true\u8203?\par
\u8203? \tab\par
\u8203? \tab validateCharacterCount(10, \u8203?'Hobbs'\u8203?, \u8203?'Eagles'\u8203?);\par
\u8203? \tab\u8203?// true\u8203?\par
\par
At this point, you\rquote ve accounted for a situation where you might get either a list or an array. There are a few other reasons you might use rest arguments.\par
\par
First, you want to signal to other developers that you\rquote ll be working with arguments as an array. In the absence of type checking, this is another little clue that will help future developers. A lot of developers will use the rest operator even though the data they\rquote re passing in will be in the form of an array. Even though they always spread in the information when calling the function, it\rquote s a clear marker of the expected parameter type.\par
\par
Second, the rest operator can give you a nice way to debug code. For example, it can help you decode library functions that you suspect may be getting additional parameters, and you can use a rest argument to collect any lingering arguments.\par
\par
You\rquote ve worked with the map() method several times, and you know the callback function takes the item being checked as an argument. It turns out that the callback function passes a few more arguments after the individual items. If you collect the rest of the parameters and log them, you\rquote ll see the map() operator also takes the index of the item being checked and the full collection.\par
params/rest/rest.js\par
\u8203? \tab [\u8203?'Spirited Away'\u8203?, \u8203?'Princess Mononoke'\u8203?].map((film, ...other) => \{\par
\u8203? \tab   console.log(other);\par
\u8203? \tab   \u8203?return\u8203? film.toLowerCase();\par
\u8203? \tab\});\par
\u8203? \tab\u8203?// [0, ['Spirited Away', 'Princess Mononoke']]\u8203?\par
\u8203? \tab\u8203?// [1, ['Spirited Away', 'Princess Mononoke']]\u8203?\par
\par
This isn\rquote t a big deal on the map() operator, which is well-documented, but the rest operator can help you see parameters that you might not have otherwise known about. The rest operator is a great way to debug.\par
\par
Third, rest arguments are a great way to pass props through functions if you have no plans to alter them.\par
\par
This is nice when you want to wrap a couple of functions and pass the arguments through. For example, you may have a modal, and when changes are saved, you\rquote ll want to close a modal while simultaneously updating some information with another function.\par
params/rest/rest.js\par
\u8203? \tab\u8203?function\u8203? applyChanges(...args) \{\par
\u8203? \tab   updateAccount(...args);\par
\u8203? \tab   closeModal();\par
\u8203? \tab\}\par
\par
Finally, don\rquote t forget the rest operator isn\rquote t just for parameters. As you\rquote ve seen, it works for pulling the remaining key-values from objects or the remaining values from arrays.\par
\par
Much like the spread operator, you can recreate a common array method while removing side effects. If you wanted to recreate the shift() method, which returns the first item of an array and removes that item from the original array, simply combine the rest operator and destructuring.\par
params/rest/rest.js\par
\u8203? \tab\u8203?const\u8203? queue = [\u8203?'stop'\u8203?, \u8203?'collaborate'\u8203?, \u8203?'listen'\u8203?];\par
\u8203? \tab\u8203?const\u8203? [first, ...remaining] = queue;\par
\u8203? \tab first;\par
\u8203? \tab\u8203?// 'stop'\u8203?\par
\u8203? \tab remaining;\par
\u8203? \tab\u8203?// ['collaborate', 'listen'];\u8203?\par
\par
You get the first value and an array of the remaining values. As a bonus, the original array is still intact.\par
\par
The only downside to using the rest operator as an argument is that it must be the last argument in all situations. It must be the last parameter for a function. It must be the last value when destructuring. This means that although you can recreate the shift() method\emdash return the first item\emdash you can\rquote t recreate the pop() method, which returns the last item of an array.\par
\u8203? \tab\u8203?const\u8203? [...beginning, last] = queue;\par
\u8203? \tab\u8203?// SyntaxError: Rest element must be last element\u8203?\par
\par
Still, the rest operator is very useful, and you\rquote ll find lots of opportunities to work it into your code.\par
\par
Look at how much more you can do with functions already. And you\rquote ve only just begun. In the next chapter, you\rquote ll move beyond parameters and return statements and explore how to construct more powerful and flexible functions.\par
Footnotes\par
\par
[25]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html }}{\fldrslt{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html\ul0\cf0}}}}\f1\fs22\par
[26]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://flow.org }}{\fldrslt{https://flow.org\ul0\cf0}}}}\f1\fs22\par
[27]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://www.youtube.com/watch?v=DogGMNBZZvg }}{\fldrslt{https://www.youtube.com/watch?v=DogGMNBZZvg\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 7\par
Build Flexible Functions\par
\par
Several years ago, the New York Times asked a master furniture builder to review furniture from Ikea, Target, and other discount retailers.[28]\par
\par
Unsurprisingly, the craftsman was not impressed. He noticed problems with the wood finish, screws that would tear out, and other issues. Astonishingly, he noticed a piece of chipping paint and concluded that the piece was painted before it was cut and that the blade cutting the wood was dull. A single piece of chipped paint told him something about the construction process and the tools used to create it.\par
\par
A master of his or her craft can see things that others don\rquote t. In this chapter, you\rquote re going to learn to master functions, and in the process, you\rquote ll see ideas in code that you\rquote ve probably never considered before. Problems disappear and new ideas pop up regularly.\par
\par
Functions are so common that it\rquote s easy to ignore them. But functions in JavaScript are different. You may think you know how to use them, but you\rquote ll be surprised to find how much more they are capable of. This chapter isn\rquote t about the basics. It\rquote s about how you can use functions in ways you may not have explored before.\par
\par
You\rquote ll start off by learning how to write testable code. Testable functions are more clean and easy to maintain, but learning to write them takes a little effort. From there, you\rquote ll return to arrow functions to see how you can take all the ideas from parameters and apply them in single line functions. Next, you\rquote ll dive into higher-order functions\emdash functions that return functions\emdash and learn two techniques to help you lock in information to make clear, reusable functions. Finally, you\rquote ll return to arrow functions to see how you can use them to solve a sneaky context problem that will drive you crazy if you aren\rquote t expecting it.\par
\par
Functions, currying, higher-order functions. These are the concepts that turn casual JavaScript writers into fanatics. They\rquote re the concepts I love most about the language.\par
\par
When you\rquote re finished, you\rquote ll see problems in new ways. You won\rquote t be baffled when this returns undefined. You\rquote ll see a context problem that you can solve with arrow functions. When a variable is inaccessible, you\rquote ll see an opportunity for closures. Masters of a craft see the world differently. When you\rquote re finished mastering functions, you\rquote ll see all problems in a new way.\par
\par
Tip 32\tab Write Functions for Testability\par
\par
I had a literature professor who said that classes about writing don\rquote t include enough reading and classes about reading don\rquote t include enough writing. The same is true of code and tests: Books about code don\rquote t talk enough about testing and books about testing don\rquote t talk enough about composing code.\par
\par
Time to fix that. Testing is important. If you don\rquote t do it, you should. It makes your code easier to refactor. It makes legacy code much easier to understand. And it generally results in cleaner, less buggy applications.\par
\par
Most developers agree with this. Why then is testing neglected?\par
\par
It\rquote s simple. Writing tests is hard. Or more accurately, many developers think writing tests is hard because they try to fit tests onto their existing code. And their existing code is tightly coupled with external dependencies.\par
\par
Code that\rquote s hard to test is often unnecessarily complex. Instead of struggling to make tests for your code, you should focus on writing code that is testable. Your code will improve, your tests will be easier to write, and the user experience will be identical. There\rquote s nothing to lose.\par
\par
If you\rquote re new to testing, check the documentation for one of three popular testing frameworks\emdash jasmine,[29] mocha,[30] or jest[31]\emdash for some quick pointers. You can also check out the code for this book, which has near 100% code coverage using mocha as the test runner.\par
\par
To get the most out of this tip, you should know the basics of describe() and it() functions along with expectations.\par
\par
Now, how do you write testable code? Here\rquote s a function that looks simple but has some subtle complexity.\par
functions/test/problem.js\par
\u8203?1: \tab\u8203?import\u8203? \{ getTaxInformation \} \u8203?from\u8203? \u8203?'./taxService'\u8203?;\par
\u8203?2: \tab\par
\u8203?3: \tab\u8203?function\u8203? formatPrice(user, \{ price, location \}) \{\par
\u8203?4: \tab   \u8203?const\u8203? rate = getTaxInformation(location); \par
\u8203?5: \tab   \u8203?const\u8203? taxes = rate ? \u8203?`plus $\u8203?$\{price * rate\}\u8203? in taxes.`\u8203? : \u8203?'plus tax.'\u8203?;\par
\u8203?6: \tab\par
\u8203?7: \tab   \u8203?return\u8203? \u8203?`\u8203?$\{user\}\u8203? your total is: \u8203?$\{price\}\u8203? \u8203?$\{taxes\}\u8203?`\u8203?;\par
\u8203?8: \tab\}\par
\u8203?9: \tab\par
\u8203?10: \tab\u8203?export\u8203? \{ formatPrice \};\par
\par
You may be wondering, how can this be complex? All it does is compute some tax information from a price and combines it with a user to create a string.\par
\par
The testing difficulty begins when you call an outside function on line 4. Notice that you\rquote re importing that function at the top of the file. You\rquote ll learn more about importing functions in Tip 47, \u8203? Isolate Functionality with Import and Export \u8203?, but for now, all you need to know is that you\rquote re getting something from outside the file.\par
\par
The problem with using imported code directly is that the function is now tightly coupled with the imported function. You can\rquote t run formatPrice() without executing getTaxInformation(). And because the getTaxInformation() function will likely need to hit an external service or a config file, you\rquote re now tightly coupled to network communication. This means that if you run a test, the test will also have to access the API. Now your test is dependent on network access, response time, and so on. Again, this is a big problem. You\rquote re just trying to build a string.\par
\par
To avoid the problem, you can create mocks that intercept imports and explicitly set a return value. Here\rquote s what a test would look like for the current function.\par
functions/test/problem.spec.js\par
\u8203?1: \tab\u8203?import\u8203? expect \u8203?from\u8203? \u8203?'expect'\u8203?;\par
\u8203?- \tab\par
\u8203?- \tab\u8203?import\u8203? sinon \u8203?from\u8203? \u8203?'sinon'\u8203?;\par
\u8203?- \tab\u8203?import\u8203? * \u8203?as\u8203? taxService \u8203?from\u8203? \u8203?'./taxService'\u8203?;\par
\u8203?5: \tab\u8203?import\u8203? \{ formatPrice \} \u8203?from\u8203? \u8203?'./problem'\u8203?;\par
\u8203?- \tab\par
\u8203?- \tab describe(\u8203?'format price'\u8203?, () => \{\par
\u8203?- \tab   \u8203?let\u8203? taxStub;\par
\u8203?- \tab\par
\u8203?10: \tab   beforeEach(() => \{\par
\u8203?- \tab     taxStub = sinon.stub(taxService, \u8203?'getTaxInformation'\u8203?); \par
\u8203?- \tab   \});\par
\u8203?- \tab\par
\u8203?- \tab   afterEach(() => \{\par
\u8203?15: \tab     taxStub.restore(); \par
\u8203?- \tab   \});\par
\u8203?- \tab\par
\u8203?- \tab   it(\u8203?'should return plus tax if no tax info'\u8203?, () => \{\par
\u8203?- \tab     taxStub.returns(\u8203?null\u8203?); \par
\u8203?20: \tab     \u8203?const\u8203? item = \{ price: 30, location: \u8203?'Oklahoma'\u8203? \};\par
\u8203?- \tab     \u8203?const\u8203? user = \u8203?'Aaron Cometbus'\u8203?;\par
\u8203?- \tab     \u8203?const\u8203? message = formatPrice(user, item);\par
\u8203?- \tab     \u8203?const\u8203? expectedMessage = \u8203?'Aaron Cometbus your total is: 30 plus tax.'\u8203?;\par
\u8203?- \tab     expect(message).toEqual(expectedMessage);\par
\u8203?25: \tab   \});\par
\u8203?- \tab\par
\u8203?- \tab   it(\u8203?'should return plus tax information'\u8203?, () => \{\par
\u8203?- \tab     taxStub.returns(0.1);\par
\u8203?- \tab\par
\u8203?30: \tab     \u8203?const\u8203? item = \{ price: 30, location: \u8203?'Oklahoma'\u8203? \};\par
\u8203?- \tab     \u8203?const\u8203? user = \u8203?'Aaron Cometbus'\u8203?;\par
\u8203?- \tab     \u8203?const\u8203? message = formatPrice(user, item);\par
\u8203?- \tab     \u8203?const\u8203? expectedMessage = \u8203?'Aaron Cometbus your total is:\u8203?\par
\u8203?- \tab\u8203?                            30 plus $3 in taxes.'\u8203?;\par
\u8203?35: \tab     expect(message).toEqual(expectedMessage);\par
\u8203?- \tab   \});\par
\u8203?- \tab\});\par
\par
The tricky part begins on line 11. You\rquote re creating a stub that overrides the original getTaxInformation() function with a simple return value.\par
\par
When you create a stub, you\rquote re bypassing the imported code and declaring what the output would be without running the actual code. The upside is that now you don\rquote t have to worry about any external dependencies. The downside is that you constantly have to set and reset the return value in every assertion. See line 19 for an example.\par
\par
Finally, after the test suite is over, you have to restore the code to use the original method. You do this in the afterEach() method on line 15. Restoring the code is a crucial step. By hijacking the code in this test suite, you\rquote ve hijacked it for all tests unless you restore it.\par
\par
I once had a test suite that was tightly coupled and used a lot of stubs. Everything was working until I changed the location of a file. All of a sudden, the tests ran in a different order and lots of tests started failing. I thought I had accurately restored all the stubs, but it was an illusion. The only reason the test passed was because they ran in a specific order.\par
\par
Don\rquote t be fooled by the shortness of the test suite. Tests that require a lot of external helpers, such as spies, mocks, and stubs, are a clue that your code is complex and may be tightly coupled. You should simplify your code.\par
Stubs, Mocks, Spies\par
\par
Even with your best efforts, you\rquote ll eventually need some helpers to test your code. Fortunately there are quite a few techniques to help you. The three big ones are stubs, mocks, and spies.\par
\par
In this example, you\rquote re working with stubs. You\rquote re overriding outside code and returning an explicit result. It\rquote s called a stub because you\rquote re removing all the underlying logic of the function and just declaring a result.\par
\par
Mocks are a little more complex. They stand in for the objects they\rquote re replacing, and you make assertions based on the messages they\rquote ll receive and the methods you\rquote ll call on them. For example, you may mock an object and assert that you\rquote ll call a format() method on your object with the argument jabberwocky.\par
\par
A crucial difference between mocks and stubs is that you set up the expectations before you call the code with mocks. Martin Fowler has a good article on the difference between mocks and stubs.[32]\par
\par
Spies are like mocks, but you check how they were called after you execute the code. If you called formatPrice() and wanted to make sure that getTaxInformation() was called once with an argument of Iowa, you\rquote d set up the stub with a spy and then, after calling formatPrice(), you\rquote d make assertions on the spy. If you look at the code for this book, you\rquote ll see an occasional spy.\par
\par
For more on mocks, spies, and stubs, Simon Coffey goes into detail on each, using Ruby as an example.[33]\par
\par
Fortunately, the fix for tightly coupled code is fairly simple. You simply pass in your external functions as arguments. Passing in dependencies as arguments is called dependency injection.\par
\par
 \par
\par
To decouple your code, pass getTaxInformation() as an argument. You don\rquote t need to change anything else in your code.\par
functions/test/test.js\par
\u8203? \tab\u8203?function\u8203? formatPrice(user, \{ price, location \}, getTaxInformation) \{\par
\u8203? \tab   \u8203?const\u8203? rate = getTaxInformation(location);\par
\u8203? \tab   \u8203?const\u8203? taxes = rate ? \u8203?`plus $\u8203?$\{price * rate\}\u8203? in taxes.`\u8203? : \u8203?'plus tax.'\u8203?;\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{user\}\u8203? your total is: \u8203?$\{price\}\u8203? \u8203?$\{taxes\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ formatPrice \};\par
\par
Now that you\rquote re using dependency injection, you don\rquote t need stubs. When you write your tests, you don\rquote t need to bypass an import. Instead, you pass a simple function that returns the value you want. It\rquote s a lot like stubbing but without any external dependencies. Your function now takes inputs, including another function, and returns outputs. Remember, you aren\rquote t testing getTaxInformation(). You\rquote re testing that formatPrice(), given certain inputs, will return a certain result.\par
\par
Here\rquote s your test:\par
functions/test/test.spec.js\par
\u8203? \tab\u8203?import\u8203? expect \u8203?from\u8203? \u8203?'expect'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?import\u8203? \{ formatPrice \} \u8203?from\u8203? \u8203?'./test'\u8203?;\par
\u8203? \tab\par
\u8203? \tab describe(\u8203?'format price'\u8203?, () => \{\par
\u8203? \tab   it(\u8203?'should return plus tax if no tax info'\u8203?, () => \{\par
\u8203? \tab     \u8203?const\u8203? item = \{ price: 30, location: \u8203?'Oklahoma'\u8203? \};\par
\u8203? \tab     \u8203?const\u8203? user = \u8203?'Aaron Cometbus'\u8203?;\par
\u8203? \tab     \u8203?const\u8203? message = formatPrice(user, item, () => \u8203?null\u8203?);\par
\u8203? \tab     expect(message).toEqual(\u8203?'Aaron Cometbus your total is: 30 plus tax.'\u8203?);\par
\u8203? \tab   \});\par
\u8203? \tab\par
\u8203? \tab   it(\u8203?'should return plus tax information'\u8203?, () => \{\par
\u8203? \tab     \u8203?const\u8203? item = \{ price: 30, location: \u8203?'Oklahoma'\u8203? \};\par
\u8203? \tab     \u8203?const\u8203? user = \u8203?'Aaron Cometbus'\u8203?;\par
\u8203? \tab     \u8203?const\u8203? message = formatPrice(user, item, () => 0.1);\par
\u8203? \tab     expect(message).toEqual(\u8203?'Aaron Cometbus your total is:\u8203?\par
\u8203? \tab\u8203?                            30 plus $3 in taxes.'\u8203?);\par
\u8203? \tab   \});\par
\u8203? \tab\});\par
\par
Notice that you require nothing except the function you\rquote re testing and the expect library. The tests are much easier to write, and they do a better job of getting your code down to a single responsibility.\par
\par
You may argue that dependency injection didn\rquote t solve the problem\emdash it moved the problem to another function.\par
\par
That\rquote s true. There are going to be some side effects, some input/output, in your code. The trick to writing testable code is to get that in as few places as possible.\par
\par
For example, you can move all your AJAX calls into a service. Then, when you need to use them in a function, you can inject a service that\rquote s easy to test rather than trying to mock AJAX responses (which is very difficult).\par
\par
The important thing to know is that there\rquote s a perception that writing tests is hard. That\rquote s just not true. If a test is hard to write, spend time rethinking your code. If your code isn\rquote t easy to test, you should change your code, not your tests.\par
\par
And don\rquote t get frustrated when you encounter other problems. Tightly coupled code is just one form of complexity. There are plenty of other code smells\emdash code that\rquote s technically correct but doesn\rquote t seem very clear\emdash  that sneak into tests. Joshua Mock wrote a good article on some of the other problems of testing JavaScript, and it\rquote s worth reading to learn more.[34]\par
\par
The best thing you can do is start writing tests today. If you need more examples, check out the code for this book. It has nearly 100% test coverage and has a variety of tests (including some with mocks and spies). If you want to learn more, check out Test Driving JavaScript Applications. [Sub16]\par
\par
In the next tip, we\rquote ll get back into the details of writing functions by further exploring arrow functions.\par
\par
Tip 33\tab Reduce Complexity with Arrow Functions\par
\par
In this tip, you\rquote ll learn how to use arrow functions to destructure arguments, return objects, and construct higher-order functions.\par
\par
You explored arrow functions once in Tip 20, \u8203? Simplify Looping with Arrow Functions \u8203?. It\rquote s time to take a deeper dive.\par
\par
As a reminder, arrow functions allow you to remove extraneous information, such as the function declaration, parentheses, return statements, even curly braces. Now you\rquote re going to see how to handle a few more concepts that you\rquote ve just learned, such as destructuring. You\rquote ll also get an introduction to new ideas that you\rquote ll explore further in future tips.\par
\par
Let\rquote s begin with destructuring. You\rquote re going to take an object that has a first and last name and combine them in a string. You can\rquote t get more simple than that.\par
functions/arrow/problem.js\par
\u8203? \tab\u8203?const\u8203? name = \{\par
\u8203? \tab   first: \u8203?'Lemmy'\u8203?,\par
\u8203? \tab   last: \u8203?'Kilmister'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getName(\{ first, last \}) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{first\}\u8203? \u8203?$\{last\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
That should be very easy to convert to an arrow function. Remove everything except the parameter and the template literal. Add a fat arrow, =>, and you should be done.\par
\par
Not quite. Everything is the same except the parameters. When you\rquote re using any kind of special parameter action\emdash destructuring, rest parameters, default parameters\emdash you still need to include the parentheses.\par
\par
This sounds trivial, but it will trip you up if you aren\rquote t aware. It\rquote s hard for the JavaScript engine to know if you\rquote re performing a function declaration and not an object declaration. You\rquote ll get an error like this:\par
functions/arrow/close.js\par
\u8203? \tab\u8203?const\u8203? getName = \{ first, last \} => \u8203?`\u8203?$\{first\}\u8203? \u8203?$\{last\}\u8203?`\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?// Error: Unexpected token '=>'. Expected ';' after variable declaration\u8203?\par
\par
And that\rquote s if you\rquote re lucky. If you try this in a Node.js REPL, it will just hang like you forgot to add a closing curly brace. It can be very confusing.\par
\par
The solution is simple: If you\rquote re using any special parameters, just wrap the parameter in parentheses as you normally would.\par
functions/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? comic = \{\par
\u8203? \tab   first: \u8203?'Peter'\u8203?,\par
\u8203? \tab   last: \u8203?'Bagge'\u8203?,\par
\u8203? \tab   city: \u8203?'Seattle'\u8203?,\par
\u8203? \tab   state: \u8203?'Washington'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? getName = (\{ first, last \}) => \u8203?`\u8203?$\{first\}\u8203? \u8203?$\{last\}\u8203?`\u8203?;\par
\u8203? \tab getName(comic);\par
\u8203? \tab\u8203?// Peter Bagge\u8203?\par
\par
If you\rquote re returning an object, you have to be careful when omitting the return statement. Because an arrow function can\rquote t tell whether the curly braces are for an object or to wrap a function body, you\rquote ll need to indicate the return object by wrapping the whole thing in parentheses.\par
functions/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? getFullName = (\{ first, last \}) => (\{ fullName: \u8203?`\u8203?$\{first\}\u8203? \u8203?$\{last\}\u8203?`\u8203? \});\par
\u8203? \tab getFullName(comic);\par
\u8203? \tab\u8203?// \{ fullName: 'Peter Bagge' \}\u8203?\par
\par
It gets even better. When you return a value using parentheses, you aren\rquote t limited to a single line. You can return multi-line items while still omitting the return statement.\par
functions/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? getNameAndLocation = (\{ first, last, city, state \}) => (\{\par
\u8203? \tab   fullName: \u8203?`\u8203?$\{first\}\u8203? \u8203?$\{last\}\u8203?`\u8203?,\par
\u8203? \tab   location: \u8203?`\u8203?$\{city\}\u8203?, \u8203?$\{state\}\u8203?`\u8203?,\par
\u8203? \tab\});\par
\u8203? \tab getNameAndLocation(comic);\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   fullName: 'Peter Bagge',\u8203?\par
\u8203? \tab\u8203?//   location: 'Seattle, Washington'\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
Finally, arrow functions are great ways to make higher-order functions\emdash functions that return other functions. You\rquote ll explore higher-order functions in upcoming tips, so for now, let\rquote s just see how to structure them.\par
\par
Because a higher-order function is merely a function that returns another function, the initial parameter is the same. And you can return a function from the body like you always would.\par
functions/arrow/problem.js\par
\u8203? \tab\u8203?const\u8203? discounter = discount => \{\par
\u8203? \tab   \u8203?return\u8203? price => \{\par
\u8203? \tab     \u8203?return\u8203? price * (1 - discount);\par
\u8203? \tab   \};\par
\u8203? \tab\};\par
\u8203? \tab\u8203?const\u8203? tenPercentOff = discounter(0.1);\par
\u8203? \tab tenPercentOff(100);\par
\u8203? \tab\u8203?// 90\u8203?\par
\par
Of course, because the return value is another function, you can leverage the implicit return to return the function without even needing extra curly braces. Try it out.\par
functions/arrow/arrow.js\par
\u8203? \tab\u8203?const\u8203? discounter = discount => price => price * (1 - discount);\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? tenPercentOff = discounter(0.1);\par
\u8203? \tab tenPercentOff(100);\par
\u8203? \tab\u8203?// 90;\u8203?\par
\par
If you\rquote re anything like me, you\rquote re probably already forgetting all about higher-order functions. When are you going to use them? Turns out, they can be very helpful. Not only are they great ways to lock in parameters, but they\rquote ll also help you take some of the ideas you\rquote ve already seen\emdash array methods, rest parameters\emdash even further.\par
\par
In all the examples, you invoked the higher-order functions by first assigning the returned function to a variable before calling that with another parameter. That\rquote s not necessary. You can call one function after the other by just adding the second set of parameters in parentheses right after the first. This essentially turns a higher-order function into a single function with two different parameter sets.\par
functions/arrow/arrow.js\par
\u8203? \tab discounter(0.1)(100);\par
\u8203? \tab\u8203?// 90\u8203?\par
\par
In the next tip, you\rquote ll see why using higher-order functions to keep parameters separate is such a game changer by learning how to create single responsibility parameters. \par
\par
Tip 34\tab Maintain Single Responsibility Parameters with Partially Applied Functions\par
\par
In this tip, you\rquote ll learn to keep parameters focused with partially applied functions.\par
\par
In the last tip, you saw how you can easily create higher-order functions with arrow functions. If you come from an object-oriented background or just haven\rquote t seen much code that uses higher-order functions, you may have problems understanding when you should use higher-order functions.\par
\par
Higher-order functions provide unique value by locking in parameters so you can complete the function later while still maintaining access to the original arguments. They also isolate parameters so you can keep intentions clear. In the next tip, you\rquote ll see more about locking in parameter data. In this tip, you\rquote ll see how you leverage higher-order functions to give parameters single responsibility.\par
\par
A higher-order function is a function that returns another function. What this means is that you have at least two rounds of parameters before the function is fully resolved. With a partially applied function, you pass some parameters and you get back a function that locks those parameters in place while taking more parameters. In other words, a partially applied function reduces the total number of arguments for a function\emdash also called the \ldblquote arity\rdblquote\emdash while giving you another function that needs a few more arguments.\par
\par
The takeaway is that you can have multiple sets of parameters that are independent of one another. Perhaps it seems like parameters already have single responsibility. They are, after all, the input data to the function so they must relate to one another. That\rquote s true, but even inputs have different relationships. Some inputs are related to one another while others are more independent.\par
\par
Think about an events page on a website. An event is going to occur in a specific space. Each event is unique, but the space isn\rquote t going to change radically between events. The address, name, building hours, and so on will be the same. In addition, spaces are managed by people who are points of contact, and they will seldom change between events.\par
\par
With that in mind, consider a function that needs to combine information about the space, the space manager, and an event on a page. You\rquote ll likely get each piece of information from a different source, and you\rquote ll need to combine them together to return the complete information.\par
\par
Here\rquote s a sample of the data you\rquote ll receive. The building has an address and hours. The manager has a name and phone number. Then you have two different event types. The first, a program, will have a specific hour range that\rquote s shorter than the building hours. The second, an exhibit, will be open as long as the building is open but will need the curator as a contact.\par
functions/partial/partial.js\par
\u8203? \tab\u8203?const\u8203? building = \{\par
\u8203? \tab   hours: \u8203?'8 a.m. - 8 p.m.'\u8203?,\par
\u8203? \tab   address: \u8203?'Jayhawk Blvd'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? manager = \{\par
\u8203? \tab   name: \u8203?'Augusto'\u8203?,\par
\u8203? \tab   phone: \u8203?'555-555-5555'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? program = \{\par
\u8203? \tab   name: \u8203?'Presenting Research'\u8203?,\par
\u8203? \tab   room: \u8203?'415'\u8203?,\par
\u8203? \tab   hours: \u8203?'3 - 6'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? exhibit = \{\par
\u8203? \tab   name: \u8203?'Emerging Scholarship'\u8203?,\par
\u8203? \tab   contact: \u8203?'Dyan'\u8203?,\par
\u8203? \tab\};\par
\par
At this point, you just need to write a simple function that takes three arguments\emdash building, manager, program/event\emdash and combines them into one set of information.\par
functions/partial/problem.js\par
\u8203? \tab\u8203?function\u8203? mergeProgramInformation(building, manager, program) \{\par
\u8203? \tab   \u8203?const\u8203? \{ hours, address \} = building;\par
\u8203? \tab   \u8203?const\u8203? \{ name, phone \} = manager;\par
\u8203? \tab   \u8203?const\u8203? defaults = \{\par
\u8203? \tab     hours,\par
\u8203? \tab     address,\par
\u8203? \tab     contact: name,\par
\u8203? \tab     phone,\par
\u8203? \tab   \};\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? \{ ...defaults, ...program \};\par
\u8203? \tab\}\par
\par
Notice every time you call the function for a building, you have to pass the same first parameters. The function call is repetitive.\par
functions/partial/problem.js\par
\u8203? \tab\u8203?const\u8203? programInfo = mergeProgramInformation(building, manager, program);\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? exhibitInfo = mergeProgramInformation(building, manager, exhibit);\par
\par
This repetition is a clue that your function has a natural division. The first two parameters are establishing a base for a building, which is then applied to a series of programs and exhibits.\par
\par
A higher-order function can create single responsibility parameters, allowing you to reuse the first two arguments. The responsibility of the first set of parameters is to gather baseline data. The second set will be the custom information that overrides the baseline.\par
\par
To accomplish this, you need to make the top function take only two parameters\emdash the building and the manager\emdash and have it return a function that takes only one parameter\emdash a program (which could be a program, an event, an exhibit, and so on).\par
functions/partial/partial.js\par
\u8203? \tab\u8203?function\u8203? mergeProgramInformation(building, manager) \{\par
\u8203? \tab   \u8203?const\u8203? \{ hours, address \} = building;\par
\u8203? \tab   \u8203?const\u8203? \{ name, phone \} = manager;\par
\u8203? \tab   \u8203?const\u8203? defaults = \{\par
\u8203? \tab     hours,\par
\u8203? \tab     address,\par
\u8203? \tab     contact: name,\par
\u8203? \tab     phone,\par
\u8203? \tab   \};\par
\u8203? \tab\par
\u8203? \tab   \u8203?return\u8203? program => \{\par
\u8203? \tab     \u8203?return\u8203? \{ ...defaults, ...program \};\par
\u8203? \tab   \};\par
\u8203? \tab\}\par
\par
This can look intimidating, but it\rquote s actually simple. Again, a higher-order function is just a function that needs to be called multiple time before it\rquote s fully resolved. That\rquote s all. To invoke both parts of the functions in a single call, all you have to do is put parentheses right after one another. This invokes the outer function, then immediately invokes the inner function. The result is the same as before.\par
functions/partial/partial.js\par
\u8203? \tab\u8203?const\u8203? programInfo = mergeProgramInformation(building, manager)(program);\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//    name: 'Presenting Research',\u8203?\par
\u8203? \tab\u8203?//    room: '415',\u8203?\par
\u8203? \tab\u8203?//    hours: '3 - 6',\u8203?\par
\u8203? \tab\u8203?//    address: 'Jayhawk Blvd',\u8203?\par
\u8203? \tab\u8203?//    contact: 'Augusto',\u8203?\par
\u8203? \tab\u8203?//    phone: '555-555-5555'\u8203?\par
\u8203? \tab\u8203?//  \}\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? exhibitInfo = mergeProgramInformation(building, manager)(exhibit);\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//    name: 'Emerging Scholarship',\u8203?\par
\u8203? \tab\u8203?//    contact: 'Dyan'\u8203?\par
\u8203? \tab\u8203?//    hours: '8 a.m. - 8 p.m.',\u8203?\par
\u8203? \tab\u8203?//    address: 'Jayhawk Blvd'\u8203?\par
\u8203? \tab\u8203?//    phone: '555-555-5555'\u8203?\par
\u8203? \tab\u8203?//  \}\u8203?\par
\par
You may have given the parameters a single responsibility, but it doesn\rquote t eliminate the repetition. Fortunately, with partial application, you can get around that problem also. You\rquote ll see how you can reuse a returned function in the next tip.\par
\par
To finish up, there\rquote s another reason to use partial application and higher-order functions to give your parameters single responsibility: you can reuse the rest operator.\par
\par
As you probably remember from Tip 31, \u8203? Pass a Variable Number of Arguments with the Rest Operator \u8203?, nothing can come after the rest parameter. In other words, you can only have a single rest parameter in a set of arguments. That\rquote s fine most of the time, but occasionally you\rquote ll have a situation where you want to have multiple rest parameters.\par
\par
This comes up often when you have an array of data and more data that has a one-to-one correspondence with your original data.\par
\par
For example, if you have a function that takes an array of states and returns the state bird, the resulting array is nice, but you\rquote ll eventually need to connect the original and the result together into a nice array of pairs.\par
functions/partial/partial.js\par
\u8203? \tab\u8203?const\u8203? birds = getBirds(\u8203?'kansas'\u8203?, \u8203?'wisconsin'\u8203?, \u8203?'new mexico'\u8203?);\par
\u8203? \tab\u8203?// ['meadowlark', 'robin', 'roadrunner']\u8203?\par
\par
Combining two arrays into pairs is so common that it has a name: \ldblquote zip.\rdblquote\par
\par
To write a zip function that can take multiple parameters, you need to write a higher-order function that takes the original array (call it left), returns a function that takes the results array (right), and combines them. Guess what? Because the parameters are independent, you can use your rest parameters both times.\par
functions/partial/partial.js\par
\u8203? \tab\u8203?const\u8203? zip = (...left) => (...right) => \{\par
\u8203? \tab   \u8203?return\u8203? left.map((item, i) => [item, right[i]]);\par
\u8203? \tab\};\par
\u8203? \tab zip(\u8203?'kansas'\u8203?, \u8203?'wisconsin'\u8203?, \u8203?'new mexico'\u8203?)(...birds);\par
\u8203? \tab\u8203?// [\u8203?\par
\u8203? \tab\u8203?//   ['kansas', 'meadowlark'],\u8203?\par
\u8203? \tab\u8203?//   ['wisconsin', 'robin'],\u8203?\par
\u8203? \tab\u8203?//   ['new mexico', 'roadrunner']\u8203?\par
\u8203? \tab\u8203?// ]\u8203?\par
\par
This isn\rquote t a technique you\rquote ll use often, but it\rquote s very valuable when you want to keep an interface clear. Sometimes parameters just don\rquote t belong together, yet you still need all the information. Partially applied functions are a great way to combine parameters without a lot of effort.\par
\par
In the next tip, you\rquote ll go even further and learn how you can invoke a function once to capture information and then reuse it over and over again.\par
\par
Tip 35\tab Combine Currying and Array Methods for Partial Application\par
\par
In this tip, you\rquote ll learn to lock in variables with partial application of functions.\par
\par
In the previous tip, you saw how you can give parameters a single responsibility with higher-order functions and partial application. It solved the problem of having unrelated parameters, but it didn\rquote t solve the problem of using the same parameters over and over. You still passed in the same parameters multiple times.\par
\par
With higher-order functions, you can avoid repetition by creating a new function with values you lock in once and use later. When you return a higher-order function, you don\rquote t have to invoke it right away. After you invoke it once, you have another pre-made function that you can use over and over. It\rquote s like you wrote it with the argument hard-coded.\par
\par
To reuse the building and manager from the previous tip, you can assign the return value from the first function call to a variable. You now have a pre-built function with some information locked in place.\par
\par
Invoking it once and reusing the captured parameters is no different from declaring a function knowing the inside variables ahead of time. These are equivalent.\par
functions/partial/program.js\par
\u8203? \tab\u8203?const\u8203? setStrongHallProgram = mergeProgramInformation(building, manager);\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? programInfo = setStrongHallProgram(program);\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? exhibitInfo = setStrongHallProgram(exhibit);\par
functions/curry/higherorder.js\par
\u8203? \tab\u8203?const\u8203? setStrongHallProgram = program => \{\par
\u8203? \tab   \u8203?const\u8203? defaults = \{\par
\u8203? \tab     hours: \u8203?'8 a.m. - 8 p.m.'\u8203?,\par
\u8203? \tab     address: \u8203?'Jayhawk Blvd'\u8203?,\par
\u8203? \tab     name: \u8203?'Augusto'\u8203?,\par
\u8203? \tab     phone: \u8203?'555-555-5555'\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? \{ ...defaults, ...program\}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? programs = setStrongHallProgram(program);\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? exhibit = setStrongHallProgram(exhibit);\par
\par
You built the first function with partial application of a higher-order function. You built the second function with hard-coded information. A higher-order function that takes two rounds of arguments will be more flexible than the one with hard-coded information, but it helps to think about how they\rquote re similar.\par
\par
You know higher-order functions can keep parameters separate, but they have an even more important use: separating arguments so that you can reduce the number of arguments that a function needs before it\rquote s fully resolved. Building functions that take only one argument at a time is called \ldblquote currying,\rdblquote  and it\rquote s an invaluable technique when you\rquote re working with methods that pass only one argument. And although currying in its pure form isn\rquote t fully supported in JavaScript,[35] partially applying a function to reduce parameters to a series of single parameters is common.\par
Currying and Partial Application\par
\par
Partially applied functions can take multiple rounds of parameters. This is often confused with currying. And it\rquote s true that currying and partial application are very similar, but they\rquote re different.\par
\par
Partially applied functions and curried functions both reduce the number of arguments by returning functions that need fewer arguments than the original. The total number of arguments for a function to fully resolve is called the arity. A partially applied function returns a function that has a smaller arity than the original function. If you need three total arguments and you pass two, the returned function will need only one argument. The original function had a total arity of three. With partial application, you returned a function with an arity of one.\par
\par
Currying, by contrast, is when you take a function that would require multiple arguments and return a series of functions that take exactly one argument. If you had a function that requires three arguments to resolve, you\rquote d need a higher-order function that takes one argument and returns a function that takes one argument, which returns a function that takes one argument that finally resolves.\par
\par
Think back to when you were filtering an array of dogs in Tip 22, \u8203? Create Arrays of a Similar Size with map() \u8203?. At that point, you only added the filters\emdash you never applied them. Here\rquote s a slightly modified version of your array of dogs.\par
functions/curry/curry.js\par
\u8203? \tab\u8203?const\u8203? dogs = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'max'\u8203?,\par
\u8203? \tab     weight: 10,\par
\u8203? \tab     breed: \u8203?'boston terrier'\u8203?,\par
\u8203? \tab     state: \u8203?'wisconsin'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'don'\u8203?,\par
\u8203? \tab     weight: 90,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     state: \u8203?'kansas'\u8203?,\par
\u8203? \tab     color: \u8203?'black'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'shadow'\u8203?,\par
\u8203? \tab     weight: 40,\par
\u8203? \tab     breed: \u8203?'labrador'\u8203?,\par
\u8203? \tab     state: \u8203?'wisconsin'\u8203?,\par
\u8203? \tab     color: \u8203?'chocolate'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\par
Try to write a function that takes the dogs and a filter and returns just the names of the dogs that match the filter.\par
\par
Pass the dogs as the first parameter and use a combination of array methods\emdash filter() and map()\emdash to get the final result set.\par
functions/curry/problem.js\par
\u8203? \tab\u8203?function\u8203? getDogNames(dogs, filter) \{\par
\u8203? \tab   \u8203?const\u8203? [key, value] = filter;\par
\u8203? \tab   \u8203?return\u8203? dogs\par
\u8203? \tab     .filter(dog => dog[key] === value)\par
\u8203? \tab     .map(dog => dog.name);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, [\u8203?'color'\u8203?, \u8203?'black'\u8203?]);\par
\u8203? \tab\u8203?// ['max', 'don']\u8203?\par
\par
This function looks pretty good, but it\rquote s actually severely limited. There are two issues.\par
\par
First, your filter function is constrained. It will work only when you\rquote re doing an exact comparison between a filter and each individual dog. In other words, it works only when using ===. What if you need to do a different comparison, such as finding all the dogs below a certain weight?\par
\par
Second, the map, like all array methods, can take only one argument\emdash the item being checked\emdash so you have to somehow get your other variables in scope. Because map is a function inside another function, it has access to the variables in the wrapper function. That means you\rquote ll need to figure out how to pass them in as parameters to the outside function.\par
\par
Start by trying to solve the first problem. Rewrite the function so that you can find all dogs below a certain weight. As you saw in Tip 32, \u8203?Write Functions for Testability \u8203?, you can inject functions into other functions. Start there. Instead of hard coding a comparison function, pass in the filter function as a callback.\par
functions/curry/curry.js\par
\u8203? \tab\u8203?function\u8203? getDogNames(dogs, filterFunc) \{\par
\u8203? \tab   \u8203?return\u8203? dogs\par
\u8203? \tab   .filter(filterFunc)\par
\u8203? \tab   .map(dog => dog.name)\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, dog => dog.weight < 20);\par
\u8203? \tab\u8203?// ['max']\u8203?\par
\par
You\rquote re partway there, but you\rquote re still forced to hard code a value, the number 20 in this case. This means you\rquote ll still have to either code the value by hand or make sure there are no scope conflicts if you\rquote re using a variable. This may not seem like a big deal, but scope conflicts creep in when you least expect them. It\rquote s much better to inject values in a function rather than trust them to be able to access variables in an upper scope at runtime.\par
\par
The goal is to have a partially applied function with some values locked in. You can assign a partially applied function to a variable and pass it as data to another function, which can then provide the remaining arguments.\par
\par
At this point, you don\rquote t even need to rewrite your getDogNames() function. It takes any comparison function, so you\rquote re all set. What you do need to do is rewrite your comparison function so that you don\rquote t need to hard code the comparison value.\par
\par
Use the technique from the previous tip to create two sets of arguments\emdash the first argument will be a weight, the second set will be the individual dog.\par
\par
Now you can apply the function first with one weight and another time with a different weight. The actual number will be locked in the function. This means you can reuse the function over and over with different weights. Scope conflicts will be much less likely.\par
functions/curry/curry.js\par
\u8203? \tab\u8203?const\u8203? weightCheck = weight => dog => dog.weight < weight;\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, weightCheck(20));\par
\u8203? \tab\u8203?// ['max']\u8203?\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, weightCheck(50));\par
\u8203? \tab\u8203?// ['max', 'shadow']\u8203?\par
\par
By currying the function, you\rquote ve made it so you can pass multiple parameters at different points. You\rquote re also able to pass a function around as data.\par
\par
And the best part is you don\rquote t need to limit yourself to just two functions and two sets of arguments. What if you wanted to rewrite your original comparison function using currying?\par
\par
First, you\rquote d pass in the field you want to compare, such as color. In the next function, you\rquote d pass the value you want to compare against, such as black. The final function takes the individual dog.\par
\par
The result is a set of comparisons you build up using the same logic but different parameters.\par
functions/curry/curry.js\par
\u8203? \tab\u8203?const\u8203? identity = field => value => dog => dog[field] === value;\par
\u8203? \tab\u8203?const\u8203? colorCheck = identity(\u8203?'color'\u8203?);\par
\u8203? \tab\u8203?const\u8203? stateCheck = identity(\u8203?'state'\u8203?);\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, colorCheck(\u8203?'chocolate'\u8203?));\par
\u8203? \tab\u8203?// ['shadow']\u8203?\par
\u8203? \tab\par
\u8203? \tab getDogNames(dogs, stateCheck(\u8203?'kansas'\u8203?));\par
\u8203? \tab\u8203?// ['don']\u8203?\par
\par
Now think about what you\rquote ve created. You took a function that had specific requirements and made something abstract that can take many different comparisons. Because you can assign partially applied functions to variables, they\rquote re now just another piece of data you can pass around. This means you can build very sophisticated comparisons using a small set of simple tools.\par
\par
For example, if you only wanted dogs that meet every criteria, you can pass an array of checks and use the every() array method, which returns true if all values return true.\par
\par
If you only wanted the dogs that meet at least one criteria, you can write a function that uses the some() array method, which returns true if any value returns true.\par
functions/curry/curry.js\par
\u8203? \tab\u8203?function\u8203? allFilters(dogs, ...checks) \{\par
\u8203? \tab   \u8203?return\u8203? dogs\par
\u8203? \tab   .filter(dog => checks.every(check => check(dog)))\par
\u8203? \tab   .map(dog => dog.name);\par
\u8203? \tab\}\par
\u8203? \tab allFilters(dogs, colorCheck(\u8203?'black'\u8203?), stateCheck(\u8203?'kansas'\u8203?));\par
\u8203? \tab\u8203?// ['Don']\u8203?\par
\u8203? \tab\u8203?function\u8203? anyFilters(dogs, ...checks) \{\par
\u8203? \tab   \u8203?return\u8203? dogs\par
\u8203? \tab   .filter(dog => checks.some(check => check(dog)))\par
\u8203? \tab   .map(dog => dog.name);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab anyFilters(dogs, weightCheck(20), colorCheck(\u8203?'chocolate'\u8203?));\par
\u8203? \tab\u8203?// ['max', 'shadow']\u8203?\par
\par
Does that make your head spin? Hopefully not. Copy the code into a REPL and try playing with it. That\rquote s the best way to learn. Just remember this: If you have functions that can\rquote t take more than one argument, currying is a great tool. It makes otherwise complicated problems very straightforward.\par
\par
In the next tip, you\rquote ll see a problem related to variable scope\emdash context. You\rquote ll learn how to use arrow functions to solve nagging problems related to the this keyword.\par
\par
Tip 36\tab Prevent Context Confusion with Arrow Functions\par
\par
In this tip, you\rquote ll learn how to use the arrow function to avoid context errors.\par
\par
Scope and context are probably the two most confusing concepts for JavaScript developers. A function\rquote s scope, at it simplest, is what variables the functions can access. We explored this previously in Tip 3, \u8203? Isolate Information with Block Scoped Variables \u8203?. Now you\rquote re going to learn about context. Context is what the keyword this refers to in a function or class.\par
\par
Not only are both concepts hard to grasp, but people often confuse them. I know I confuse them all the time. Ryan Morr gives a simple way to remember the difference: Scope pertains to functions and context pertains to objects.[36] While that\rquote s not 100 percent true\emdash you can use this in any function\emdash it\rquote s a good general rule.\par
\par
To understand context, start with a very simple object. For example, think about an object called Validator, which sets an invalid message on form fields. You have one property, message, and one method, setInvalidMessage().\par
\par
In the setInvalidMessage() method, you can refer to the message property using this.message. To see it in action, call the method from the object.\par
functions/context/basic.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessage(field) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab validator.setInvalidMessage(\u8203?'city'\u8203?);\par
\u8203? \tab\u8203?// city is invalid.\u8203?\par
\par
As you see, this.message refers to the property on the object. This works because, when the method is called from the object, the function creates a this binding with the containing object as context.\par
\par
Now before you go any further, you should know that concepts surrounding the keyword this are pretty complex. There\rquote s a whole book in the You Don\rquote t Know JS [Sim14] series on the subject. This book is mandatory reading for JavaScript developers, and there\rquote s no way to cover the same level of information here in one tip. Instead, you\rquote re going to see one of the most common context mistakes.\par
\par
Working with this on objects usually isn\rquote t a problem until you try to use a function as callback for another function.\par
\par
For example, you\rquote ll encounter problems with this when using setTimeout(), setInterval(), or your favorite array methods such as map() or filter(). Each of these functions takes a callback, which, as you\rquote ll see, changes the context of the callback.\par
\par
What do you think will happen if you try to refactor your setInvalidMessage() method to take an array of fields using map() to add the message? The code change isn\rquote t complicated. Create a new method called setInvalidMessages() that maps over an array adding the message to each.\par
functions/context/problem.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?function\u8203? (field) \{\par
\u8203? \tab       \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab     \});\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\par
The problem is that when you invoke the function, you\rquote ll get either a TypeError or undefined. This is where most developers get frustrated and refactor the code to remove a reference to this.\par
functions/context/context.spec.js\par
\u8203? \tab validatorProblem.setInvalidMessages(field);\par
\u8203? \tab\u8203?// TypeError: Cannot read property 'message' of undefined\u8203?\par
\par
Think for a moment about what may cause this problem. Remember that whenever you call a function, it creates a this binding based on where it\rquote s called. setInvalidMessage() was called in the context of an object. The this context was the object. The callback for the map function is called in the context of the map() method, so the this binding is no longer the Validator object. It will actually be the global object: window in a browser and the Node.js environment in a REPL. The callback doesn\rquote t have access to the message property.\par
\par
This is where arrow functions come in. Arrow functions don\rquote t create a new this binding when you use them. If you were to rewrite the preceding map() callback using an arrow function, everything would work as expected.\par
functions/context/context.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(field => \{\par
\u8203? \tab       \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab     \});\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab validator.setInvalidMessages(\u8203?'city'\u8203?);\par
\u8203? \tab\u8203?// ['city is invalid.]\u8203?\par
\par
Now this may seem great and a good reason to always use arrow functions. But remember, sometimes you actually do want to set a this context.\par
\par
For example, what if you wrote your original setInvalidMessage() method not as a named method but as an arrow function assigned to a property?\par
functions/context/method.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessage: field => \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?,\par
\u8203? \tab\};\par
\par
You\rquote d have the exact same TypeError when you called it.\par
functions/context/context.spec.js\par
\u8203? \tab validatorMethod.setInvalidMessage(field);\par
\u8203? \tab\u8203?// TypeError: Cannot read property 'message' of undefined\u8203?\par
\par
In this case, you didn\rquote t create a new this context binding to the current object. Because you didn\rquote t create a new context, you\rquote re still bound to the global object.\par
\par
To summarize, arrow functions are great when you already have a context and want to use the function inside another function. They\rquote re a problem when you need to set a new this binding.\par
\par
This isn\rquote t the last you\rquote ll see of this. It plays a big part in classes, and context bindings will come up again in Tip 42, \u8203? Resolve Context Problems with Bind() \u8203?.\par
\par
The next chapter explores classes in JavaScript. If you come from an object-oriented background, you\rquote ll see a lot that looks familiar and a lot that you won\rquote t expect.\par
Footnotes\par
\par
[28]\par
\par
    {{\field{\*\fldinst{HYPERLINK http://www.nytimes.com/2005/10/20/garden/cheap-its-chic-but-is-it-good.html }}{\fldrslt{http://www.nytimes.com/2005/10/20/garden/cheap-its-chic-but-is-it-good.html\ul0\cf0}}}}\f1\fs22\par
[29]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://jasmine.github.io }}{\fldrslt{https://jasmine.github.io\ul0\cf0}}}}\f1\fs22\par
[30]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://mochajs.org }}{\fldrslt{https://mochajs.org\ul0\cf0}}}}\f1\fs22\par
[31]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://facebook.github.io/jest/ }}{\fldrslt{https://facebook.github.io/jest/\ul0\cf0}}}}\f1\fs22\par
[32]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://martinfowler.com/articles/mocksArentStubs.html }}{\fldrslt{https://martinfowler.com/articles/mocksArentStubs.html\ul0\cf0}}}}\f1\fs22\par
[33]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://about.futurelearn.com/blog/stubs-mocks-spies-rspec }}{\fldrslt{https://about.futurelearn.com/blog/stubs-mocks-spies-rspec\ul0\cf0}}}}\f1\fs22\par
[34]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://www.toptal.com/javascript/writing-testable-code-in-javascript }}{\fldrslt{https://www.toptal.com/javascript/writing-testable-code-in-javascript\ul0\cf0}}}}\f1\fs22\par
[35]\par
\par
    {{\field{\*\fldinst{HYPERLINK http://2ality.com/2017/11/currying-in-js.html }}{\fldrslt{http://2ality.com/2017/11/currying-in-js.html\ul0\cf0}}}}\f1\fs22\par
[36]\par
\par
    {{\field{\*\fldinst{HYPERLINK http://ryanmorr.com/understanding-scope-and-context-in-javascript/ }}{\fldrslt{http://ryanmorr.com/understanding-scope-and-context-in-javascript/\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 8\par
Keep Interfaces Clear with Classes\par
\par
An octopus has a brain. But in a way, it has many brains. Neurons run throughout an octopus\rquote s body, so in a sense, it can think with its arms. If its arm is removed from its body, it can still respond to stimulus, change color, and reach and grab for items.\par
\par
This poses a challenge to researchers. An octopus can think, but not in the way mammals do. It responds similarly\emdash it can remember specific people, prefer certain types of food, and even plan an escape\emdash but the way its consciousness works is unusual. An octopus\rquote s mind is similar but different.\par
\par
In this chapter, we\rquote re going to explore concepts that are familiar, but they\rquote re also different. Developers have been complaining for years about these differences\emdash they say JavaScript is broken because it doesn\rquote t behave like other object-oriented languages. The problem isn\rquote t that it\rquote s different. It\rquote s that it\rquote s just similar enough to create confusion.\par
\par
In ES6+, things have gotten even more confusing because now JavaScript uses familiar syntax\emdash class, extend,static\emdash but the code doesn\rquote t always act as you\rquote d expect if you come from another object-oriented language. In this chapter, you\rquote re going to recognize how classes in JavaScript are different even while they use many familiar concepts.\par
\par
To start off, you\rquote ll build and extend a class. This will look similar to most object-oriented languages. After that, you\rquote ll see how classes work under the hood by combining class syntax and JavaScript prototypes. Next, you\rquote ll learn how to mask complexity with getters, setters, and generators. Finally, you will return to common problems with the this keyword and techniques for solving them.\par
\par
Remember that classes in JavaScript are a little different, but they still retain many of the benefits\emdash and some of the problems\emdash of class syntax. Classes will help you organize your code, build new instances of objects, and store local properties. Just keep in mind that JavaScript is its own language with a unique history and paradigm. Learn how you can use classes to fuse your existing knowledge of both JavaScript and other object-oriented languages.\par
\par
Tip 37\tab Build Readable Classes\par
\par
In this tip, you\rquote ll learn how to create extendable classes in JavaScript.\par
\par
One of the longest running criticisms of JavaScript was that it lacked a class syntax. Well it\rquote s here! But it didn\rquote t arrive without controversy. Proponents of classes argue it\rquote s a common development paradigm that\rquote s very familiar to developers in other languages. Skeptics think it obscures the underlying nature of the language and encourages bad habits.\par
\par
Like many controversies, the rhetoric is excessive. Classes are now part of JavaScript, and if you use any popular framework such as Angular or React, you\rquote ll introduce them in your code. And that\rquote s great.\par
\par
As you\rquote ll see in Tip 39, \u8203? Extend Existing Prototypes with Class \u8203?, the base language hasn\rquote t changed. JavaScript is still a prototype-based language. Now you have familiar syntax masking slightly complicated concepts. As a result, there are some surprises.\par
\par
In this tip, you\rquote ll get a quick look at how to write classes in JavaScript. If you\rquote ve written classes in any other language, the interface should seem pretty familiar.\par
\par
To start off, make a class called Coupon. You declare a class with the class keyword. You can then create new instances using the new keyword.\par
classes/constructor/problem.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon();\par
\par
When you create an instance of a class, the first thing you\rquote re doing is running a constructor function, which can define a number of properties. You aren\rquote t forced to declare a constructor function, but it\rquote s where you will declare your properties, so you\rquote ll write one in most cases.\par
\par
The next step is to create a constructor method. You\rquote ll need to name it constructor(). Add it to the class using what looks like function syntax, but without the function keyword. Because the constructor is a function, you can pass as many arguments as you want.\par
\par
Part of the job of the constructor is creating a this context. Inside your constructor, you add properties to a class by assigning them to this with a key like you would if you were adding key-values to an object. And because you\rquote re able to pass arguments to the constructor, you can dynamically set properties when you create a new instance. Currently, you are required to set all properties inside the constructor. That will likely change in the future.\par
\par
For now, set two properties on your Coupon: price and expiration. After setting the properties, you can call them using the familiar dot syntax or even array syntax. Remember that this is still JavaScript, and you\rquote re still working with objects.\par
classes/constructor/constructor.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 5\u8203?\par
\u8203? \tab coupon[\u8203?'expiration'\u8203?];\par
\u8203? \tab\u8203?// 'Two Weeks'\u8203?\par
\par
Note that you aren\rquote t declaring properties as public or private. Currently, everything is public. Private fields\emdash properties or methods\emdash are working their way through the TC39 committee.\par
\par
The class and object instance are getting a little more interesting, but they still can\rquote t do much. The next step is to add two simple methods: getPriceText() to return a formatted price and getExpirationMessage() to get a formatted message.\par
\par
You can add methods using the same syntax as a constructor. The methods will be normal functions, not arrow functions. This may not seem like a big deal, but arrow functions behave differently in classes than normal functions, just as you saw in Tip 36, \u8203? Prevent Context Confusion with Arrow Functions \u8203?. You\rquote ll see how to use arrow functions in classes in Tip 42, \u8203? Resolve Context Problems with Bind() \u8203?.\par
\par
Speaking of context. You have full access to the this context in the methods if you call them directly on an instance of a class. This will work as predicted most of the time. You\rquote ll see the exceptions in upcoming tips.\par
\par
This means that you can create methods that refer to properties or other methods.\par
classes/constructor/methods.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getPriceText() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`$ \u8203?$\{\u8203?this\u8203?.price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getExpirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?.`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.getPriceText();\par
\u8203? \tab\u8203?// '$ 5'\u8203?\par
\u8203? \tab coupon.getExpirationMessage();\par
\u8203? \tab\u8203?// 'This offer expires in two weeks.'\u8203?\par
\par
Now that you have a very basic but useful class, you can create a new object using a constructor function that sets up a this binding. You can call methods and access properties. And everything uses an intuitive interface. The basics are familiar, but it\rquote s important you note the quirks, particularly in regard to setting properties. You\rquote re building objects, so you\rquote ll still encounter some context and scope issues.\par
\par
In the next tip, you\rquote ll see how to share code between classes using inheritance.\par
\par
Tip 38\tab Share Methods with Inheritance\par
\par
In this tip, you\rquote ll learn how to extend classes and call parent methods.\par
\par
In the previous tip, you learned how to create basic classes with properties and methods. You may recall that classes in JavaScript were highly anticipated and slightly dreaded. The core of the controversy is inheritance.\par
\par
Inheriting methods on prototypes was a pretty complex process in early versions of JavaScript. First, you had to loop through the properties on an object; then, you had to check to see that each property existed specifically on an object as a property and not on the object prototype. Then you had to copy the prototype from the parent to a new object before adding further methods.\par
\par
It was hard.\par
\par
With classes, inheritance is easy. Still, in recent years, JavaScript developers have soured on inheritance. They argue that too much inheritance is a bad thing and that it leads to bloated code. There are other techniques for sharing methods that don\rquote t require inheritance (such as composition). In other words, use inheritance with caution.\par
\par
How does inheritance work? Return to your Coupon class. Suppose you want a FlashCoupon that has deeper discounts but a shorter time span. To create that class, simply declare a new class called FlashCoupon that inherits from the Coupon class using the extends keyword.\par
\par
Your new FlashCoupon class inherits all the existing properties and methods. For example, you can access the price and the getPriceText() method.\par
classes/extend/basic.js\par
\u8203? \tab\u8203?import\u8203? Coupon \u8203?from\u8203? \u8203?'./extend'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?class\u8203? FlashCoupon \u8203?extends\u8203? Coupon \{\par
\u8203? \tab\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? flash = \u8203?new\u8203? FlashCoupon(10);\par
\u8203? \tab\par
\u8203? \tab flash.price;\par
\u8203? \tab\u8203?// 10\u8203?\par
\u8203? \tab\par
\u8203? \tab flash.getPriceText();\par
\u8203? \tab\u8203?// "$ 10"\u8203?\par
\par
Of course, there\rquote s really no point in inheriting code if you aren\rquote t going to add new properties or methods. To make this coupon different, add a new default expiration. Make the new default expiration \ldblquote two hours\rdblquote  instead of \ldblquote two weeks.\rdblquote\par
\par
To make the change, set up a constructor function that takes price and expiration, as you did on the parent. In this constructor, you\rquote ll need to call super() to access the parent constructor. super() calls the parent constructor, so pass through any arguments the parent constructor might need. In this case, you\rquote ll need to pass the price to the parent constructor. After that, you can set any new properties or override any properties that the parent constructor might set.\par
\par
For the FlashCoupon, you\rquote re setting the expiration, but you don\rquote t need to worry about setting the price. The parent constructor takes care of that.\par
classes/extend/constructor.js\par
\u8203? \tab\u8203?import\u8203? Coupon \u8203?from\u8203? \u8203?'./extend'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?class\u8203? FlashCoupon \u8203?extends\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?super\u8203?(price);\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two hours'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? flash = \u8203?new\u8203? FlashCoupon(10);\par
\u8203? \tab\par
\u8203? \tab flash.price;\par
\u8203? \tab\u8203?// 10\u8203?\par
\u8203? \tab\par
\u8203? \tab flash.getExpirationMessage();\par
\u8203? \tab\u8203?// "This offer expires in two hours"\u8203?\par
\par
You\rquote re using the parent getExpirationMessage() method, but you\rquote re using the child\rquote s expiration property. When you call getExpirationMessage(), you\rquote ll see the familiar message with the new default expiration.\par
\par
Of course, you may not like that message. This is a flash coupon after all. You should alert your users that this coupon is special. Any time you call a method, the JavaScript engine first checks to see if the method exists on the current class. If not, the engine goes up the chain, checking each class or prototype along the way. This means you can override any method by creating a new method with the same name.\par
\par
Try adding a new method called getExpirationMessage() to the FlashCoupon class. This method will be the same as the parent method except that it returns a message of This is a flash offer and expires in $\{this.expiration\}.\par
\par
At this point, you\rquote ve created a class that inherits methods and properties. You called the parent constructor to set some properties and overrode other properties. You also wrote methods that override parent methods.\par
\par
The last step is to write methods that invoke the parent methods. To start, add two new methods to your Coupon class. First, add the method getRewards(), which takes a user and then calls isRewardsEligible() to find out if the user is eligible for further discounts. If the user is eligible for further discounts, reduce the price.\par
\par
As a warning, any method you add to a parent class is inherited by a child class. This can be a huge benefit, but it\rquote s also easy to create bloat in child classes by adding methods to parents that aren\rquote t necessary in child classes.\par
classes/extend/extend.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'Two Weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getPriceText() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`$ \u8203?$\{\u8203?this\u8203?.price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getExpirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   isRewardsEligible(user) \{\par
\u8203? \tab     \u8203?return\u8203? user.rewardsEligible && user.active;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getRewards(user) \{\par
\u8203? \tab     \u8203?if\u8203? (\u8203?this\u8203?.isRewardsEligible(user)) \{\par
\u8203? \tab       \u8203?this\u8203?.price = \u8203?this\u8203?.price * 0.9;\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? Coupon;\par
\par
Giving users a discount is great, but because flash coupons are an even bigger savings, you\rquote ll probably want to give eligible users a larger discount on flash coupons. But you don\rquote t want to give away too much. Instead, you only want to give your eligible users a discount if the previous conditions are met, a user is active and is rewards-eligible, and the base price of the item is $20 or more.\par
\par
To add this in, first create a method of the same name in the FlashCoupon class. Then, in the isRewardsEligible() method, first call the parent method by calling the method name on super(). After that, add your additional code. Note that super() in the constructor doesn\rquote t need a specific method call, but if you want to call any other methods on the parent class, you\rquote ll have to specify them, even when they\rquote re in a method of the same name.\par
\par
The result is a class that inherits some properties and functions from a parent while overriding others.\par
classes/extend/flash.js\par
\u8203? \tab\u8203?import\u8203? Coupon \u8203?from\u8203? \u8203?'./extend'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?class\u8203? FlashCoupon \u8203?extends\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?super\u8203?(price);\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two hours'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getExpirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This is a flash offer and expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?.`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   isRewardsEligible(user) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?super\u8203?.isRewardsEligible(user) && \u8203?this\u8203?.price > 20;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getRewards(user) \{\par
\u8203? \tab     \u8203?if\u8203? (\u8203?this\u8203?.isRewardsEligible(user)) \{\par
\u8203? \tab       \u8203?this\u8203?.price = \u8203?this\u8203?.price * 0.8;\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ FlashCoupon \};\par
\par
That\rquote s all there is to it. For those familiar with object-oriented programming, this should be very familiar. Still, you should remember that JavaScript isn\rquote t the same as Ruby, Java, or other languages that use classes. JavaScript is a prototype language. Classes as you\rquote re using them are simply a familiar syntax for a different paradigm. The benefit is that because they are using the same prototype actions under the hood, you can combine classes with legacy code.\par
\par
In the next tip, you\rquote ll see how classes relate to pre-ES6 JavaScript and how you can combine the two approaches in the same codebase. \par
\par
Tip 39\tab Extend Existing Prototypes with Class\par
\par
In this tip, you\rquote ll learn how to use classes with existing prototypes.\par
\par
Now that you know how to write classes in JavaScript, it\rquote s time to see how the new class syntax relates to JavaScript prototypes. It\rquote s important to understand that classes in JavaScript and prototypes aren\rquote t different. Classes are just a clean way to write regular JavaScript. By understanding how classes in JavaScript differ from traditional object-oriented languages, you\rquote ll be able to integrate new syntax with legacy code and prevent subtle bugs from surfacing.\par
\par
What are the differences between JavaScript and more traditional object-oriented languages? Here are the basics: When you use a class in traditional object-oriented languages, such as Ruby, it\rquote s a blueprint for an object. When you create a new instance, you copy all the properties and methods onto the new object.[37]\par
\par
JavaScript is a prototype language. When you create a new instance, you aren\rquote t copying methods. You\rquote re creating a link to a prototype. When you call a method on an instance of an object, you\rquote re calling it from the prototype, which is itself an object instance (not a blueprint). Eric Elliot has a longer article on the subject.[38]\par
\par
When you see the word class in JavaScript, you should know that it isn\rquote t new functionality. It\rquote s just a shorthand for a prototype. That means you can integrate class syntax with your current code bases.\par
\par
Up to this point, you\rquote ve created object instances from classes, but not from constructor functions. In pre-ES5 JavaScript, when you wanted to create a new object instance using the new keyword, you\rquote d use a function. You\rquote ll notice that constructor functions are very similar to a constructor method on a class. That should be a clue that new syntax will fit in nicely with legacy code.\par
\par
To make an object instance with a constructor function in JavaScript, you\rquote d simply write a function as normal. By convention, when you intend to use a function as a constructor, you\rquote d start the function with a capital letter. Inside the function, you can attach properties to an instance using the this keyword.\par
\par
When you create a new instance using the new keyword, you run the function as a constructor and bind the this context. Here\rquote s Coupon written as a constructor function.\par
classes/prototypes/prototypes.js\par
\u8203? \tab\u8203?function\u8203? Coupon(price, expiration) \{\par
\u8203? \tab   \u8203?this\u8203?.price = price;\par
\u8203? \tab   \u8203?this\u8203?.expiration = expiration || \u8203?'two weeks'\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5, \u8203?'two months'\u8203?);\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 5\u8203?\par
\par
That should look familiar. All you did is pull out your constructor function into a standalone action. The only problem is you lost all your methods. This is precisely where JavaScript diverges from traditional object-oriented languages.\par
\par
When you created a new instance with new, you ran the constructor and bound a this context, but you didn\rquote t copy methods. You can add methods to this in the constructor, but it\rquote s far more efficient to add directly to a prototype.\par
\par
A prototype is an object that\rquote s the base for the constructor function. All object instances derive properties from the prototype. In addition, new instances can also use methods on the prototype.\par
\par
To add a method to a prototype, you use the constructor name, Coupon, and you add the method to the prototype property as if you were adding a function or property to an object instance. Add the getExpirationMessage() method to the prototype. Now remember, you already have a working instance of Coupon. Because you\rquote re working with an instance of a prototype, you can access a method you add even after you\rquote ve created a new instance.\par
classes/prototypes/prototypes.js\par
\u8203? \tab Coupon.prototype.getExpirationMessage = \u8203?function\u8203? () \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?.`\u8203?;\par
\u8203? \tab\};\par
\u8203? \tab coupon.getExpirationMessage();\par
\u8203? \tab\u8203?// This offer expires in two months.\u8203?\par
\par
When you create an object using the class keyword, you\rquote re still creating prototypes and binding contexts, but with a more intuitive interface.\par
\par
The code you just created using constructor functions and prototypes is identical to the classes you created in previous tips. It looks different, but behind the scenes, you\rquote re still creating a prototype.\par
\par
And because they\rquote re the same, you can write classes for legacy code that you built using prototypes. For example, if you wanted to extend the Coupon prototype, the process would be the exact same as when you extended the Coupon you built with class syntax. You merely declare that you\rquote re extending the Coupon prototype when you create your new class.\par
classes/prototypes/prototypes.js\par
\u8203? \tab\u8203?class\u8203? FlashCoupon \u8203?extends\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?super\u8203?(price);\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two hours'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   getExpirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This is a flash offer and expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?.`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
If you spend lots of time with JavaScript, it\rquote s worth exploring other ideas such as the prototypal chain, but for now, all you need to know is that classes aren\rquote t new functionality. It\rquote s just a new name for an old concept. Check out the Mozilla Developer Network for a few more examples of how classes relate to prototypes.[39]\par
\par
In the next tip, you\rquote ll return to class syntax and explore how to make simple interfaces using get and set.\par
\par
Tip 40\tab Simplify Interfaces with get and set\par
\par
In this tip, you\rquote ll learn how to mask logic behind simple interfaces with get and set.\par
\par
You have the basics of classes. You can create instances, call properties, call methods, and extend parent classes. But it won\rquote t be long before someone tries to alter a property you had no intention of exposing. Or maybe someone sets the wrong data type on a property, creating bugs because the code expects an integer, not a string.\par
\par
One of the major problems in JavaScript is that there are no private properties by default. Everything is exposed. You can\rquote t control what the users of your class do with the methods or properties.\par
\par
Think about your Coupon. It has a property of price, which you initially set in the constructor. A user of the class can access the property on an instance with dot syntax: coupon.price. So far, no problem. But because an instance of Coupon is just an object, the user can also change the property: coupon.price = 11.\par
\par
In itself that\rquote s not a big deal. But you\rquote ll eventually hit a problem where another developer (or, admit it, you yourself) innocently tries to set a value other parts of the code may not expect. For example, what if instead of setting the price with an integer, you set it using a string? The change may seem harmless, but because all methods expect an integer, the change could ripple through the class, creating unexpected bugs.\par
classes/get/problem.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'Two Weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab   getPriceText() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`$ \u8203?$\{\u8203?this\u8203?.price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab   getExpirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.price = \u8203?'$10'\u8203?;\par
\u8203? \tab coupon.getPriceText();\par
\u8203? \tab\u8203?// '$ $10'\u8203?\par
\par
When you set the price to a string, your message looks broken. What can you do about it?\par
\par
One solution is to put properties behind extra logic using getters and setters. A getter or setter is a way to mask complexity by making a function appear like a property.\par
\par
The change is very simple. You already have a few functions that are clearly getting data. You have a getPriceText() method and a getExpirationMessage() method that have the word \ldblquote get\rdblquote  built right in the function name. And, of course, to execute the method, you call it with dot syntax: coupon.getPriceText().\par
\par
Refactoring the method to a getter is simple. You simply add the keyword get in front of the method. After that, you can also rename the function to be a noun instead of an action. By convention, methods or functions are usually verbs and properties are usually nouns.\par
\par
Here are your methods converted to getters. Notice the only change is the get keyword.\par
classes/get/price.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'two weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? priceText() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`$ \u8203?$\{\u8203?this\u8203?.price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? expirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?.`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
After making that small change, you can call the method using dot syntax but without the parentheses. The method acts like a property even though you\rquote re executing code.\par
classes/get/price.js\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.price = 10;\par
\u8203? \tab coupon.priceText;\par
\u8203? \tab\u8203?// '$10'\u8203?\par
\u8203? \tab coupon.messageText;\par
\u8203? \tab\u8203?// 'This offer expires in two weeks.\u8203?\par
\u8203? \tab coupon.messageText;\par
\par
This makes information easier to retrieve, but it doesn\rquote t solve your problem of someone setting a bad value. To address that, you also need to create a setter.\par
\par
A setter works like your getter. It masks a method by making the method appear like a property. A setter, though, accepts a single argument and changes a property rather than just exposing information. You don\rquote t pass the argument using parentheses. Instead, you pass the object using the equal sign (=) as if you were setting a value on an object.\par
\par
As an example, make a setter that sets the price to half of an argument. This may not be a very useful setter, but it will show you how easy it is to mask method logic behind a setter.\par
\par
To create a setter, you add the keyword set in front of a method. Inside the method, you can change a value on a property.\par
classes/get/set.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'Two Weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?set\u8203? halfPrice(price) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price / 2;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
The problem with setters is that if you don\rquote t have a corresponding getter, things get a little odd. You can set a value to halfPrice. It looks like it\rquote s a normal property, but you can\rquote t get a value from halfPrice.\par
classes/get/set.js\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 5\u8203?\par
\u8203? \tab coupon.halfPrice = 20;\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 10\u8203?\par
\u8203? \tab coupon.halfPrice;\par
\u8203? \tab\u8203?// undefined\u8203?\par
\par
For this reason, it\rquote s always a good idea to pair getters and setters. In fact, they can (and should) have the same name. That\rquote s perfectly valid. What you can\rquote t do is have a property with the same name as your getter or setter. That would be invalid and create a lot of confusion.\par
\par
For example, if you tried to make a setter of price, it would trigger an infinite call stack.\par
classes/get/invalid.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?.price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'Two Weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? price() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?this\u8203?.price;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?set\u8203? price(price) \{\par
\u8203? \tab     \u8203?this\u8203?.price = \u8203?`$ \u8203?$\{price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab\u8203?// RangeError: Maximum call stack size exceeded\u8203?\par
\par
The solution is to use another property as a bridge between your getter and setter. You don\rquote t want users or other developers to access your bridge property. You want it to be for internal use only. In most languages, you\rquote d use a private property. Because you don\rquote t have those currently in JavaScript, you must rely on convention.\par
\par
Developers signal that a method or property is private by prepending it with an underscore. If you see an object with a property of _price, you should know you shouldn\rquote t access it directly.\par
\par
After you set an intermediate property, you can use getters and setters with the same name, minus the underscore, to access or update the value.\par
\par
You now have the tools to solve your problem with setting a non-integer to price. Simply change the property this.price to this._price in the constructor. After that, create a getter to access this._price and a setter that will replace any non-numeric characters with nothing, leaving only the integers. This isn\rquote t perfect because it would strip out decimal points, but it\rquote s good for this demo.\par
classes/get/get.js\par
\u8203? \tab\u8203?class\u8203? Coupon \{\par
\u8203? \tab   \u8203?constructor\u8203?(price, expiration) \{\par
\u8203? \tab     \u8203?this\u8203?._price = price;\par
\u8203? \tab     \u8203?this\u8203?.expiration = expiration || \u8203?'Two Weeks'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? priceText() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`$\u8203?$\{\u8203?this\u8203?._price\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? price() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?this\u8203?._price;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?set\u8203? price(price) \{\par
\u8203? \tab     \u8203?const\u8203? newPrice = price\par
\u8203? \tab       .toString()\par
\u8203? \tab       .replace(\u8203?/\u8203?\u8203?[^\\d]\u8203?\u8203?/g\u8203?, \u8203?''\u8203?);\par
\u8203? \tab     \u8203?this\u8203?._price = newPrice;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   \u8203?get\u8203? expirationMessage() \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`This offer expires in \u8203?$\{\u8203?this\u8203?.expiration\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? coupon = \u8203?new\u8203? Coupon(5);\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 5\u8203?\par
\u8203? \tab\par
\u8203? \tab coupon.price = \u8203?'$10'\u8203?;\par
\u8203? \tab\par
\u8203? \tab coupon.price;\par
\u8203? \tab\u8203?// 10\u8203?\par
\u8203? \tab\par
\u8203? \tab coupon.priceText;\par
\u8203? \tab\u8203?// $ 10\u8203?\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? Coupon;\par
\par
A bonus to using this approach is you don\rquote t need to refactor any existing code. All code that currently uses coupon.price will work as intended.\par
\par
The big advantage with getters and setters is that you hide complexity. The downside is that you mask your intentions. If another developer is writing code elsewhere, they may think they\rquote re setting a property when they\rquote re actually calling a method. Getters and setters can sometimes be very hard to debug and hard to test. As always, use with caution and make sure your intentions are clear with plenty of tests and documentation.\par
\par
In the next tip, you\rquote ll learn another technique to mask complexity by turning data structures into iterables with generators.\par
\par
Tip 41\tab Create Iterable Properties with Generators\par
\par
In this tip, you\rquote ll learn how to convert complex data structures to iterables with generators.\par
\par
In Tip 14, \u8203? Iterate Over Key-Value Data with Map and the Spread Operator \u8203?, you learned how simple it is to loop over maps thanks to iterables. And once you can iterate over a collection, you have access to the spread operator, array methods, and many other tools to transform your data. Iterables give your data more flexibility by allowing you to access each piece of data individually.\par
\par
You also know that objects don\rquote t have a built-in iterator. You can\rquote t loop over an object directly\emdash you need to convert part of it to an array first. That can be a major problem when you want the structure of an object but the flexibility of an iterable.\par
\par
In this tip, you\rquote ll learn a technique that can make complex data structures as easy to use as simple arrays. You\rquote re going to use a new specialized function called a generator to return data one piece at time. In the process, you\rquote ll see how you can convert a deeply nested object into a simple structure.\par
\par
Generators aren\rquote t exclusive to classes. They\rquote re a specialized function. At the same time, they\rquote re very different from other functions. And while the JavaScript community has enthusiastically embraced most new features, they haven\rquote t quite figured out what to do with generators. In late 2016, a poll by Kent Dodds, a popular JavaScript developer, found that 81 percent of developers rarely or never used generators.[40]\par
\par
That\rquote s changing. Developers and library authors are discovering how to use generators. One of the best use cases so far is to use generators to transform objects into iterables.\par
Finding Real Life Use Cases\par
\par
Now that the JavaScript spec is updating yearly, you\rquote ll see new features regularly. Occasionally, you\rquote ll come across new syntax and have no idea why it was included or where you should use it. Sometimes it takes time to understand how to incorporate new syntax. When you find yourself stuck with new syntax that you don\rquote t understand, you should spend some time looking for real-life use cases.\par
\par
The best way to find use cases for new syntax is to explore open source libraries. I usually have a few large projects\emdash React, Redux, Lodash\emdash that I search for syntax examples. All you need to do is go to GitHub, Gitlab, or anywhere the project is hosted and search for the syntax. When I was trying to learn how to use Map, I went to React and searched for new Map and found a few good examples. I discovered this generator pattern by looking through Khan Academy on github.\par
\par
You\rquote ll quickly see a lot of usage patterns. And if you don\rquote t see many examples, that\rquote s a clue that the syntax may not be very valuable or at least not widely understood.\par
\par
What is a generator? The Mozilla Developer Network explains that a generator is a function that doesn\rquote t fully execute its body immediately when called.[41]\par
\par
This is different from a higher-order function, which fully executes but returns a new function. A generator is a single function that doesn\rquote t resolve its body immediately. What that means is that a generator is a function that has break points where it essentially pauses until the next step.\par
\par
To make a generator, you add an asterisk (*) after the function keyword. You then have access to a special method called next(), which returns a part of the function. Inside the function body, you return a piece of information with the keyword yield. When executing the function, use the next() method to get the information yielded by the function.\par
\par
When you call next(), you get an object containing two keys: value and done. The item you declare with yield is the value. done indicates there are no items left.\par
\par
For example, if you wanted to read Nobel Prize winner Naguib Mahfouz\rquote s Cairo Trilogy but you only wanted to know the titles one at a time, you\rquote d write a function that would return the yields for each book in the trilogy. Each time you called yield(), you\rquote d give the next book in the sequence.\par
\par
To use the trilogy generator, you\rquote d first have to call the function and assign it to a variable. You\rquote d then call next() on the variable each time you wanted a new book.\par
classes/generators/simple.js\par
\u8203? \tab\u8203?function\u8203?* getCairoTrilogy() \{\par
\u8203? \tab   \u8203?yield\u8203? \u8203?'Palace Walk'\u8203?;\par
\u8203? \tab   \u8203?yield\u8203? \u8203?'Palace of Desire'\u8203?;\par
\u8203? \tab   \u8203?yield\u8203? \u8203?'Sugar Street'\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? trilogy = getCairoTrilogy();\par
\u8203? \tab trilogy.next();\par
\u8203? \tab\u8203?// \{ value: 'Palace Walk', done: false \}\u8203?\par
\u8203? \tab trilogy.next();\par
\u8203? \tab\u8203?// \{ value: 'Palace of Desire', done: false \}\u8203?\par
\u8203? \tab trilogy.next();\par
\u8203? \tab\u8203?// \{ value: 'Sugar Street', done: false \}\u8203?\par
\u8203? \tab trilogy.next();\par
\u8203? \tab\u8203?// \{ value: undefined, done: true \}\u8203?\par
\par
Notice how interesting that is. You can step through the function piece by piece. This is useful if you have lots of information and want to access it in parts. You could pull out one piece of information and pass the generator somewhere else to get the next piece. Like a higher-order function, you can use it in different places.\par
\par
But that is not going to be your focus for this tip. Instead, it is far more interesting that generators turn a function into an iterable. Because you are accessing data one piece at a time, it is a simple step to turn them into iterables.\par
\par
When you use a generator as an iterable, you don\rquote t need to use the next() method. Use any action that requires an iterable. The generator will go through the parts one at a time as if it were going through the indexes of an array or the keys of a map.\par
\par
For example, if you want the Cairo trilogy in the form of an array, you\rquote d simply use the spread operator.\par
classes/generators/simple.js\par
\u8203? \tab [...getCairoTrilogy];\par
\u8203? \tab\u8203?// [ 'Palace Walk', 'Palace of Desire', 'Sugar Street']\u8203?\par
\par
If you want to add all the books to your reading list, all you\rquote d need is a simple for...of loop.\par
classes/generators/simple.js\par
\u8203? \tab\u8203?const\u8203? readingList = \{\par
\u8203? \tab   \u8203?'Visit from the Goon Squad'\u8203?: \u8203?true\u8203?,\par
\u8203? \tab   \u8203?'Manhattan Beach'\u8203?: \u8203?false\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\u8203?for\u8203? (\u8203?const\u8203? book \u8203?of\u8203? getCairoTrilogy()) \{\par
\u8203? \tab   readingList[book] = \u8203?false\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab readingList;\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//   'Visit from the Goon Squad': true,\u8203?\par
\u8203? \tab\u8203?//   'Manhattan Beach': false,\u8203?\par
\u8203? \tab\u8203?//   'Palace Walk': false,\u8203?\par
\u8203? \tab\u8203?//   'Palace of Desire': false,\u8203?\par
\u8203? \tab\u8203?//   'Sugar Street': false\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
How does this fit into classes? Generators are awesome because, like getters and setters, they can give your classes a simple interface. You can make a class with a complex data structure but design it in such a way that developers using it will be able to access the data as if it were a simple array.\par
\par
Consider a simple data structure: a family tree with a single branch. A person in a family tree would have a name and children. And each child would have children of their own.\par
\par
A tree data structure would have advantages for searches and lookups, but flattening the information would be pretty difficult. You\rquote d have to make a method to create an empty array and fill it with family members before returning.\par
classes/generators/problem.js\par
\u8203? \tab\u8203?class\u8203? FamilyTree \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.family = \{\par
\u8203? \tab       name: \u8203?'Dolores'\u8203?,\par
\u8203? \tab       child: \{\par
\u8203? \tab         name: \u8203?'Martha'\u8203?,\par
\u8203? \tab         child: \{\par
\u8203? \tab           name: \u8203?'Dyan'\u8203?,\par
\u8203? \tab           child: \{\par
\u8203? \tab             name: \u8203?'Bea'\u8203?,\par
\u8203? \tab           \},\par
\u8203? \tab         \},\par
\u8203? \tab       \},\par
\u8203? \tab     \};\par
\u8203? \tab   \}\par
\u8203? \tab   getMembers() \{\par
\u8203? \tab     \u8203?const\u8203? family = [];\par
\u8203? \tab     \u8203?let\u8203? node = \u8203?this\u8203?.family;\par
\u8203? \tab     \u8203?while\u8203? (node) \{\par
\u8203? \tab       family.push(node.name);\par
\u8203? \tab       node = node.child;\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?return\u8203? family;\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? family = \u8203?new\u8203? FamilyTree();\par
\u8203? \tab family.getMembers();\par
\u8203? \tab\u8203?// ['Dolores', 'Martha', 'Dyan', 'Bea'];\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? FamilyTree;\par
\par
With a generator, you can return the data directly without pushing it to an array. As a bonus, your users wouldn\rquote t need to look up a method name. They could treat the property holding the family tree as if it were holding an array.\par
\par
Converting the method to a generator is simple. You\rquote re just combining ideas from the method with ideas from your getCairoTrilogy() generator.\par
\par
Start off by changing the method name from getMembers() to * [Symbol.iterator](). It looks confusing, but here\rquote s what\rquote s happening. First, the asterisk signifies that you\rquote re creating a generator. The phrase Symbol.iterator is attaching the generator to an iterable on the class. This is similar to how the map object has a MapIterator.\par
\par
Inside the body of the method, add the while loop. Unlike your getCairoTrilogy() generator, you aren\rquote t going to yield an explicit value. Instead, you\rquote ll yield the value from each cycle of the loop. As long as there\rquote s something to return, the generator will keep going.\par
\par
Instead of family.push(node.name);, all you need to do is yield the result: yield node.name. This means you don\rquote t need the intermediate array. Delete that. Everything else is the same\par
\par
Now when you need any action that requires an iterable, such as the spread or the for...of loop, you can call it directly on the class instance.\par
classes/generators/generators.js\par
\u8203? \tab\u8203?class\u8203? FamilyTree \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.family = \{\par
\u8203? \tab       name: \u8203?'Dolores'\u8203?,\par
\u8203? \tab       child: \{\par
\u8203? \tab         name: \u8203?'Martha'\u8203?,\par
\u8203? \tab         child: \{\par
\u8203? \tab           name: \u8203?'Dyan'\u8203?,\par
\u8203? \tab           child: \{\par
\u8203? \tab             name: \u8203?'Bea'\u8203?,\par
\u8203? \tab           \},\par
\u8203? \tab         \},\par
\u8203? \tab       \},\par
\u8203? \tab     \};\par
\u8203? \tab   \}\par
\u8203? \tab   * [Symbol.iterator]() \{\par
\u8203? \tab     \u8203?let\u8203? node = \u8203?this\u8203?.family;\par
\u8203? \tab     \u8203?while\u8203? (node) \{\par
\u8203? \tab       \u8203?yield\u8203? node.name;\par
\u8203? \tab       node = node.child;\par
\u8203? \tab     \}\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? family = \u8203?new\u8203? FamilyTree();\par
\u8203? \tab [...family];\par
\u8203? \tab\u8203?// ['Dolores', 'Martha', 'Dyan', 'Bea'];\u8203?\par
\par
Is the extra complexity of the generator worth it? It depends on your goals. The advantage with a generator is that other developers don\rquote t need to get caught up in the implementation details of your class. They don\rquote t need to know that the class is actually using a tree data structure. To them, the class contains an iterable.\par
\par
Of course, sometimes hiding complexity makes debugging more difficult. As with getters and setters, be careful about hiding too much from other developers. Still, when you want to use more complicated data structures but you don\rquote t want to burden others with implementation details, generators are a great solution.\par
\par
In the next tip, you\rquote ll see how context problems can sneak into classes and how you can solve them using bind().\par
\par
Tip 42\tab Resolve Context Problems with Bind()\par
\par
In this tip, you\rquote ll learn how to solve this errors with bind().\par
\par
In Tip 36, \u8203? Prevent Context Confusion with Arrow Functions \u8203?, you saw how functions create a new context and how a new context can give you results you aren\rquote t expecting. Changing context can create confusion, particularly when you\rquote re using the this keyword in callbacks or array methods.\par
\par
Sadly, the problem doesn\rquote t go away in classes. Earlier, you learned how you can use arrow functions to create another function without a new context. In this tip, you\rquote ll learn more techniques for preventing context problems. The techniques you\rquote re about to learn work on object literals and classes, but they\rquote re much more common in class syntax, particularly if you\rquote re using libraries such at React or Angular.\par
\par
Think back to the original example, a validator. Originally, you made it as an object literal, but now that you know a bit about classes, you can make it a class. The class will have one property, a message, and two methods: setInvalidMessage(), which returns a single invalid message for a field, and setInvalidMessages(), which maps an array of fields to a series of invalid messages.\par
classes/bind/problem.js\par
\u8203? \tab\u8203?class\u8203? Validator \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.message = \u8203?'is invalid.'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessage(field) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?this\u8203?.setInvalidMessage);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
All you did was translate an object with properties and methods to a class with properties and methods.\par
\par
The Validator class will have the exact same context problem as your object. When you call setInvalidMessages(), the function creates a this binding to the class. Inside the method, you call map() on an array and pass setInvalidMessage() as the callback. When the map() method invokes setInvalidMessage(), it will create a new this binding in the context of the array method, not the class.\par
classes/bind/bind.spec.js\par
\u8203? \tab\u8203?const\u8203? validator = \u8203?new\u8203? ValidatorProblem();\par
\u8203? \tab validator.setInvalidMessages(\u8203?'city'\u8203?);\par
\u8203? \tab\u8203?// TypeError: Cannot read property 'message' of undefined\u8203?\par
\par
Context problems are common in the React community. Nearly every class has some form of binding problem. Cory House has a great breakdown of different ways to solve the binding problem in React.[42] You\rquote ll be seeing an adaptation of most of those solutions in a more generic class.\par
\par
The first way to solve the problem is the same as the solution suggested in Tip 36, \u8203? Prevent Context Confusion with Arrow Functions \u8203?. Convert your method to an arrow function. The arrow function won\rquote t create a new this binding and it won\rquote t throw an error.\par
\par
The only downside to this approach is that when you\rquote re working with class syntax, you\rquote ll have to move your function to a property rather than a method. It\rquote s not a big deal on objects because objects and properties both use a key-value declaration. In classes, you have to set properties in the constructor and the method will look a little out of place. Now you\rquote re stuck with a situation where some methods are set in the constructor and some are set as class methods.\par
classes/bind/constructorArrow.js\par
\u8203? \tab\u8203?class\u8203? Validator \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.message = \u8203?'is invalid.'\u8203?;\par
\u8203? \tab     \u8203?this\u8203?.setInvalidMessage = field => \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?this\u8203?.setInvalidMessage);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Moving the method to a property in the constructor may solve your context problem, but it creates another. Methods are defined in multiple places. And depending on how many methods you create this way, your constructor can get large quickly.\par
\par
A better solution is to use the bind() method. This method exists on all functions and lets you state your context explicitly. You\rquote ll always know what this refers to because you tell the function exactly where to bind.\par
\par
As an example, suppose you have a function that refers to a property on this. The function doesn\rquote t actually have that property. The property this refers to may not yet exist. There\rquote s no rule that says properties must exist when you declare a function. But they do need to exist at runtime when you call a function or else you\rquote ll get undefined. With this function, you can explicitly set this to a specific object using bind.\par
classes/bind/bind.js\par
\u8203? \tab\u8203?function\u8203? sayMessage() \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?this\u8203?.message;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? alert = \{\par
\u8203? \tab   message: \u8203?'Danger!'\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? sayAlert = sayMessage.bind(alert);\par
\u8203? \tab\par
\u8203? \tab sayAlert();\par
\u8203? \tab\u8203?// Danger!\u8203?\par
\par
Whenever the function uses this, it will lock in the object you bound to it. Kyle Simpson calls this explicit binding because you\rquote re declaring the context and not relying on the engine to set it at runtime.[43]\par
\par
In the preceding example, you\rquote re binding the sayMessage() function explicitly to an object that has the message property.\par
\par
Now it\rquote s time for things to get a little confusing. You can also bind a function to the current context by binding it to this. It may seem odd to bind a this to, well, this, but all you\rquote re doing is telling the function to use the current context rather than creating a new one. Unlike an arrow function, the function is still creating a this binding\emdash it\rquote s just using the current binding rather than building a new one.\par
\par
In your Validator class, you can bind the function to the current context before you pass it to the map() method.\par
classes/bind/bind.js\par
\u8203? \tab\u8203?class\u8203? Validator \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.message = \u8203?'is invalid.'\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessage(field) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?this\u8203?.setInvalidMessage.bind(\u8203?this\u8203?));\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
That\rquote s a fine approach. The only downside is if you use the function in another method, you\rquote ll have to bind it again. A lot of developers avoid multiple binds by setting a bound method to a property of the same name in the constructor.\par
\par
This is very similar to creating an arrow function in the constructor. The advantage is that your methods are still defined in the same place. They\rquote re merely bound in the constructor. Now you define all your methods in one place, the body. You declare your properties in another place, the constructor. And you set your context in one place, also the constructor.\par
classes/bind/constructor.js\par
\u8203? \tab\u8203?class\u8203? Validator \{\par
\u8203? \tab   \u8203?constructor\u8203?() \{\par
\u8203? \tab     \u8203?this\u8203?.message = \u8203?'is invalid.'\u8203?;\par
\u8203? \tab     \u8203?this\u8203?.setInvalidMessage = \u8203?this\u8203?.setInvalidMessage.bind(\u8203?this\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessage(field) \{\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?this\u8203?.setInvalidMessage);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Both approaches\emdash using arrow functions and binding a function to this\emdash  work with the current spec. In a future spec, you\rquote ll be able to set class properties outside of the constructor. With the new spec, you assign arrow functions to properties alongside other method definitions. It\rquote s the best of both worlds.\par
classes/bind/properties.js\par
\u8203? \tab\u8203?class\u8203? Validator \{\par
\u8203? \tab   message = \u8203?'is invalid.'\u8203?;\par
\u8203? \tab\par
\u8203? \tab   setMessage = field => \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?;\par
\u8203? \tab\par
\u8203? \tab   setInvalidMessages(...fields) \{\par
\u8203? \tab     \u8203?return\u8203? fields.map(\u8203?this\u8203?.setMessage);\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
As with other proposed specs, you can use this feature right now with the proper Babel plugin. This particular feature isn\rquote t currently supported in any version of Node.js, so you won\rquote t be able to try it out in the REPL.\par
\par
As with other context problems, try not to get too hung up on the details. Binding will make more sense when you see it organically. Just remember: If you\rquote re encountering unexpected behaviors or weird errors when using this, you might want to explicitly bind the context. Until that point, don\rquote t worry. Binding can be expensive, and you really should only use it when you need to solve a specific problem.\par
\par
At this point, you should be able to create and extend classes with ease. Despite the controversy, it makes writing JavaScript a lot more intuitive for those outside the language and more succinct for those who\rquote ve been developing JavaScript for years.\par
\par
In the next chapter, you\rquote ll learn how to work with data outside your code by exploring promises, fetch methods, and asynchronous functions.\par
Footnotes\par
\par
[37]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch4.md }}{\fldrslt{https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch4.md\ul0\cf0}}}}\f1\fs22\par
[38]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9 }}{\fldrslt{https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9\ul0\cf0}}}}\f1\fs22\par
[39]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Sub_classing_with_extends }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Sub_classing_with_extends\ul0\cf0}}}}\f1\fs22\par
[40]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://twitter.com/kentcdodds/status/775447130391535616 }}{\fldrslt{https://twitter.com/kentcdodds/status/775447130391535616\ul0\cf0}}}}\f1\fs22\par
[41]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function* }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\ul0\cf0}}}}\f1\fs22\par
[42]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://medium.freecodecamp.org/react-binding-patterns-5-approaches-for-handling-this-92c651b5af56 }}{\fldrslt{https://medium.freecodecamp.org/react-binding-patterns-5-approaches-for-handling-this-92c651b5af56\ul0\cf0}}}}\f1\fs22\par
[43]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#explicit-binding }}{\fldrslt{https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#explicit-binding\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 9\par
Access External Data\par
\par
In the 19th century, an international team of engineers embarked on one of the greatest engineering challenges of their day: laying a telegraph cable across the Atlantic Ocean. The project took several failed attempts and plenty of money and hours before it succeeded. In the end, you could send a message from Europe to the United States in an impressive 17 hours\emdash much faster than the nearly two-week boat trip it used to take.\par
\par
Fast communication can mean the difference between success and failure. JavaScript\rquote s resurgence is partially due to the fact that you can load a page once and then use JavaScript for all future communications to and from servers. Suddenly, you could experience websites as actual software instead of a series of discrete pages. When you skip page loads, you save time and resources for your users. They don\rquote t have to reload new images and other assets. They have less latency, and their experience is greatly improved. Accessing external data is crucial to so-called Single Page web applications.\par
\par
In this chapter, you\rquote ll learn how to access external data and how to use the data you receive. JavaScript is an asynchronous language, which means it won\rquote t block code execution while waiting for requested data. JavaScript can give you speedy websites, but asynchronous requests can be a little confusing to work with.\par
\par
We\rquote ll start off by exploring how to use fetch() to access remote data. Next, we\rquote ll take a deep dive into promises, the JavaScript method for handling asynchronous requests. Then we\rquote ll use the new async/await syntax to make working with promises even more clear. Finally, you\rquote ll learn to store data on the browser so you can keep a user\rquote s state without any server access.\par
\par
You\rquote ll never experience performance gains on the level of the transatlantic cable, but every second counts. Don\rquote t be surprised when a mobile user leaves a site that requires a new page render on every action. You can\rquote t remove the server entirely, but you can give your users experiences that make the server requests as painless as possible.\par
Tip 43\tab Retrieve Data Asynchronously with Promises\par
\par
In this tip, you\rquote ll learn how to work with delayed data responses using promises.\par
\par
JavaScript is an asynchronous language. That\rquote s a big word for a simple concept. An asynchronous language is merely a language that can execute subsequent lines of code when previous lines of code aren\rquote t fully resolved.\par
\par
All right. Maybe that explanation wasn\rquote t any more clear. Think about reasons why code may be blocked. You may be getting data from an API. You might be pulling data from the DOM or other source. You might be waiting for a user response. The common thread is you need some information to proceed, and it may take time to get it. If you want more examples, Peter Olson has a great breakdown of the differences between asynchronous and synchronous code.[44]\par
\par
The value of asynchronous languages is that if there are parts of your code that don\rquote t require the delayed information, you can run the code while the other code is waiting. If you\rquote re waiting for an API response, you can still respond to click methods on other elements or calculate values of other data sources. Your code doesn\rquote t grind to a halt while waiting.\par
\par
In later tips, you\rquote ll work with API data specifically. In this tip, you\rquote ll explore a reusable technique for working with asynchronous data: promises.\par
\par
Before promises, developers used callbacks to handle asynchronous actions. If you requested expenses from a data source, you\rquote d pass a callback function as an argument. After the asynchronous data is returned\emdash or resolved as it is often called\emdash the function would execute the callback. The traditional example is a setTimeout() function that takes a callback and executes it after a certain number of milliseconds.\par
\par
Use setTimeout() as a place holder for any action that doesn\rquote t immediately resolve. For example, think about a function called getUserPreferences(), which would fetch data from an API and then pass that data to a callback.\par
\par
Because Javascript is asynchronous, you can call other functions before and after the call to getUserPreferences() and they\rquote d both resolve before getUserPreferences() executes the callback.\par
externalData/promises/problem.js\par
\u8203? \tab\u8203?function\u8203? getUserPreferences(cb) \{\par
\u8203? \tab   setTimeout(() => \{\par
\u8203? \tab     cb(\{\par
\u8203? \tab       theme: \u8203?'dusk'\u8203?,\par
\u8203? \tab     \});\par
\u8203? \tab   \}, 1000);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? log(value) \{\par
\u8203? \tab   \u8203?return\u8203? console.log(value);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab log(\u8203?'starting'\u8203?);\par
\u8203? \tab\u8203?// starting\u8203?\par
\u8203? \tab\par
\u8203? \tab getUserPreferences(preferences => \{\par
\u8203? \tab   \u8203?return\u8203? log(preferences.theme.toUpperCase());\par
\u8203? \tab\});\par
\u8203? \tab\par
\u8203? \tab log(\u8203?'ending?'\u8203?);\par
\u8203? \tab\u8203?// ending\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?// DUSK\u8203?\par
\par
Callbacks are a fine way to handle asynchronous data. And they were a standard tool for a long time. The problem is that you may have asynchronous functions that call asynchronous functions, that call asynchronous\'85 Eventually you have so many nested callbacks, you find yourself in what became known as \ldblquote callback hell.\rdblquote\par
\par
What if you wanted to get a music selection based on a user\rquote s preference? The callback function, getMusic(), also needs to hit an API and also needs a callback based on the API response. You encounter this situation all the time. Here\rquote s your getMusic() function:\par
externalData/promises/problem.js\par
\u8203? \tab\u8203?function\u8203? getMusic(theme, cb) \{\par
\u8203? \tab   setTimeout(() => \{\par
\u8203? \tab     \u8203?if\u8203? (theme === \u8203?'dusk'\u8203?) \{\par
\u8203? \tab       \u8203?return\u8203? cb(\{\par
\u8203? \tab         album: \u8203?'music for airports'\u8203?,\par
\u8203? \tab       \});\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?return\u8203? cb(\{\par
\u8203? \tab       album: \u8203?'kind of blue'\u8203?,\par
\u8203? \tab     \});\par
\u8203? \tab   \}, 1000);\par
\u8203? \tab\}\par
\par
Now you need to get the preference and then get an album. First, you\rquote d make a call to getUserPreferences() and you\rquote d pass getMusic() as a callback. getMusic() takes a theme preference and a callback. This function is only nested two deep, and it\rquote s already getting hard to read.\par
externalData/promises/problem.js\par
\u8203? \tab getUserPreferences(preferences => \{\par
\u8203? \tab   \u8203?return\u8203? getMusic(preferences.theme, music => \{\par
\u8203? \tab     console.log(music.album);\par
\u8203? \tab   \});\par
\u8203? \tab\});\par
\par
As if that weren\rquote t enough, many asynchronous functions took two callbacks: a callback for a successful response and a callback for an error. Things got complicated fast.\par
\par
Promises solve the callback problem twice over. Instead of taking callback functions as arguments, promises have methods for success and failure. This keeps things visually flat. In addition, you can chain together asynchronous promises instead of nesting them. This means that you can neatly stack all of your actions.\par
\par
How does it work? A promise is an object that takes asynchronous action and calls one of two methods based on the response. If the asynchronous action is successful, or fulfilled, the promise passes the results to a then() method. If the action fails, or is rejected, the promise calls the catch() method. Both then() and catch() take a function as an argument, and that can only take a single response argument.\par
\par
A promise takes two arguments: resolve() and reject(). resolve() is what happens when things go as planned. When resolve() is called, the code will execute the function passed to the then() method. When you define your getUserPreferences() function, you\rquote ll return the promise. When you actually call getUserPreferences(), you\rquote ll call either the then() or the catch() method.\par
externalData/promises/promises.js\par
\u8203? \tab\u8203?function\u8203? getUserPreferences() \{\par
\u8203? \tab   \u8203?const\u8203? preferences = \u8203?new\u8203? Promise((resolve, reject) => \{\par
\u8203? \tab     resolve(\{\par
\u8203? \tab       theme: \u8203?'dusk'\u8203?,\par
\u8203? \tab     \});\par
\u8203? \tab   \});\par
\u8203? \tab   \u8203?return\u8203? preferences;\par
\u8203? \tab\}\par
\par
Here\rquote s an example of calling a code and running a function on successful resolution using the then() method.\par
externalData/promises/promises.js\par
\u8203? \tab getUserPreferences()\par
\u8203? \tab   .then(preferences => \{\par
\u8203? \tab     console.log(preferences.theme);\par
\u8203? \tab   \});\par
\u8203? \tab\u8203?// 'dusk'\u8203?\par
\par
In this case, things went well, but you should always have a backup plan. Whenever you set up a promise, you can have both a then() and a catch() method. The then() method will handle the resolutions. The catch() method will handle the rejections.\par
\par
Here\rquote s a failing promise. Note that it\rquote s calling the reject() argument.\par
externalData/promises/promises.js\par
\u8203? \tab\u8203?function\u8203? failUserPreference() \{\par
\u8203? \tab   \u8203?const\u8203? finder = \u8203?new\u8203? Promise((resolve, reject) => \{\par
\u8203? \tab     reject(\{\par
\u8203? \tab       type: \u8203?'Access Denied'\u8203?,\par
\u8203? \tab     \});\par
\u8203? \tab   \});\par
\u8203? \tab   \u8203?return\u8203? finder;\par
\u8203? \tab\}\par
\par
When you call a promise, you can add attach the then() method and the catch() using chaining.\par
externalData/promises/promises.js\par
\u8203? \tab failUserPreference()\par
\u8203? \tab   .then(preferences => \{\par
\u8203? \tab   \u8203?// This won't execute\u8203?\par
\u8203? \tab     console.log(preferences.theme);\par
\u8203? \tab   \})\par
\u8203? \tab   .\u8203?catch\u8203?(error => \{\par
\u8203? \tab     console.error(\u8203?`Fail: \u8203?$\{error.type\}\u8203?`\u8203?);\par
\u8203? \tab   \});\par
\u8203? \tab\u8203?// Fail: Access Denied\u8203?\par
\par
This code should already look more clean. The fun really begins when you chain multiple promises together.\par
\par
Remember your getMusic() function? Try converting that to a promise.\par
externalData/promises/promises.js\par
\u8203? \tab\u8203?function\u8203? getMusic(theme) \{\par
\u8203? \tab   \u8203?if\u8203? (theme === \u8203?'dusk'\u8203?) \{\par
\u8203? \tab     \u8203?return\u8203? Promise.resolve(\{\par
\u8203? \tab       album: \u8203?'music for airports'\u8203?,\par
\u8203? \tab     \});\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? Promise.resolve(\{\par
\u8203? \tab     album: \u8203?'kind of blue'\u8203?,\par
\u8203? \tab   \});\par
\u8203? \tab\}\par
\par
After you do, you can call and return it in the then() method of getUserPreferences(). After you do that, you can call another then() method, which will call a function using the results from getMusic().\par
externalData/promises/promises.js\par
\u8203? \tab getUserPreferences()\par
\u8203? \tab   .then(preference => \{\par
\u8203? \tab     \u8203?return\u8203? getMusic(preference.theme);\par
\u8203? \tab   \})\par
\u8203? \tab   .then(music => \{\par
\u8203? \tab     console.log(music.album);\par
\u8203? \tab   \});\par
\u8203? \tab\u8203?// music for airports\u8203?\par
\par
See what\rquote s happening? Instead of passing data into a series of nested callbacks, you\rquote re passing data down through a series of then() methods.\par
\par
And, of course, because you\rquote re returning promises, you can convert everything to single-line arrow functions with an implicit return.\par
externalData/promises/promises.js\par
\u8203? \tab getUserPreferences()\par
\u8203? \tab   .then(preference => getMusic(preference.theme))\par
\u8203? \tab   .then(music => \{ console.log(music.album); \});\par
\par
Finally, as if that weren\rquote t enough, if you\rquote re chaining promises together, you don\rquote t need to add a catch() method to each one. You can define a single catch() method to handle a case where any promise is rejected.\par
\par
To see a chained catch() in action, create another promise that returns the artist for an album.\par
externalData/promises/promises.js\par
\u8203? \tab\u8203?function\u8203? getArtist(album) \{\par
\u8203? \tab   \u8203?return\u8203? Promise.resolve(\{\par
\u8203? \tab     artist: \u8203?'Brian Eno'\u8203?,\par
\u8203? \tab   \});\par
\u8203? \tab\}\par
\par
Unfortunately, you won\rquote t get to use getArtists() because getMusic() is going to be rejected. Don\rquote t worry\emdash it won\rquote t kill your code. Your code will execute the catch() at the bottom of the group even though it was defined after another then() method.\par
externalData/promises/promises.js\par
\u8203? \tab\u8203?function\u8203? failMusic(theme) \{\par
\u8203? \tab   \u8203?return\u8203? Promise.reject(\{\par
\u8203? \tab     type: \u8203?'Network error'\u8203?,\par
\u8203? \tab   \});\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getUserPreferences()\par
\u8203? \tab   .then(preference => failMusic(preference.theme))\par
\u8203? \tab   .then(music => getArtist(music.album))\par
\u8203? \tab   .\u8203?catch\u8203?(e => \{\par
\u8203? \tab     console.log(e);\par
\u8203? \tab   \});\par
\par
As you can see, promises can handle a lot of situations with a very simple interface. There\rquote s even a method called Promise.all that takes an array of promises and returns either a resolve or a reject when they all finish.[45]\par
\par
Promises took the JavaScript world by storm. They\rquote re an amazing tool that can help you make otherwise ugly code gorgeous and easy to read.\par
\par
Of course, things can always get better. In ES2017, the TC39 committee approved a new method for handling asynchronous functions. Well, it\rquote s actually a two-step process called async/await and it takes asynchronous data in an interesting new direction.\par
\par
In the next tip, you\rquote ll explore async/await and see how you can make your asynchronous code even more readable.\par
\par
Tip 44\tab Create Clean Functions with Async/Await\par
\par
In this tip, you\rquote ll learn how to streamline promises with async/await.\par
\par
In the previous tip, you saw that promises are awesome. They\rquote re a vast improvement over callbacks, but their interfaces are still a little clunky. You\rquote re still working with callbacks in methods. Fortunately, the language continues to improve. You can now avoid callbacks entirely by adding asynchronous promise data to a variable in a single function.\par
\par
Developers usually talk about the new syntax, async/await, as a group, but it\rquote s really two separate actions. You use the async keyword to declare that an encapsulating function will be using asynchronous data. Inside the asynchronous function, you can use the await keyword to pause the function until a value is returned.\par
\par
Before you begin, there are a couple things to note. First, this doesn\rquote t replace promises. You\rquote re merely wrapping promises in a better syntax. Second, it isn\rquote t well supported, and the compiled code is a little buggy. It\rquote s safe to use on server-side JavaScript, but you may have problems in browsers.\par
\par
To see async/await in action, refactor some of your code from the previous tip. As a reminder, you pass a function to the then() method on the getUserPreferences() function.\par
externalData/promises/promises.js\par
\u8203? \tab getUserPreferences()\par
\u8203? \tab   .then(preferences => \{\par
\u8203? \tab     console.log(preferences.theme);\par
\u8203? \tab   \});\par
\u8203? \tab\u8203?// 'dusk'\u8203?\par
\par
First, you\rquote ll need to wrap the call to getUserPreferences() in another function. Write a new function called getTheme(). This will hold all of your calls to asynchronous functions. To indicate that you\rquote ll be calling asynchronous functions, add the async keyword right before the function keyword.\par
\par
Inside your getTheme() function, you can call getUserPreferences(). Before you call the function, though, add the await keyword to signal that getUserPreferences() will return a promise. This allows you to assign the resolved promise to a new variable.\par
externalData/async/async.js\par
\u8203? \tab\u8203?async\u8203? \u8203?function\u8203? getTheme() \{\par
\u8203? \tab   \u8203?const\u8203? \{ theme \} = \u8203?await\u8203? getUserPreferences();\par
\u8203? \tab   \u8203?return\u8203? theme;\par
\u8203? \tab\}\par
\par
The trick with an asynchronous function is that it\rquote s transformed into a promise. In other words, when you call getTheme(), you\rquote ll still need a then() method.\par
externalData/async/async.js\par
\u8203? \tab getTheme()\par
\u8203? \tab   .then(theme => \{\par
\u8203? \tab     console.log(theme);\par
\u8203? \tab   \});\par
\par
You cleaned things up a little, but honestly, not much. async functions really shine when you\rquote re working with multiple promises.\par
\par
Think about the previous tip when you chained multiple promises together. With async/await, you can assign each return statement to a variable before passing the variable to the next function. In other words, you can transform your chained promises into a series of function calls in a single wrapping function. Try creating a new function called getArtistsByPreference() where you call a series of asynchronous functions passing the data from the previous function as an argument to the next.\par
externalData/async/async.js\par
\u8203? \tab\u8203?async\u8203? \u8203?function\u8203? getArtistByPreference() \{\par
\u8203? \tab   \u8203?const\u8203? \{ theme \} = \u8203?await\u8203? getUserPreferences();\par
\u8203? \tab   \u8203?const\u8203? \{ album \} = \u8203?await\u8203? getMusic(theme);\par
\u8203? \tab   \u8203?const\u8203? \{ artist \} = \u8203?await\u8203? getArtist(album);\par
\u8203? \tab   \u8203?return\u8203? artist;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getArtistByPreference()\par
\u8203? \tab   .then(artist => \{\par
\u8203? \tab     console.log(artist);\par
\u8203? \tab   \});\par
\par
That\rquote s a vast improvement over a long method chain.\par
\par
All that\rquote s left is handling errors. In this case, you\rquote ll need to move error handling outside the wrapping function. Instead, you still use the catch method when you\rquote re invoking getArtistsByPreference(). Because getArtistsByPreference() returns a promise, you need to add a catch() method in case any of your internal asynchronous functions return an error.\par
externalData/async/catch.js\par
\u8203? \tab\u8203?async\u8203? \u8203?function\u8203? getArtistByPreference() \{\par
\u8203? \tab   \u8203?const\u8203? \{ theme \} = \u8203?await\u8203? getUserPreferences();\par
\u8203? \tab   \u8203?const\u8203? \{ album \} = \u8203?await\u8203? failMusic(theme);\par
\u8203? \tab   \u8203?const\u8203? \{ artist \} = \u8203?await\u8203? getArtist(album);\par
\u8203? \tab   \u8203?return\u8203? artist;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab getArtistByPreference()\par
\u8203? \tab   .then(artist => \{\par
\u8203? \tab     console.log(artist);\par
\u8203? \tab   \})\par
\u8203? \tab   .\u8203?catch\u8203?(e => \{\par
\u8203? \tab     console.error(e);\par
\u8203? \tab   \});\par
\par
async/await functions can clean up your code, but again, use them with caution, particularly when you\rquote re compiling your code to earlier versions of JavaScript.\par
\par
At this point, you have a few tools for handling asynchronous actions, but you\rquote re probably wondering when you\rquote ll actually use them. You use promises in many situations, but the most common is when you\rquote re fetching data from an API.\par
\par
In the next tip, you\rquote ll learn how to access data from an endpoint using fetch.\par
\par
Tip 45\tab Make Simple AJAX Calls with Fetch\par
\par
In this tip, you\rquote ll learn how to retrieve remote data using fetch().\par
\par
If you do any significant JavaScript app development, you\rquote ll have to interact with APIs. With APIs, you can get current information and update single elements without a page refresh. In short, you can create very fast applications that behave like native software.\par
\par
Single-page web apps are part of the reason why JavaScript is so popular, but getting data with AJAX\emdash Asynchronous JavaScript And XML\emdash used to be a hassle. It was such a hassle that most developers used a library, usually jQuery, to to reduce the complexity. You can see the documentation on the Mozilla Developer Network.[46] It\rquote s not easy stuff.\par
\par
Now, there\rquote s a much simpler tool for AJAX calls: fetch(). This tip is a little different than the others. fetch() isn\rquote t part of the JavaScript spec. The fetch spec is defined by the Web Hypertext Application Technology Working Group or WHATWG.[47] That means you\rquote ll be able to find it in most major browsers, but it isn\rquote t natively supported in Node.js. If you want to use it in Node.js, you\rquote ll need to use the node-fetch package.[48]\par
\par
Enough trivia. How does it work?\par
\par
To start, you need an endpoint. The good folks at typicode have an API for fake blog data at {{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/ }}{\fldrslt{https://jsonplaceholder.typicode.com/\ul0\cf0}}}}\f1\fs22 . They also make an amazing tool called JSON Server that enables you to mock APIs locally.[49] JSON Server is a great way to mock APIs that are in development or slow, require authentication, or cost money for each call. You should use it.\par
\par
Now that you have an endpoint, it\rquote s time to make some requests.\par
\par
The first request you\rquote ll make is a simple GET request. If all you\rquote re doing is asking for data, the fetch() call is simple. Call fetch() with the endpoint URL as the argument:\par
externalData/fetch/fetch.js\par
\u8203? \tab fetch(\u8203?'{{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/posts/1 }}{\fldrslt{https://jsonplaceholder.typicode.com/posts/1\ul0\cf0}}}}\f1\fs22 '\u8203?);\par
\par
The response body for this endpoint will be information about a blog post:\par
externalData/fetch/fetch.js\par
\u8203? \tab\{\par
\u8203? \tab   userId: 1,\par
\u8203? \tab   id: 1,\par
\u8203? \tab   title: \u8203?'First Post'\u8203?,\par
\u8203? \tab   body: \u8203?'This is my first post...'\u8203?,\par
\u8203? \tab\};\par
\par
You can\rquote t get much easier than that. After you make the request, fetch() will return a promise that resolves with a response. The next thing you\rquote ll need to do is add a callback function to the then() method to handle the response.\par
\par
Ultimately, you want to get the response body. But the response object contains quite a bit of information beyond the body, including the status code, headers, and more. You\rquote ll see more about the response in a moment.\par
\par
The response body isn\rquote t always in a usable format. You may need to convert it to a format JavaScript can handle. Fortunately, fetch() contains a number of mixins that will automatically convert the response body data. In this case, because you know you\rquote re getting JSON, you can convert the body to JSON by calling json() on the response. The method also returns a promise, so you\rquote ll need another then() method. After that, you can do something with the parsed data. For example, if you want the title only, you can pull it out.\par
externalData/fetch/fetch.js\par
\u8203? \tab fetch(\u8203?'{{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/posts/1 }}{\fldrslt{https://jsonplaceholder.typicode.com/posts/1\ul0\cf0}}}}\f1\fs22 '\u8203?)\par
\u8203? \tab   .then(data => \{\par
\u8203? \tab     \u8203?return\u8203? data.json();\par
\u8203? \tab   \})\par
\u8203? \tab   .then(post => \{\par
\u8203? \tab     console.log(post.title);\par
\u8203? \tab   \});\par
\par
Of course, nothing is ever easy. The fetch() promise will resolve even if you get a failing status code, such as a 404 response. In other words, you can\rquote t rely on a catch() method on the promise to handle failed requests.\par
\par
The response does include a field called ok that\rquote s set to true if the response code is in the 200\endash 299 range. You can check for that response and throw an error if there\rquote s a problem. Unfortunately, Internet Explorer doesn\rquote t include ok, but Edge does. If you need to support older versions of Internet Explorer, you can check response.status to see if the value is between 200 and 299.\par
externalData/fetch/fetch.js\par
\u8203? \tab fetch(\u8203?'{{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/pots/1 }}{\fldrslt{https://jsonplaceholder.typicode.com/pots/1\ul0\cf0}}}}\f1\fs22 '\u8203?)\par
\u8203? \tab   .then(data => \{\par
\u8203? \tab     \u8203?if\u8203? (!data.ok) \{\par
\u8203? \tab       \u8203?throw\u8203? Error(data.status);\par
\u8203? \tab     \}\par
\u8203? \tab     \u8203?return\u8203? data.json();\par
\u8203? \tab   \})\par
\u8203? \tab   .then(post => \{\par
\u8203? \tab     console.log(post.title);\par
\u8203? \tab   \})\par
\u8203? \tab   .\u8203?catch\u8203?(e => \{\par
\u8203? \tab     console.log(e);\par
\u8203? \tab   \});\par
\par
Most of your requests will be simple GET requests. But you\rquote ll eventually need to make more complex requests. What if you wanted to add a new blog post? Easy, make a POST request to {{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/posts }}{\fldrslt{https://jsonplaceholder.typicode.com/posts\ul0\cf0}}}}\f1\fs22 .\par
\par
Once you move beyond GET requests, you\rquote ll need to set a few more options. So far, you\rquote ve only supplied a single argument to fetch()\emdash the URL endpoint. Now you\rquote ll need to pass an object of configuration options as a second argument. The optional object can take a lot of different details. In this case, include only the most necessary information.\par
\par
Because you\rquote re sending a POST request, you\rquote ll need to declare that you\rquote re using the POST method. In addition, you\rquote ll need to pass some JSON data to actually create the new blog post. Because you\rquote re sending JSON data, you\rquote ll need to set a header of Content-Type set to application/json. Finally, you\rquote ll need the body, which will be a single string of JSON data.\par
\par
The final request is nearly identical to your other request, except you pass in the special options as the second argument.\par
externalData/fetch/fetch.js\par
\u8203? \tab\u8203?const\u8203? update = \{\par
\u8203? \tab   title: \u8203?'Clarence White Techniques'\u8203?,\par
\u8203? \tab   body: \u8203?'Amazing'\u8203?,\par
\u8203? \tab   userId: 1,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? options = \{\par
\u8203? \tab   method: \u8203?'POST'\u8203?,\par
\u8203? \tab   headers: \{\par
\u8203? \tab     \u8203?'Content-Type'\u8203?: \u8203?'application/json'\u8203?,\par
\u8203? \tab   \},\par
\u8203? \tab   body: JSON.stringify(update),\par
\u8203? \tab\};\par
\u8203? \tab fetch(\u8203?'{{\field{\*\fldinst{HYPERLINK https://jsonplaceholder.typicode.com/posts }}{\fldrslt{https://jsonplaceholder.typicode.com/posts\ul0\cf0}}}}\f1\fs22 '\u8203?, options).then(data => \{\par
\u8203? \tab   \u8203?if\u8203? (!data.ok) \{\par
\u8203? \tab     \u8203?throw\u8203? Error(data.status);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? data.json();\par
\u8203? \tab\}).then(update => \{\par
\u8203? \tab   console.log(update);\par
\u8203? \tab   \u8203?// \{\u8203?\par
\u8203? \tab   \u8203?//   title: 'Clarence White Techniques',\u8203?\par
\u8203? \tab   \u8203?//   body: 'Amazing',\u8203?\par
\u8203? \tab   \u8203?//   userId: 1,\u8203?\par
\u8203? \tab   \u8203?//   id: 101\u8203?\par
\u8203? \tab   \u8203?// \};\u8203?\par
\u8203? \tab\}).\u8203?catch\u8203?(e => \{\par
\u8203? \tab   console.log(e);\par
\u8203? \tab\});\par
\par
If your request is successful, you\rquote ll get a response body containing the blog post object along with a new ID. The response will vary depending on how the API is set up.\par
\par
While JSON data is probably the most common request body, there are other options, such as FormData. Beyond that, there are even more methods for customizing your request. You can set a mode, a cache method, and so on. Most of these are specialized, but you\rquote ll need them at some point. As always, the best place to find out more is the Mozilla Developer Network.[50]\par
\par
Finally, you should be careful about where you place your AJAX requests in your code. Remember that fetch will most likely need an Internet connection, and endpoints may change during the project. It\rquote s good practice to keep all your fetch actions in one location. This will make them easier to update and easier to test. Check out the code for the book to see how you can create a services directory to store your fetch functions and how you can use them in other functions.\par
\par
In the next tip, you\rquote ll learn how to preserve user data with localStorage.\par
\par
Tip 46\tab Maintain State Over Time with LocalStorage\par
\par
In this tip, you\rquote ll learn how to save user data with localStorage.\par
\par
Users love to personalize applications. Conversely, they hate entering the same data every time they visit an app or a page. When you\rquote re working with front-end JavaScript, you\rquote re in a bit of a bind. How do you preserve user data with minimal interference?\par
\par
An obvious solution is to create a login. The problem is that many users will abandon a site if they\rquote re forced to log in. A better, albeit imperfect, solution is to store data locally. When you save data locally, you can preserve information on a particular browser on a particular device.\par
\par
Of course, everyone uses multiple devices. So saving data to a browser won\rquote t help a user who works across multiple devices. Still, it\rquote s far less intrusive than demanding a user make yet another account.\par
\par
You can easily save user information with localStorage. localStorage is like a tiny database that exists only in your browser. You can add and retrieve information from it, but it isn\rquote t accessible by JavaScript in the browser.\par
\par
Think back to your pet adoption site from Tip 13, \u8203? Update Key-Value Data Clearly with Maps \u8203?. You set up a series of filters to show only relevant pets. Because pet owners tend to prefer certain types of animals\emdash lovers of labradors probably won\rquote t look for tiny dogs\emdash you could do them a favor if you save their searches between sessions.\par
\par
Start by saving a breed preference. To save a breed, you just need to set the value on the localStorage object using the setItem() method. You pass the key as the first argument and the value as the second. The syntax should look familiar. It\rquote s nearly identical to the method for setting data on a map.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? saveBreed(breed) \{\par
\u8203? \tab   localStorage.setItem(\u8203?'breed'\u8203?, breed);\par
\u8203? \tab\}\par
\par
When the user leaves and then returns to the page later, you can pull out the data with a similar command.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? getSavedBreed() \{\par
\u8203? \tab   \u8203?return\u8203? localStorage.getItem(\u8203?'breed'\u8203?);\par
\u8203? \tab\}\par
\par
And if you want to remove an item, you can do that, too.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? removeBreed() \{\par
\u8203? \tab   \u8203?return\u8203? localStorage.removeItem(\u8203?'breed'\u8203?);\par
\u8203? \tab\}\par
\par
Now think about why this is so powerful. You can save user data without requiring any extra effort from the user. That means that when they return to the page or even refresh the page, you can set the application exactly as they left it.\par
\par
For example, when you initialize your filters, you can add in the breed information from localStorage if it exists.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? applyBreedPreference(filters) \{\par
\u8203? \tab   \u8203?const\u8203? breed = getSavedBreed();\par
\u8203? \tab   \u8203?if\u8203? (breed) \{\par
\u8203? \tab     filters.\u8203?set\u8203?(\u8203?'breed'\u8203?, breed);\par
\u8203? \tab   \}\par
\u8203? \tab   \u8203?return\u8203? filters;\par
\u8203? \tab\}\par
\par
Like any object, you can have as many keys as you want. If you wanted to save all your user\rquote s filters, you could save each item individually, but it\rquote s much easier to save the whole group. It\rquote s already structured data, so why spend time taking it apart?\par
\par
The only downside to localStorage is that your value must be a string. You can\rquote t save an array or an object in localStorage. Fortunately, the fix is simple. Just use JSON.stringify() to convert your data to a string and JSON.parse to convert it back to a JavaScript object.\par
\par
If you wanted to save all of your user\rquote s search, you can convert all the filters to a string. Remember that because you were using a map, you\rquote ll need to spread it into an array first.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? savePreferences(filters) \{\par
\u8203? \tab   \u8203?const\u8203? filterString = JSON.stringify([...filters]);\par
\u8203? \tab   localStorage.setItem(\u8203?'preferences'\u8203?, filterString);\par
\u8203? \tab\}\par
\par
When you want to use it, you\rquote ll just need to pull the data from localStorage and convert it back into a map. Of course, if you\rquote re saving objects or arrays, all you need to do is parse the string.\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? retrievePreferences() \{\par
\u8203? \tab   \u8203?const\u8203? preferences = JSON.parse(localStorage.getItem(\u8203?'preferences'\u8203?));\par
\u8203? \tab   \u8203?return\u8203? \u8203?new\u8203? Map(preferences);\par
\u8203? \tab\}\par
\par
And, on occasion, you may just want to get back to a clean slate. In that case, you can remove all key-values with clear().\par
externalData/local/local.js\par
\u8203? \tab\u8203?function\u8203? clearPreferences() \{\par
\u8203? \tab   localStorage.clear();\par
\u8203? \tab\}\par
\par
localStorage is one of those tools that\rquote s simple but incredibly powerful. It will make you users happy and it\rquote s simple to use. The data won\rquote t persist across devices, but the benefit of avoiding a login far outweighs this downside.\par
\par
In addition, you can also temporarily save data with sessionStorage.[51] The usage is identical except sessionStorage doesn\rquote t persist after a tab is closed. This is a great tool when you have a project that mixes server-side rendering and client-side functionality. You can save preferences between page refreshes while also ensuring that the user will have fresh state when they return.\par
\par
You now have the tools to make fully integrated single page applications. Between locally saved information and API access, you only need servers to render the page once. fetch() and localStorage are incredibly simple, but they open the door to limitless opportunities to create powerful software in the browser.\par
\par
In the next chapter, you\rquote ll take a step back and look at how to architect and organize your code when building applications longer than a few lines of code.\par
Footnotes\par
\par
[44]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://www.pluralsight.com/guides/front-end-javascript/introduction-to-asynchronous-javascript }}{\fldrslt{https://www.pluralsight.com/guides/front-end-javascript/introduction-to-asynchronous-javascript\ul0\cf0}}}}\f1\fs22\par
[45]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\ul0\cf0}}}}\f1\fs22\par
[46]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started }}{\fldrslt{https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started\ul0\cf0}}}}\f1\fs22\par
[47]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://fetch.spec.whatwg.org/ }}{\fldrslt{https://fetch.spec.whatwg.org/\ul0\cf0}}}}\f1\fs22\par
[48]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://www.npmjs.com/package/node-fetch }}{\fldrslt{https://www.npmjs.com/package/node-fetch\ul0\cf0}}}}\f1\fs22\par
[49]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/typicode/json-server }}{\fldrslt{https://github.com/typicode/json-server\ul0\cf0}}}}\f1\fs22\par
[50]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\ul0\cf0}}}}\f1\fs22\par
[51]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage\ul0\cf0}}}}\f1\fs22\par
\par
 Chapter 10\par
Gather Related Files with Component Architecture\par
\par
In chess, there\rquote s a distinction between tactics and strategy. Tactics are a series or combination of moves to achieve a goal. It\rquote s short term and fairly easy to define and teach. Strategy, by contrast, is an abstract conception of which side has more influence in a particular part of the board. Tactics solve problems at hand. Strategy allocates resources in anticipation of future problems.\par
\par
Most coding books, including this one, are about tactics. How do you transform an array? How do you write a function that consumes asynchronous data?\par
\par
Now you\rquote re going to learn strategy. In the software development world, organizing code in a way that makes it extendable, reusable, and manageable is called architecture. Instead of solving clear problems, you\rquote re going to learn to split and organize code to make future problems\emdash extending classes, handling edge cases, finding bugs\emdash easier to solve. You got a taste of code architecture when you learned about dependency injection in Tip 32, \u8203?Write Functions for Testability \u8203?. That was the first time you saw how code could be split to keep one function focused and flexible.\par
\par
Most books avoid discussing architecture because it\rquote s messy. The solutions aren\rquote t clear, and you can usually only recognize a mistake months later when it\rquote s too late and too expensive to change the structure of a codebase. In this chapter, you\rquote ll see how to structure a project from the ground up. You\rquote ll learn how to incorporate modern JavaScript tooling to pull the pieces together into a final product.\par
\par
You\rquote ll start off by learning how you can separate code into different files using import and export. Next, you\rquote ll learn how to incorporate third-party code with npm. Then, you\rquote ll learn how to break an application into well-designed pieces using the component architecture pattern. This isn\rquote t the only architecture pattern, but it\rquote s the most popular one now, and it\rquote s very different from most server-side patterns.\par
\par
Next, you\rquote ll combine the pieces into a final, usable asset with build tools. And you\rquote ll finish up by learning how to use CSS to handle animations that used to be the responsibility of JavaScript.\par
\par
This chapter will be a little more difficult. There are more moving pieces, and the examples are more complex, even as they\rquote re still extremely simplified compared to anything you\rquote ll see in production. But if you come away understanding that clean architecture is just as important\emdash and just as achievable\emdash as clean code, I guarantee your projects will benefit.\par
\par
The first step in creating a clean architecture is breaking code into reusable and shareable pieces with import and export. \par
\par
Tip 47\tab Isolate Functionality with Import and Export\par
\par
In this tip, you\rquote ll learn how to share code between files.\par
\par
In the bad old days of JavaScript, you kept all code in a single file. Even worse, developers would put all their JavaScript code in the DOM under a single <script> tag.\par
\par
Things got better slowly. First, someone created code to minify and concatenate files so at least you had only one small import statement. Then projects such as Require.js and CommonJS gave developers a way to share code between files using modules. With the module system, JavaScript developers were finally able to easily reuse code in a project.\par
\par
Modules have been simplified and are now simple import and export statements. And with this simple interface, not only can you share code between files in a project, but you can also use community code with nearly identical syntax. You\rquote ll see more about community code in the next tip. For now, let\rquote s look at how to import and export code.\par
\par
This code won\rquote t work out-of-the box. It\rquote s still a good idea to combine and minify your code to a single file. Eventually, browsers will be able to dynamically import code, but for now, you still need to create single files, often called bundles or packages. You\rquote ll see how in Tip 50, \u8203? Use Build Tools to Combine Components \u8203?.\par
\par
You\rquote ve actually been using exported code throughout the book. You wouldn\rquote t know unless you looked at the book\rquote s source code because the examples hid the code export. Importing and exporting is just that simple. You export any existing code with a single statement.\par
\par
Here\rquote s some code from Tip 36, \u8203? Prevent Context Confusion with Arrow Functions \u8203?:\par
functions/context/method.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessage: field => \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?,\par
\u8203? \tab\};\par
\par
If you want to share the code, you just need to add a simple export statement.\par
functions/context/method.js\par
\u8203? \tab\u8203?const\u8203? validator = \{\par
\u8203? \tab   message: \u8203?'is invalid.'\u8203?,\par
\u8203? \tab   setInvalidMessage: field => \u8203?`\u8203?$\{field\}\u8203? \u8203?$\{\u8203?this\u8203?.message\}\u8203?`\u8203?,\par
\u8203? \tab\};\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ validator \};\par
\par
How does it work? At the most basic level, all you need to do is export an object containing the data you want to share. That means you can export functions, variables, and classes. And you don\rquote t need to export anything. If you choose to export some functions and not others, you\rquote ve essentially created public and private functions.\par
\par
In the preceding example, you exported a single function. In other situations, you may have a function you don\rquote t want to share essentially making it private. In that situation, export all the functions you\rquote re willing to share.\par
\par
Here\rquote s how it would look if you wanted to share two functions while hiding one:\par
architecture/import/single/util.js\par
\u8203? \tab\u8203?function\u8203? getPower(decimalPlaces) \{\par
\u8203? \tab   \u8203?return\u8203? 10 ** decimalPlaces;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? capitalize(word) \{\par
\u8203? \tab   \u8203?return\u8203? word[0].toUpperCase() + word.slice(1);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? roundToDecimalPlace(number, decimalPlaces = 2) \{\par
\u8203? \tab   \u8203?const\u8203? round = getPower(decimalPlaces);\par
\u8203? \tab   \u8203?return\u8203? Math.round(number * round) / round;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ capitalize, roundToDecimalPlace \};\par
\par
Now that you\rquote ve exported the functions, you\rquote ll probably want to use them. To use a function in another file, use the import keyword and the functions you\rquote d like to import to curly braces. After you declare what you\rquote re importing, give the path relative to the file you\rquote re in.\par
\par
You can also import library code and you\rquote ll see how in the next tip. For now, you\rquote re only importing code from other files you own. Try importing some utility functions into a new file. It would look like this:\par
architecture/import/single/bill.js\par
\u8203? \tab\u8203?import\u8203? \{ capitalize, roundToDecimalPlace \} \u8203?from\u8203? \u8203?'./util'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? giveTotal(name, total) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{capitalize(name)\}\u8203?, your total is: \u8203?$\{roundToDecimalPlace(total)\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab giveTotal(\u8203?'sara'\u8203?, 10.3333333);\par
\u8203? \tab\u8203?// "Sara, your total is: 10.33"\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ giveTotal \};\par
\par
You don\rquote t have to import everything. If you want only a single item, that\rquote s fine.\par
architecture/import/single/name.js\par
\u8203? \tab\u8203?import\u8203? \{ capitalize \} \u8203?from\u8203? \u8203?'./util'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? greet(name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Hello, \u8203?$\{capitalize(name)\}\u8203?!`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab greet(\u8203?'ashley'\u8203?);\par
\u8203? \tab\u8203?// Hello, Ashley!\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ greet \};\par
\par
And you don\rquote t have to limit yourself to functions. You can also export variables and classes.\par
architecture/import/single/math.js\par
\u8203? \tab\u8203?const\u8203? PI = 3.14;\par
\u8203? \tab\u8203?const\u8203? E = 2.71828;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ E, PI \};\par
\par
This probably looks familiar. Exporting and importing use nearly the same syntax as destructuring. In fact, if you want you keep all your imports as properties on an object, you simply import everything to a variable name.\par
\par
The syntax is a little different from destructuring. Declare that you\rquote re importing all functions using the asterisks and then give the variable name. You can now call the functions as if they were on an object.\par
architecture/import/each/name.js\par
\u8203? \tab\u8203?import\u8203? * \u8203?as\u8203? utils \u8203?from\u8203? \u8203?'./util'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? greet(name) \{\par
\u8203? \tab   \u8203?return\u8203? \u8203?`Hello, \u8203?$\{utils.capitalize(name)\}\u8203?!`\u8203?;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab greet(\u8203?'ashley'\u8203?);\par
\u8203? \tab\u8203?// Hello, Ashley!\u8203?\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \{ greet \};\par
\par
As with destructuring, you can also rename functions or data you import. The syntax is slightly different. Instead of a colon, like you\rquote d use in destructuring, you use the keyword as to assign the data to a new variable.\par
\par
Exports are already simple, but there are a few shortcuts that make things even easier.\par
\par
Instead of declaring an object and adding each piece of data at the end, you can add the export keyword before each function. This makes your code even easier because you don\rquote t need an object at the bottom of the file.\par
architecture/import/each/util.js\par
\u8203? \tab\u8203?function\u8203? getPower(decimalPlaces) \{\par
\u8203? \tab   \u8203?return\u8203? 10 ** decimalPlaces;\par
\u8203? \tab\}\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? capitalize(word) \{\par
\u8203? \tab   \u8203?return\u8203? word[0].toUpperCase() + word.slice(1);\par
\u8203? \tab\}\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? roundToDecimalPlace(number, decimalPlaces = 2) \{\par
\u8203? \tab   \u8203?const\u8203? round = getPower(decimalPlaces);\par
\u8203? \tab   \u8203?return\u8203? Math.round(number * round) / round;\par
\u8203? \tab\}\par
\par
Exporting functions one at a time doesn\rquote t change how you import. You can use any of the techniques mentioned.\par
\par
As you start to separate out your code, you\rquote ll often have files that contain a single entry point. Or you may have a function that\rquote s more important. In those situations, you can declare a default export. This will make the import process a little shorter.\par
\par
Consider a file that converts an address object to a string. The main goal of the utility is to convert an object. There\rquote s a clear default export. But you may still want to share some helper functions.\par
\par
Add the keyword default after the export keyword on normalize() to make it the main export. Add export to any remaining functions.\par
architecture/import/default/address.js\par
\u8203? \tab\u8203?import\u8203? \{ capitalize \} \u8203?from\u8203? \u8203?'../single/util'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? parseRegion(address) \{\par
\u8203? \tab   \u8203?const\u8203? region = address.state || address.providence || \u8203?''\u8203?;\par
\u8203? \tab   \u8203?return\u8203? region.toUpperCase();\par
\u8203? \tab\}\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? parseStreet(\{ street \}) \{\par
\u8203? \tab   \u8203?return\u8203? street.split(\u8203?' '\u8203?)\par
\u8203? \tab     .map(part => capitalize(part))\par
\u8203? \tab     .join(\u8203?' '\u8203?);\par
\u8203? \tab\}\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? normalize(address) \{\par
\u8203? \tab   \u8203?const\u8203? street = parseStreet(address);\par
\u8203? \tab   \u8203?const\u8203? city = address.city;\par
\u8203? \tab   \u8203?const\u8203? region = parseRegion(address);\par
\u8203? \tab   \u8203?return\u8203? \u8203?`\u8203?$\{street\}\u8203? \u8203?$\{city\}\u8203?, \u8203?$\{region\}\u8203?`\u8203?;\par
\u8203? \tab\}\par
\par
Now when you want to import normalize(), you use the same syntax but without the curly braces. If you don\rquote t use curly braces, you\rquote ll get the default export and nothing else. You don\rquote t need to use the exact function name\emdash you can import the default to any variable name you want\emdash but it\rquote s a good idea to use the same name as the default to keep things readable.\par
architecture/import/default/mail.js\par
\u8203? \tab\u8203?import\u8203? normalize \u8203?from\u8203? \u8203?'./address'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getAddress(user) \{\par
\u8203? \tab   \u8203?return\u8203? normalize(user.address);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? getAddress;\par
\par
If you want to import the default function along with some other functions, you can mix and match import statements. Separate the default and the curly brace import using a comma.\par
architecture/import/default/list.js\par
\u8203? \tab\u8203?import\u8203? normalize, \{ parseRegion \} \u8203?from\u8203? \u8203?'./address'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? getAddress(user) \{\par
\u8203? \tab   \u8203?return\u8203? normalize(user.address);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? getAddressByRegion(users) \{\par
\u8203? \tab   \u8203?return\u8203? users.reduce((regions, user) => \{\par
\u8203? \tab     \u8203?const\u8203? \{ address \} = user;\par
\u8203? \tab     \u8203?const\u8203? region = parseRegion(address);\par
\u8203? \tab     \u8203?const\u8203? addresses = regions[region] || [];\par
\u8203? \tab     regions[region] = [...addresses, normalize(address)];\par
\u8203? \tab     \u8203?return\u8203? regions;\par
\u8203? \tab   \}, \{\});\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?const\u8203? bars = [\par
\u8203? \tab   \{\par
\u8203? \tab     name: \u8203?'Saint Vitus'\u8203?,\par
\u8203? \tab     address: \{\par
\u8203? \tab       street: \u8203?'1120 manhattan ave'\u8203?,\par
\u8203? \tab       city: \u8203?'Brooklyn'\u8203?,\par
\u8203? \tab       state: \u8203?'NY'\u8203?,\par
\u8203? \tab     \},\par
\u8203? \tab   \},\par
\u8203? \tab ];\par
\u8203? \tab getAddressByRegion(bars);\par
\u8203? \tab\u8203?// \{\u8203?\par
\u8203? \tab\u8203?//    NY: ["1120 Manhattan Ave Brooklyn, NY"]\u8203?\par
\u8203? \tab\u8203?// \}\u8203?\par
\par
Default imports are particularly useful on classes because there should be only one class per file, so there\rquote s no reason to export other code.\par
architecture/import/class/address.js\par
\u8203? \tab\u8203?import\u8203? \{ capitalize \} \u8203?from\u8203? \u8203?'../single/util'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?class\u8203? Address \{\par
\u8203? \tab   \u8203?constructor\u8203?(address) \{\par
\u8203? \tab     \u8203?this\u8203?.address = address;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   normalize() \{\par
\u8203? \tab     \u8203?const\u8203? street = \u8203?this\u8203?.parseStreet(\u8203?this\u8203?.address);\par
\u8203? \tab     \u8203?const\u8203? city = \u8203?this\u8203?.address.city;\par
\u8203? \tab     \u8203?const\u8203? region = \u8203?this\u8203?.parseRegion(\u8203?this\u8203?.address);\par
\u8203? \tab     \u8203?return\u8203? \u8203?`\u8203?$\{street\}\u8203? \u8203?$\{city\}\u8203?, \u8203?$\{region\}\u8203?`\u8203?;\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   parseStreet(\{ street \}) \{\par
\u8203? \tab     \u8203?return\u8203? street.split(\u8203?' '\u8203?)\par
\u8203? \tab       .map(part => capitalize(part))\par
\u8203? \tab       .join(\u8203?' '\u8203?);\par
\u8203? \tab   \}\par
\u8203? \tab\par
\u8203? \tab   parseRegion(address) \{\par
\u8203? \tab     \u8203?const\u8203? region = address.state || address.providence || \u8203?''\u8203?;\par
\u8203? \tab     \u8203?return\u8203? region.toUpperCase();\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
As you can see, imports and exports are so intuitive there\rquote s not really much to say. But there is one slight problem\emdash because you can split code easily, your projects will start to grow. Don\rquote t worry, though. As your project grows, you can split code into different files. This will let you organize code more efficiently and logically. In Tip 49, \u8203? Build Applications with Component Architecture \u8203?, you\rquote ll learn one way to organize code. But before you get to that point, you\rquote ll almost certainly want to use code outside your own codebase. Fortunately, that\rquote s easier than ever.\par
\par
In the next tip, you\rquote ll learn how to use community code with npm.\par
\par
Tip 48\tab Leverage Community Knowledge with npm\par
\par
In this tip, you\rquote ll learn how to import external code with npm.\par
\par
In the previous tip, you learned how to use code from different files. In this tip, you\rquote ll learn how to use community code created by developers all over the world.\par
\par
Not many years ago, if you wanted to use an open source library, you were forced to either copy-paste code locally, download a library to your project, or include an external dependency using a <script> tag in your markup.\par
\par
You\rquote d get your code\emdash unless an external source went down\emdash but it was hard to keep dependencies up to date, particularly if you were storing them locally. Not only was it hard to maintain, but you also had to write your custom code assuming the library would be there. This made code really hard to read and test because you never explicitly included anything.\par
\par
Those days are gone. You can now download code directly to your project, control versions, and import code into individual files using familiar conventions.\par
\par
You manage all this with a tool called the node package manager, or npm. There are a few alternatives, such as Facebook\rquote s yarn project, but they work in mostly the same way, so don\rquote t worry too much about the differences.\par
\par
npm is an important project, and you\rquote ll mostly use it for importing code, but it can do a lot more. With npm, you can set your project\rquote s metadata and configuration information, run command-line scripts, and even publish your project for others to use.\par
\par
Before you begin, you\rquote ll need to have Node.js installed. But after that, you\rquote re ready to go. When you install Node.js, you also install npm.\par
\par
After Node.js and npm are installed, you need to initialize a project. Open up a terminal, go to the root of your project, and type npm init. This will start up a configuration tool that will create a package.json file for you.\par
\par
This package.json file will contain metadata information for your project, such as name, description, license, and so on. It will eventually contain all the external code dependencies. It\rquote s important to note that npm init only creates the package.json file. It doesn\rquote t set any other hidden files or directories. You don\rquote t need to worry about cluttering your file system.\par
\par
If you aren\rquote t sure what you want, don\rquote t worry. You can change all of that information later. Go with the defaults at first if you have any doubts. When you finish, you\rquote ll have a file that looks like this:\par
architecture/npm/defaults/package.json\par
\u8203? \tab\{\par
\u8203? \tab   \u8203?"name"\u8203?: \u8203?"test"\u8203?,\par
\u8203? \tab   \u8203?"version"\u8203?: \u8203?"1.0.0"\u8203?,\par
\u8203? \tab   \u8203?"description"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"main"\u8203?: \u8203?"index.js"\u8203?,\par
\u8203? \tab   \u8203?"scripts"\u8203?: \{\par
\u8203? \tab     \u8203?"test"\u8203?: \u8203?"echo \u8203?\u8203?\\"\u8203?\u8203?Error: no test specified\u8203?\u8203?\\"\u8203?\u8203? && exit 1"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"author"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"license"\u8203?: \u8203?"ISC"\u8203?\par
\u8203? \tab\}\par
\par
Pretty simple. It\rquote s just an object containing most of the information you just entered. The only surprise is the scripts field. This is where you\rquote d add command-line scripts. You\rquote ll see some more of this in a bit.\par
\par
Don\rquote t let the slimness of the file fool you. This is the most important entry point for a large JavaScript application. It\rquote s also where you store information about external dependencies.\par
\par
Let\rquote s say you\rquote re building a collection with maps and you wanted to convert an object to a map. You could write some code to convert the object to a map, but you really just want a quick solution. With some research, you\rquote d likely come across Lodash\emdash a suite of tools for converting data.[52] How do you get the code into your project?\par
\par
In addition to structuring your project, npm is also a resource for sharing code. Better still, npm tracks data such as number of downloads, number of open bugs, versions, and so on.\par
\par
If you open the npm page for the Lodash package,[53] you\rquote ll see that it\rquote s been downloaded about 50 million times per month. In essence, 50 million projects are giving Lodash a stamp of approval.\par
\par
The data collected by npm is a tacit endorsement by the greater JavaScript community. You don\rquote t need to avoid code from rarely used projects, but you may want to investigate the code before bringing it into your codebase. Fortunately, there\rquote s always a link to the code base, so you can check it out yourself if you aren\rquote t sure.\par
Evaluating Open Source Code\par
\par
There\rquote s a lot of open source code in the world. But not all code is equal. npm doesn\rquote t approve code before it\rquote s published (although npm will remove malicious code) so you\rquote re responsible for evaluating code you want to include in your project.\par
\par
The best place to start is the download count. If there\rquote s a large number of monthly downloads, it\rquote s probably safe code. Trust the community to do some of the vetting for you.\par
\par
Next, look at the issue count. If there are lots of issues, that\rquote s a sign the project is poorly maintained. Keep bugs in context, though. A large project with lots of downloads will probably have more bugs due to sheer volume.\par
\par
After that, dive into the open source code directly. npm will always have a link to the codebase. The code is usually on github, but you\rquote ll also see gitlab and bitbucket. Head over there and look through the project. The two most important things you\rquote ll see are the latest commit date and the pull requests.\par
\par
If the code doesn\rquote t have a commit in the last six months, you should probably move on. It may be abandoned.\par
\par
A pull request is when someone submits a code update. These must be approved by the maintainer before it\rquote s included. If there are stale merge requests, it\rquote s another clue that the code isn\rquote t well managed. Nothing is more frustrating than submitting a merge request and watching it linger for months or even years.\par
\par
Finally, when in doubt, look at the actual code. Sometimes it\rquote s hard to find your way around, but it\rquote s a good exercise, and you can usually tell at a glance if the code is well-structured. If things are neat and organized, and follow standard conventions, then you\rquote re probably safe. If the code is cluttered with syntax errors, you should run away screaming. If you wouldn\rquote t accept the code in your own code base, don\rquote t include the project. After all, when you import the code, you are accepting it into your code base.\par
\par
Trust your intuition. It\rquote s better to look for other projects or pull out parts of an open source library with good old copy-paste than to include a project that may be bloated or buggy.\par
\par
Once you\rquote re satisfied that code is worth using, you can install it in your project by running npm install --save lodash. It\rquote s not strictly necessary to use the --save flag, but it\rquote s a good habit because there are two types of code you\rquote ll install. More on that in a bit.\par
\par
The npm install command does a few things. If there isn\rquote t a node_modules directory, the command will create one and copy down the package. Next, it updates your package.json to include the version number of the code you\rquote re importing. Finally, it will create a package-lock.json file that includes detailed information about the version of the installed code along with any other libraries that the code requires.\par
\par
When you install one package, you may actually install several packages. They\rquote ll all be in your package-lock.json or your node_modules/ directory. The original code you installed, lodash, will be the only code to appear in your package.json file. This is so other developers can see what top-level projects you need without getting stuck in the details of dependencies.\par
\par
Here\rquote s your updated package.json file. Note that it now has a dependencies field.\par
architecture/npm/save/package.json\par
\u8203? \tab\{\par
\u8203? \tab   \u8203?"name"\u8203?: \u8203?"test"\u8203?,\par
\u8203? \tab   \u8203?"version"\u8203?: \u8203?"1.0.0"\u8203?,\par
\u8203? \tab   \u8203?"description"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"main"\u8203?: \u8203?"index.js"\u8203?,\par
\u8203? \tab   \u8203?"scripts"\u8203?: \{\par
\u8203? \tab     \u8203?"test"\u8203?: \u8203?"echo \u8203?\u8203?\\"\u8203?\u8203?Error: no test specified\u8203?\u8203?\\"\u8203?\u8203? && exit 1"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"author"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"license"\u8203?: \u8203?"ISC"\u8203?,\par
\u8203? \tab   \u8203?"dependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"lodash"\u8203?: \u8203?"^4.17.4"\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Now that you have your code, it\rquote s time to use it. Importing the code is simple. You use the same import command from the previous tip, but because you\rquote re installing a library, you don\rquote t need to give a path.\par
\par
Here\rquote s how you\rquote d import lodash. You can either import an individual function, such as fromPairs(), or you can import the default object. The default lodash import actually contains fromPairs(), but some libraries split things out.\par
architecture/npm/utils/merge.js\par
\u8203? \tab\u8203?import\u8203? lodash, \{ fromPairs \} \u8203?from\u8203? \u8203?'lodash'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? mapToObject(map) \{\par
\u8203? \tab   \u8203?return\u8203? fromPairs([...map]);\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?function\u8203? objectToMap(object) \{\par
\u8203? \tab   \u8203?const\u8203? pairs = lodash.toPairs(object);\par
\u8203? \tab   \u8203?return\u8203? \u8203?new\u8203? Map(pairs);\par
\u8203? \tab\}\par
\par
Looks pretty familiar, huh? The nice part is that no matter where you import the code, you use the same syntax. And when you\rquote re reading the code, it\rquote s easy to see what functions are from outside the code base. Anything that doesn\rquote t use a relative import must be external code.\par
\par
If npm only tracked dependencies, it would be a great project, but it does more. You\rquote ll often need code that does work on the codebase but isn\rquote t part of the production build.\par
\par
For example, you\rquote ll want a test runner, but you don\rquote t need the test runner to be in your production code. npm will handle the development dependencies and give you clean interface for running them.\par
\par
Say you wanted to add prettier[54] to your project. Prettier is a tool for formatting your code to match style guides. It\rquote s a tool for development, not a production dependency.\par
\par
Because you don\rquote t need it in production, you\rquote d install it with the npm install --save-dev prettier flag. Notice that you\rquote re using the --save-dev flag. This will also update your package.json file, but it will put the dependency under a different key.\par
architecture/npm/saveDev/package.json\par
\u8203? \tab\{\par
\u8203? \tab   \u8203?"name"\u8203?: \u8203?"test"\u8203?,\par
\u8203? \tab   \u8203?"version"\u8203?: \u8203?"1.0.0"\u8203?,\par
\u8203? \tab   \u8203?"description"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"main"\u8203?: \u8203?"index.js"\u8203?,\par
\u8203? \tab   \u8203?"scripts"\u8203?: \{\par
\u8203? \tab     \u8203?"test"\u8203?: \u8203?"echo \u8203?\u8203?\\"\u8203?\u8203?Error: no test specified\u8203?\u8203?\\"\u8203?\u8203? && exit 1"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"author"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"license"\u8203?: \u8203?"ISC"\u8203?,\par
\u8203? \tab   \u8203?"dependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"lodash"\u8203?: \u8203?"^4.17.4"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"devDependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"prettier"\u8203?: \u8203?"^1.8.2"\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Of course, now you probably want to use it. Prettier is installed in your node_modules directory, which means you can\rquote t access it on the command line directly. Let\rquote s say you wanted to make sure all tabs have a width of four spaces. The documentation says you can convert code by running this command: prettier --tab-width=4 --write ./code/*.js.\par
\par
The command won\rquote t work if you installed the code locally. If you installed the package globally\emdash npm install -g prettier\emdash then you\rquote d be able to run the command, but then the package wouldn\rquote t live specifically in your project. You\rquote d have to somehow communicate to other developers the project has a global dependency.\par
\par
You can solve the problem using npm scripts. With an npm script, you run the exact same command, but the script looks in the node_modules directory. To run the command, add it to the script object of your package.json file. Change the scripts object to include a key of clean with a value of prettier --tab-width=4 --write./code/*.js.\par
\par
Now, when you\rquote re in the same directory as your package.json file, you can run npm run clean and npm will execute the command using the locally installed prettier package.\par
architecture/npm/script/package.json\par
\u8203? \tab\{\par
\u8203? \tab   \u8203?"name"\u8203?: \u8203?"test"\u8203?,\par
\u8203? \tab   \u8203?"version"\u8203?: \u8203?"1.0.0"\u8203?,\par
\u8203? \tab   \u8203?"description"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"main"\u8203?: \u8203?"index.js"\u8203?,\par
\u8203? \tab   \u8203?"scripts"\u8203?: \{\par
\u8203? \tab     \u8203?"clean"\u8203?: \u8203?"prettier --tab-width=4 --write ./code/*.js"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"author"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"license"\u8203?: \u8203?"ISC"\u8203?,\par
\u8203? \tab   \u8203?"dependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"lodash"\u8203?: \u8203?"^4.17.4"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"devDependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"prettier"\u8203?: \u8203?"^1.8.2"\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Try it out. Clone the code for this book; then navigate to architecture/npm/script, and run npm install and then npm run clean, and prettier will update the code to have a tab-width of four spaces.\par
\par
Not only is the dependency scoped to your local project, but other developers can see your build process, dependencies, and package information in a single file.\par
\par
It\rquote s hard to overstate how valuable npm is for JavaScript development. If you ever start looking through a new project, you should begin by skimming the package.json file.\par
\par
Now that you have the tools to combine multiple files and code from open source projects, it\rquote s time to think about how to organize your code.\par
\par
In the next tip, you\rquote ll learn how to organize project assets in a single directory with component architecture.\par
\par
Tip 49\tab Build Applications with Component Architecture\par
\par
In this tip, you\rquote ll learn how to gather related HTML, JavaScript, and CSS together using component architecture.\par
\par
Organizing files can be a challenge. Front-end code\emdash HTML, CSS, JavaScript\emdash can be particularly challenging because the code is made of different languages and file types.\par
\par
Do you arrange code by file type? What about when CSS is tied to a single HTML file? Do you keep them in different directories but with similar file names?\par
\par
For a long time, developers would keep files separated by type. The root directory would contain a css directory, a js directory, an img directory, and so on.\par
\par
Organizing files like this showed good intentions. Everyone wanted to keep different areas of concern separate. The HTML markup (what a site contains) is different from the CSS (how a site looks), which is different from the JavaScript (how a site responds). It seemed like they should be in separate directories.\par
\par
The problem was that the pieces aren\rquote t really separate concerns. Except for a few global styles, CSS is built to work with specific markup. What happens when that markup is removed? If you have disciplined developers, they\rquote d remove the relevant CSS. But most of the time, it stayed. It was never used\emdash it just took up space.\par
\par
As developer tools improved, a new pattern emerged. The new pattern is component architecture. A component is the combination of all relevant code into a single directory. You then build a web page or application by adding pieces one at a time\emdash a button is in a sidebar, which is in a page\emdash until you have your working application.\par
\par
Component architecture isn\rquote t without problems. The biggest problem with component architecture is that it depends on build tools and, to a lesser extent, frameworks. In this tip, you\rquote ll be working with React code. You\rquote re going to use scaffolding developed by create-react-app.[55] This means you don\rquote t have to worry about setting up the build system. You\rquote ll explore that a little in the next tip.\par
\par
It\rquote s important to understand, however, that component architecture is not React specific. You can apply the idea in a variety of frameworks. Cody Lindley wrote a great article on the subject.[56] Still, a framework saves some of the trouble of laying a foundation.\par
\par
To see component architecture at work, build a basic component: a copyright statement. A copyright statement contains the current year, a declaration of copyright, and some styling. With component architecture, you combine everything into a simple package. Here\rquote s an example:\par
architecture/component/simplifying-js-component/src/components/Copyright/Copyright.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\u8203?import\u8203? \u8203?'./Copyright.css'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? CopyrightStatement() \{\par
\u8203? \tab   \u8203?const\u8203? year = \u8203?new\u8203? Date().getFullYear();\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <div className=\u8203?"copyright"\u8203?>\par
\u8203? \tab       Copyright \{year\}\par
\u8203? \tab     <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
To start off, notice that the markup is in a return statement, and the CSS class is called className. Don\rquote t worry about that. The specialized markup is called JSX and it\rquote s part of the React framework. You can pretend that the HTML is a separate thing. It effectively is separate. For purposes of this tip, it\rquote s just markup that happens to live inside a JavaScript function.\par
\par
Next, notice the path to the code at the top of the sample. Most of the time, you can ignore it, but in this case, it\rquote s relevant. simplifying-js-component is the root of the project. The code lives inside the src/components directory. There\rquote s also a public directory that will eventually contain the compiled code. A browser can\rquote t handle components, so everything will eventually combine to simpler components.\par
\par
The components directory contains every component you work with. Each component will then have its own separate directory. In this case, there\rquote s a directory called Copyright that contains Copyright.css, Copyright.js, and Copyright.spec.js. The capitalized names are also a React convention.\par
\par
The Copyright directory contains everything the copyright component will need. If you wanted to share the component, you could put it in a separate repo or just copy and paste it in another project. If you decide you don\rquote t want the copyright anymore, you can delete the whole directory. You wouldn\rquote t need to worry that dead CSS lives somewhere else. Everything is together.\par
\par
Speaking of CSS, notice how this file imports the CSS directly. Because you aren\rquote t importing an object from the CSS, you merely include the whole file. The build tools will know what to do with it. The CSS file for this example is very short. All it contains is the font-size, margin, and float.\par
architecture/component/simplifying-js-component/src/components/Copyright/Copyright.css\par
\u8203? \tab .copyright \{\par
\u8203? \tab     font-size: 10px;\par
\u8203? \tab     margin: 1em 1em 1em 0;\par
\u8203? \tab     float: left;\par
\u8203? \tab\}\par
\par
In the JavaScript file, you get the current year and add it to the markup. Notice how simple this is. Everything you need to know about that copyright statement is in a single place. You don\rquote t need to guess if the year is calculated or hard coded. It\rquote s right there with the markup. You don\rquote t need to search for the CSS if you need to change a margin. It\rquote s in the same directory.\par
\par
How about a slightly more complicated component? Think about a button that has an icon. The button will need styling and markup, but it will also need the image asset and a click action.\par
\par
This time, you also want to make the component reusable. That means you should hard code as few options as you can. Don\rquote t explicitly say what happens on click. Instead, inject the click action into a component. Passing in actions or assets to a component is another form of dependency injection that you explored in Tip 32, \u8203?Write Functions for Testability \u8203?. It keeps things flexible and reusable.\par
architecture/component/simplifying-js-component/src/components/IdeaButton/IdeaButton.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\u8203?import\u8203? \u8203?'./IdeaButton.css'\u8203?;\par
\u8203? \tab\u8203?import\u8203? idea \u8203?from\u8203? \u8203?'./idea.svg'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? IdeaButton(\{ handleClick, message \}) \{\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <button\par
\u8203? \tab       className=\u8203?"idea-button"\u8203?\par
\u8203? \tab       onClick=\{handleClick\}\par
\u8203? \tab     >\par
\u8203? \tab       <img\par
\u8203? \tab         className=\u8203?"idea-button__icon"\u8203?\par
\u8203? \tab         src=\{idea\}\par
\u8203? \tab         alt=\u8203?"idea icon"\u8203?\par
\u8203? \tab       />\par
\u8203? \tab       \{ message \}\par
\u8203? \tab     <\u8203?/button\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
In React, you can access the injected dependencies in the arguments of a function. And you can pull them apart using destructuring. The message will change depending on what\rquote s injected. The curly braces are a templating language, and they surround variable information. In other words, the button will contain the value of the message variable.\par
\par
Notice also that you\rquote re importing an image. Unlike when you import the CSS without ever using it, in this case, you\rquote re importing the image to a variable. The variable contains the path of the image, so set the src to the variable using the curly braces.\par
\par
Now that you have the pieces, you can start building a page. In this case, the page is just another component! This page will contain the idea button and the copyright notice in a footer. You\rquote re still in React territory, so you inject the message as a special HTML attribute. Other frameworks use different conventions to inject data. But they all allow you to pass in some information\emdash this is what makes components so powerful.\par
architecture/component/simplifying-js-component/src/App.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?import\u8203? \u8203?'./App.css'\u8203?;\par
\u8203? \tab\u8203?import\u8203? IdeaButton \u8203?from\u8203? \u8203?'./components/IdeaButton/IdeaButton'\u8203?;\par
\u8203? \tab\u8203?import\u8203? Copyright \u8203?from\u8203? \u8203?'./components/Copyright/Copyright'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?function\u8203? logIdea() \{\par
\u8203? \tab   console.log(\u8203?'Someone had an idea!'\u8203?);\par
\u8203? \tab\}\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? App() \{\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <div className=\u8203?"main"\u8203?>\par
\u8203? \tab       <div className=\u8203?"app"\u8203?>\par
\u8203? \tab         <IdeaButton\par
\u8203? \tab           message=\u8203?"I have an idea!"\u8203?\par
\u8203? \tab           handleClick=\{logIdea\}\par
\u8203? \tab         \u8203?/\u8203?\u8203?>\u8203?\par
\u8203? \tab       <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab       <footer>\par
\u8203? \tab         <Copyright />\par
\u8203? \tab         <IdeaButton\par
\u8203? \tab           message=\u8203?"Footer idea!"\u8203?\par
\u8203? \tab           handleClick=\{logIdea\}\par
\u8203? \tab         \u8203?/\u8203?\u8203?>\u8203?\par
\u8203? \tab       <\u8203?/footer\u8203?\u8203?>\u8203?\par
\u8203? \tab     <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
Because App.js is the main component, it lives at the root of the source code. Otherwise, it\rquote s the same. It imports code, it contains all the pieces, and it combines them together. In this case, you\rquote re reusing the button component twice. Each one will have a different message. As you can see in the following figure, the result isn\rquote t stunning, but it does show each piece.\par
images/component.png\par
\par
Download the source code and try it out. The code contains a README.md, which will get you up and running with only two commands. After that, try changing some CSS. Try adding a new image. You\rquote ll see how simple it is to work with components when everything is in one logical place.\par
\par
If you inspected the page, you\rquote d notice something interesting. You combined the separate CSS files into a single file and moved that file to a separate css directory. The same thing happened to images. In this case, the build tools still separate out the pieces into different directories. That\rquote s great! There\rquote s nothing wrong with having pieces separate at the user level. The goal is to make development easier.\par
\par
Intuitively, component architecture probably makes sense. Keep like things together. The only downside is that wiring everything together isn\rquote t easy. The only reason component architecture works is because you can use great tools that intelligently combine code.\par
\par
In the next tip, you\rquote ll learn how to compile front-end code with build tools.\par
\par
Tip 50\tab Use Build Tools to Combine Components\par
\par
In this tip, you\rquote ll learn how to compile JavaScript code and assets with build tools.\par
\par
In the previous tip, you saw the advantages of the component architecture. You also learned about the one big problem with component architecture: It won\rquote t work natively in browsers.\par
\par
Also in the previous tip, you used the tools provided by create-react-app[57] to get your project compiled and running. That\rquote s great. You should always take advantage of predesigned build tools. Every project has one. Sometimes there are official projects\emdash angular-cli and EmberCLI are examples\emdash and if there are no official projects, search code repos such as github for Starter Packs. Eventually, however, you\rquote ll need to customize your build.\par
\par
In this tip, you\rquote re going to make a basic build process. Build tools can be exhausting, and it can be difficult to keep up with the latest trends and tools. Don\rquote t get discouraged. A build tool is merely a way for you to process the code one piece at a time.\par
\par
To begin, take a simplified version of your components from the previous tip. Start by removing everything except for some HTML, in the form of React JSX, and some JavaScript. It\rquote ll be easier to make build tools when you have fewer assets. Here\rquote s a basic container component:\par
architecture/build/initial/src/App.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?import\u8203? Copyright \u8203?from\u8203? \u8203?'./components/Copyright/Copyright'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? App() \{\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <div className=\u8203?"main"\u8203?>\par
\u8203? \tab       <footer>\par
\u8203? \tab         <Copyright />\par
\u8203? \tab       <\u8203?/footer\u8203?\u8203?>\u8203?\par
\u8203? \tab     <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
Here\rquote s a stripped down version of your copyright component:\par
architecture/build/initial/src/components/Copyright/Copyright.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? CopyrightStatement() \{\par
\u8203? \tab   \u8203?const\u8203? year = \u8203?new\u8203? Date().getFullYear();\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <div className=\u8203?"copyright"\u8203?>\par
\u8203? \tab       Copyright \{year\}\par
\u8203? \tab     <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
Even though these files are simple, you couldn\rquote t run them in a browser. And even if you could, you certainly wouldn\rquote t be able to run them in older browsers. You need a tool to convert ES6 syntax\emdash import and export\emdash  and JSX into compatible code.\par
\par
Fortunately, there\rquote s an amazing tool called Babel[58] that can convert bleeding-edge JavaScript to browser-friendly code. Babel is the single-most important tool you have for working with modern JavaScript. Not only does it convert your ES6+ JavaScript, but you can even configure Babel to use syntax that\rquote s still in committee.\par
\par
To get started, you need to install the Babel command-line interface (cli) along with the preset-env to convert ES6+ and babel-present-react to convert react code.\par
\par
The installation command should look familiar. This time, you\rquote re installing three packages with a single command.\par
\par
npm install --save-dev babel-cli babel-preset-env babel-preset-react\par
\par
The next thing you need to do is set up a .babelrc file to hold your configuration information. This file tells Babel what kind of code you have and how Babel will need to convert it. In this case, you have ES6 code\emdash signified with env\emdash and react code.\par
architecture/build/initial/.babelrc\par
\u8203? \tab\{ "presets": ["env", "react"] \}\par
\par
Now add a script to your package.json file and you\rquote ll be ready to compile. Notice that you\rquote re outputting the compiled information to a single file, bundle.js, in the build directory. Here\rquote s your final package.json.\par
architecture/build/initial/package.json\par
\u8203? \tab\{\par
\u8203? \tab   \u8203?"name"\u8203?: \u8203?"initial"\u8203?,\par
\u8203? \tab   \u8203?"version"\u8203?: \u8203?"1.0.0"\u8203?,\par
\u8203? \tab   \u8203?"description"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"main"\u8203?: \u8203?"index.js"\u8203?,\par
\u8203? \tab   \u8203?"scripts"\u8203?: \{\par
\u8203? \tab     \u8203?"build"\u8203?: \u8203?"babel src/index.js -o build/bundle.js"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"keywords"\u8203?: [],\par
\u8203? \tab   \u8203?"author"\u8203?: \u8203?""\u8203?,\par
\u8203? \tab   \u8203?"license"\u8203?: \u8203?"ISC"\u8203?,\par
\u8203? \tab   \u8203?"devDependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"babel-cli"\u8203?: \u8203?"^6.26.0"\u8203?,\par
\u8203? \tab     \u8203?"babel-preset-env"\u8203?: \u8203?"^1.6.1"\u8203?,\par
\u8203? \tab     \u8203?"babel-preset-react"\u8203?: \u8203?"^6.24.1"\u8203?\par
\u8203? \tab   \},\par
\u8203? \tab   \u8203?"dependencies"\u8203?: \{\par
\u8203? \tab     \u8203?"react"\u8203?: \u8203?"^16.1.1"\u8203?,\par
\u8203? \tab     \u8203?"react-dom"\u8203?: \u8203?"^16.1.1"\u8203?\par
\u8203? \tab   \}\par
\u8203? \tab\}\par
\par
Finally, update your index.html to use the compiled code:\par
architecture/build/initial/index.html\par
\u8203? \tab\u8203?<!DOCTYPE html>\u8203?\par
\u8203? \tab <html lang=\u8203?"en"\u8203?>\par
\u8203? \tab   <head>\par
\u8203? \tab     <title>Sample</title>\par
\u8203? \tab   </head>\par
\u8203? \tab   <body>\par
\u8203? \tab     <div id=\u8203?"root"\u8203?>\par
\u8203? \tab     </div>\par
\u8203? \tab     <script src=\u8203?"./build/bundle.js"\u8203?></script>\par
\u8203? \tab   </body>\par
\u8203? \tab\par
\u8203? \tab </html>\par
\par
If you try to open that file in a browser, you\rquote ll encounter a problem. The console will display an error: Uncaught ReferenceError: require isn\rquote t defined.\par
\par
Babel converts the code, but it doesn\rquote t include a module loader, which handles the compiled imports and exports. You have a few options for module loaders. Currently, the most popular module loaders are webpack[59] and rollup.js.[60] In this example, you\rquote ll use webpack.\par
\par
Webpack is a project that can handle everything from combining your JavaScript, to processing your CSS or SASS, to image conversion. Webpack can handle so many file types because you declare different actions\emdash referred to as loaders in webpack\emdash based on file extension.\par
\par
To get webpack working, you\rquote ll need to install it. You\rquote ll also need to install a loader for Babel. The webpack documentation encourages you to think of loaders as a task in another build tool.[61] Because compiling the code with Babel is just a step in getting usable JavaScript, you\rquote ll need the babel-loader. You can install them both in the same command: npm install --save-dev babel-loader webpack.\par
\par
You\rquote ll also need to create a webpack.config.js file. Inside the file, declare an entry point and an output path. After that, you need to tell webpack what to do with the code it encounters. This is where the loaders come in.\par
\par
At this point, you\rquote re probably getting overwhelmed. So remember: Don\rquote t think of the whole system\emdash just think about each step. You first needed to convert ES6 and React code, so you installed Babel. Next, you wanted to combine everything together, so you installed webpack. Now, you need to declare what you want webpack to do with JavaScript specifically. Next, you\rquote ll make similar declarations for style and assets.\par
\par
Webpack uses regular expressions to decide which loader to use on each file. Because you\rquote re working with JavaScript, you only want files that match .js. When webpack encounters a file with a .js extension\emdash such as Copyright.js\emdash you need to tell it which loader to use. In this case, it needs to run the babel-loader.\par
architecture/build/webpack/webpack.config.js\par
\u8203? \tab\u8203?const\u8203? path = require(\u8203?'path'\u8203?);\par
\u8203? \tab\par
\u8203? \tab module.exports = \{\par
\u8203? \tab   entry: \u8203?'./src/index.js'\u8203?,\par
\u8203? \tab   module: \{\par
\u8203? \tab     loaders: [\par
\u8203? \tab       \{\par
\u8203? \tab         test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?js\u8203?\u8203??\u8203?\u8203?/\u8203?,\par
\u8203? \tab         use: \u8203?'babel-loader'\u8203?,\par
\u8203? \tab       \},\par
\u8203? \tab     ],\par
\u8203? \tab   \},\par
\u8203? \tab   output: \{\par
\u8203? \tab     filename: \u8203?'build/bundle.js'\u8203?,\par
\u8203? \tab     path: path.resolve(__dirname),\par
\u8203? \tab   \},\par
\u8203? \tab\};\par
\par
The last step is to update your package.json script to call webpack. Webpack will look for your config file, so you don\rquote t need any other flags or arguments. All you need to do is change\par
\u8203? \tab\u8203?"scripts"\u8203?: \{\par
\u8203? \tab   \u8203?"build"\u8203?: \u8203?"babel src/index.js -o build/bundle.js"\u8203?\par
\u8203? \tab\}\par
\par
to:\par
\u8203? \tab\u8203?"scripts"\u8203?: \{\par
\u8203? \tab   \u8203?"build"\u8203?: \u8203?"webpack"\u8203?\par
\u8203? \tab\}\par
\par
If you run this, you\rquote ll finally be able to see your code in the browser. Try it out.\par
\par
Now that you have the JavaScript working, it\rquote s time for things to get interesting. Remember, the goal is to have components that import all their dependencies. You need webpack to compile your JavaScript, but also to compile your CSS and load your images.\par
\par
Start with CSS. Go back to your Copyright.js file and import your CSS. It should look exactly like it did in the previous tip.\par
architecture/build/css/src/components/Copyright/Copyright.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\u8203?import\u8203? \u8203?'./Copyright.css'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? CopyrightStatement() \{\par
\u8203? \tab   \u8203?const\u8203? year = \u8203?new\u8203? Date().getFullYear();\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <div className=\u8203?"copyright"\u8203?>\par
\u8203? \tab       Copyright \{year\}\par
\u8203? \tab     <\u8203?/div\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
Now you\rquote ll need to install a CSS loader and update your webpack.config.js file. There are lots of tools for handling CSS, but in this case, keep it simple. Install and add two loaders\emdash a CSS loader to interpret the CSS file and a style loader to inject the styles into the <head> element on your page.\par
\par
npm install --save-dev css-loader style-loader.\par
\par
Now that you\rquote ve installed your loaders, update your webpack config by adding a test for files that end in css. This time, you won\rquote t use a single loader. You\rquote ll use two loaders\emdash css-loader and style-loader\emdash so you\rquote ll need an array of strings instead of a single string. Add the style-loader first and then the css-loader.\par
architecture/build/css/webpack.config.js\par
\u8203? \tab module: \{\par
\u8203? \tab   loaders: [\par
\u8203? \tab     \{\par
\u8203? \tab       test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?css$/\u8203?,\par
\u8203? \tab       use: [\par
\u8203? \tab         \u8203?'style-loader'\u8203?,\par
\u8203? \tab         \u8203?'css-loader'\u8203?,\par
\u8203? \tab       ],\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab       test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?js\u8203?\u8203??\u8203?\u8203?/\u8203?,\par
\u8203? \tab       use: \u8203?'babel-loader'\u8203?,\par
\u8203? \tab     \},\par
\u8203? \tab   ],\par
\u8203? \tab\},\par
\par
When you run the build script and open index.html, your components will have the correct styles.\par
\par
Impressive, huh? This is why developers fell in love with webpack. You can keep all your assets batched together and you can call different actions, or series of actions, on each file type.\par
\par
The final step is to handle your image. This time you aren\rquote t compiling an image. Instead, you\rquote re going to use webpack to move the file and rename it to a unique name. Webpack will automatically update the src link in your markup.\par
\par
As a reminder, here\rquote s your component with an imported image:\par
architecture/build/img/src/components/IdeaButton/IdeaButton.js\par
\u8203? \tab\u8203?import\u8203? React \u8203?from\u8203? \u8203?'react'\u8203?;\par
\u8203? \tab\u8203?import\u8203? \u8203?'./IdeaButton.css'\u8203?;\par
\u8203? \tab\u8203?import\u8203? idea \u8203?from\u8203? \u8203?'./idea.svg'\u8203?;\par
\u8203? \tab\par
\u8203? \tab\u8203?export\u8203? \u8203?default\u8203? \u8203?function\u8203? IdeaButton(\{ handleClick, message \}) \{\par
\u8203? \tab   \u8203?return\u8203? (\par
\u8203? \tab     <button\par
\u8203? \tab       className=\u8203?"idea-button"\u8203?\par
\u8203? \tab       onClick=\{handleClick\}\par
\u8203? \tab     >\par
\u8203? \tab       <img\par
\u8203? \tab         className=\u8203?"idea-button__icon"\u8203?\par
\u8203? \tab         src=\{idea\}\par
\u8203? \tab         alt=\u8203?"idea icon"\u8203?\par
\u8203? \tab       />\par
\u8203? \tab       \{ message \}\par
\u8203? \tab     <\u8203?/button\u8203?\u8203?>\u8203?\par
\u8203? \tab   );\par
\u8203? \tab\}\par
\par
Because you aren\rquote t doing any specific image manipulation, use file-loader to move and update your src path. In your webpack config, you\rquote ll test to see if the file is an SVG.\par
\par
This time, you aren\rquote t just declaring a loader; you\rquote re also passing options to the loader. This means you\rquote ll pass an array containing a single object. The object will include your loader and configuration options. The only option you need to pass is the directory for your images. This directory will be where the browser looks for images, so it\rquote s best to reuse your build directory.\par
\par
Set the outputPath to the build directory:\par
architecture/build/img/webpack.config.js\par
\u8203? \tab module: \{\par
\u8203? \tab   loaders: [\par
\u8203? \tab     \{\par
\u8203? \tab       test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?svg\u8203?\u8203??\u8203?\u8203?/\u8203?,\par
\u8203? \tab       use: [\par
\u8203? \tab         \{\par
\u8203? \tab           loader: \u8203?'file-loader'\u8203?,\par
\u8203? \tab           options: \{\par
\u8203? \tab             outputPath: \u8203?'build/'\u8203?,\par
\u8203? \tab           \},\par
\u8203? \tab         \},\par
\u8203? \tab       ],\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab       test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?css$/\u8203?,\par
\u8203? \tab       use: [\par
\u8203? \tab         \u8203?'style-loader'\u8203?,\par
\u8203? \tab         \u8203?'css-loader'\u8203?,\par
\u8203? \tab       ],\par
\u8203? \tab     \},\par
\u8203? \tab     \{\par
\u8203? \tab       test: \u8203?/\u8203?\u8203?\\.\u8203?\u8203?js\u8203?\u8203??\u8203?\u8203?/\u8203?,\par
\u8203? \tab       use: \u8203?'babel-loader'\u8203?,\par
\u8203? \tab     \},\par
\u8203? \tab   ],\par
\u8203? \tab\},\par
\par
Run the build script. Open up index.html and you have your components.\par
\par
See that wasn\rquote t so bad! Of course, if this were an enterprise application, you\rquote d want a server. You\rquote ll probably have more images than just SVGs. You might want the CSS to go to a style sheet instead of <style> tags. Build tools can handle all that for you.\par
\par
The key is to take it slow and add one piece at a time. It\rquote s much harder to add a configuration to a large project than it is to add it piece by piece. Webpack and rollup.js can be complex projects. Webpack has put a lot of work into updating its documentation,[62] and it\rquote s worth reading as you explore more on your own.\par
\par
At this point, you have all the tools you need to write modern JavaScript applications. The final tip is a little different. CSS and HTML are also growing and evolving\emdash actions that used to require JavaScript can now be handled by CSS. In this case, you should happily abandon JavaScript and use other tools.\par
\par
In the next tip, you\rquote ll see how to animate page elements with CSS.\par
\par
Tip 51\tab Leverage CSS for Animations\par
\par
In this tip, you\rquote ll learn how to use CSS for animations.\par
\par
The last tip isn\rquote t even a JavaScript tip. Instead, it\rquote s a tip about when to stop using JavaScript.\par
\par
The key to writing readable code is to use the best tool for the job. JavaScript used to be the best tool for animations. In fact, there were entire libraries dedicated to using JavaScript to create drop-down menus or to animate slide-in elements.\par
\par
It\rquote s much easier now. CSS is replacing JavaScript for simple animations. That\rquote s great. Now you don\rquote t have to worry about using the right timeouts or calculating odd-size constraints. CSS will take care of all that for you. You\rquote ll still need JavaScript for more complicated animations, but for most common tasks, CSS works great.\par
\par
Start by creating a simple page that has a menu on the right. The markup is very simple. You need some text, a button to toggle the side menu, and the menu itself.\par
architecture/css/initial/index-truncated.html\par
\u8203? \tab\u8203?<!doctype html>\u8203?\par
\u8203? \tab <html lang=\u8203?"en"\u8203?>\par
\u8203? \tab     <head>\par
\u8203? \tab         <link href=\u8203?"main.css"\u8203? rel=\u8203?"stylesheet"\u8203?>\par
\u8203? \tab     </head>\par
\u8203? \tab     <body>\par
\u8203? \tab         <div class=\u8203?"main"\u8203?>\par
\u8203? \tab             <h1>Moby Dick</h1>\par
\u8203? \tab             <button id=\u8203?"show"\u8203?>See More</button>\par
\u8203? \tab             <section class=\u8203?"menu"\u8203? id=\u8203?"sidebar"\u8203?>\par
\u8203? \tab                 <h2>Other Works</h2>\par
\u8203? \tab                 <ul>\par
\u8203? \tab                     <li>Bartleby, the Scrivener</li>\par
\u8203? \tab                     <li>Billy Budd</li>\par
\u8203? \tab                 </ul>\par
\u8203? \tab             </section>\par
\u8203? \tab             <section class=\u8203?"content"\u8203?>\par
\u8203? \tab                 <p>\par
\u8203? \tab                   Call me Ishmael.\par
\u8203? \tab                   \u8203?<!-- More content -->\u8203?\par
\u8203? \tab                 </p>\par
\u8203? \tab             </section>\par
\u8203? \tab         </div>\par
\u8203? \tab     </body>\par
\u8203? \tab </html>\par
\par
Start with simple CSS to place the menu on top of the text.\par
architecture/css/initial/main.css\par
\u8203? \tab .main \{\par
\u8203? \tab     width: 1000px;\par
\u8203? \tab     margin: 0 auto;\par
\u8203? \tab     overflow: hidden;\par
\u8203? \tab     position: relative;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab button \{\par
\u8203? \tab     border: black solid 1px;\par
\u8203? \tab     background: #ffffff;\par
\u8203? \tab\}\par
\u8203? \tab\par
\u8203? \tab .menu \{\par
\u8203? \tab     width: 300px;\par
\u8203? \tab     padding: 0 2em;\par
\u8203? \tab     float: right;\par
\u8203? \tab     border: black solid 1px;\par
\u8203? \tab     position: absolute;\par
\u8203? \tab     top: 0;\par
\u8203? \tab     right: 0;\par
\u8203? \tab     height: calc(100% - 2px);\par
\u8203? \tab     background: #ffffff;\par
\u8203? \tab\}\par
\par
As you see in the figure, when the menu is fully opened, it will cover a portion of the words. You\rquote ll change that in a moment.\par
images/cssInitial.png\par
\par
Now that you have the page set up, you\rquote re going to add some CSS animations to slide the menu on and off the page.\par
\par
The first step is hiding the side menu. Add the following property to your .menu class.\par
\par
transform: translateX(calc(300px + 4em + 2px));\par
\par
This property and value\emdash transform: translateX\emdash will move the page outside the container div, making it appear invisible. The calculation is the width of the menu, plus the padding, plus the border.\par
\par
With the menu hidden, it\rquote s time to add a transition. A CSS transition is an animation of a changing property. In other words, an animation is just a visual transition between two properties of the same name.\par
\par
That\rquote s fine, but how do you change a property? Turns out, you\rquote ll need a little JavaScript after all. Add a click event listener to the button. The callback function for the button will toggle the .display class on the menu. The first time you click the button, it will add the class. The second time you click the button, it will remove the class.\par
architecture/css/middle/open.js\par
\u8203? \tab\u8203?const\u8203? sidebar = document.getElementById(\u8203?'sidebar'\u8203?);\par
\u8203? \tab document.getElementById(\u8203?'show'\u8203?)\par
\u8203? \tab   .addEventListener(\u8203?'click'\u8203?, () => \{\par
\u8203? \tab     sidebar.classList.toggle(\u8203?'display'\u8203?);\par
\u8203? \tab   \});\par
\par
Next, you need to update your stylesheet to include styles for a .menu.display\par
architecture/css/middle/main.css\par
\u8203? \tab .menu \{\par
\u8203? \tab     \u8203?/* Other styles from before */\u8203?\par
\u8203? \tab     transform: translateX(calc(300px \u8203?+\u8203? 4em \u8203?+\u8203?  2px));\par
\u8203? \tab\}\par
\u8203? \tab .menu.display \{\par
\u8203? \tab     transform: translateX(0);\par
\u8203? \tab\}\par
\par
When you add the class, you move from a transform of calc(300px + 4em + 2px) to a transform of 0. Because the browser knows that property is changing, it can trigger an animation. All that\rquote s left is to tell the element how to respond to the changing property.\par
\par
A CSS transition is a set of instructions telling the page what to do when moving from an initial property value to the final property value. Check out the Mozilla Developer Network documentation for different options.[63]\par
\par
First, declare the property that will need a transition with transition-property. In this case, you only want to animate the transform, so set the value to transform. Next, set the length of the durations with transition-duration.\par
\par
The transition time will seem very quick or very slow depending on how radical the transition is. Going from 0px to 10px in one second will seem much slower than going from 0 to 100px. In this case, set it for 600ms.\par
\par
Finally, you need to say how the transition should act with the transition-timing-function property. This one is a little more tricky. It can make the transition move faster at the beginning, faster at the ending, or the same speed throughout.[64] Set the value to linear to keep a nice smooth slide throughout.\par
\par
Here\rquote s the updated CSS for .menu.display:\par
architecture/css/animate/main.css\par
\u8203? \tab .menu.display \{\par
\u8203? \tab     \u8203?/* Other styles */\u8203?\par
\u8203? \tab     transform: translateX(0);\par
\u8203? \tab     transition-property: transform;\par
\u8203? \tab     transition-duration: 600ms;\par
\u8203? \tab     transition-timing-function: linear;\par
\u8203? \tab\}\par
\par
When you click the button, you should see the menu slide into place. But when you click it again, the menu will just instantly disappear. The problem is that you only declared the transition for when you add the .display class. There\rquote s no transition for when you remove the .display.\par
\par
No problem\emdash all you need to do is add a transition to the base .menu styles. This time, though, you can shorten things up. You can add all three properties\emdash transition-property, transition-duration, and transition-timing-function\emdash to a single property called transition. You also have the option to apply the transition to any changing property by setting the transition to all.\par
\par
Once you update the stylesheet, you\rquote ll have a menu that slides in on button click and slides out on button click with very minimal JavaScript.\par
architecture/css/animate/main.css\par
\u8203? \tab .menu \{\par
\u8203? \tab     \u8203?/* Other styles */\u8203?\par
\u8203? \tab     transform: translateX(calc(300px \u8203?+\u8203? 4em \u8203?+\u8203?  2px));\par
\u8203? \tab     transition: all 600ms linear;\par
\u8203? \tab\}\par
\par
Honestly, you only need the transition on the .menu class, unless you want the slide in and slide out to be different. Transitions are like any other property. They\rquote ll bubble up to all elements unless you override them with a more specific selector.\par
\par
This simple slide-in used to require a lot of JavaScript code. Now it only takes a single line of CSS and a simple class toggle. Part of what makes web development such a delight is the tool set is steadily improving. HTML is more semantic. Styles are more flexible. JavaScript is simpler and easier to read.\par
\par
JavaScript is a great language, and I hope you learned to love it. It\rquote s simple, expressive, and very elegant. And the best part is it\rquote s getting better all the time. You have everything you need to start writing JavaScript that you can be proud of. Now all you need to do is start building. Have fun.\par
Footnotes\par
\par
[52]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://lodash.com/ }}{\fldrslt{https://lodash.com/\ul0\cf0}}}}\f1\fs22\par
[53]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://www.npmjs.com/package/lodash }}{\fldrslt{https://www.npmjs.com/package/lodash\ul0\cf0}}}}\f1\fs22\par
[54]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://prettier.io }}{\fldrslt{https://prettier.io\ul0\cf0}}}}\f1\fs22\par
[55]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/facebookincubator/create-react-app }}{\fldrslt{https://github.com/facebookincubator/create-react-app\ul0\cf0}}}}\f1\fs22\par
[56]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.telerik.com/featured/front-end-application-frameworks-component-architectures/ }}{\fldrslt{https://developer.telerik.com/featured/front-end-application-frameworks-component-architectures/\ul0\cf0}}}}\f1\fs22\par
[57]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://github.com/facebookincubator/create-react-app }}{\fldrslt{https://github.com/facebookincubator/create-react-app\ul0\cf0}}}}\f1\fs22\par
[58]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://babeljs.io/ }}{\fldrslt{https://babeljs.io/\ul0\cf0}}}}\f1\fs22\par
[59]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://webpack.js.org }}{\fldrslt{https://webpack.js.org\ul0\cf0}}}}\f1\fs22\par
[60]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://rollupjs.org/ }}{\fldrslt{https://rollupjs.org/\ul0\cf0}}}}\f1\fs22\par
[61]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://webpack.js.org/concepts/#loaders }}{\fldrslt{https://webpack.js.org/concepts/#loaders\ul0\cf0}}}}\f1\fs22\par
[62]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://webpack.js.org/concepts/ }}{\fldrslt{https://webpack.js.org/concepts/\ul0\cf0}}}}\f1\fs22\par
[63]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions\ul0\cf0}}}}\f1\fs22\par
[64]\par
\par
    {{\field{\*\fldinst{HYPERLINK https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function }}{\fldrslt{https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function\ul0\cf0}}}}\f0\fs22\par
\par
Bibliography\par
\par
[Fog13]\par
    Michael Fogus. Functional JavaScript. O\rquote Reilly & Associates, Inc., Sebastopol, CA, 2013.\par
[Sim14]\par
    Kyle Simpson. You Don\rquote t Know JS: this Object Prototypes. O\rquote Reilly & Associates, Inc., Sebastopol, CA, 2014.\par
[Sub16]\par
    Venkat Subramaniam. Test-Driving JavaScript Applications. The Pragmatic Bookshelf, Raleigh, NC, 2016.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
}
 