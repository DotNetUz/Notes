Chapter 1: Introduction â€“ The What and the Why
    Performance testing
    Load testing
    Stress testing
    Profiling
    Cost benefits of performance and load testing
        Example scenarios
    Sometimes, what seems right can be wrong
    Conclusion
Chapter 2: Understanding Performance Targets
    Identifying performance targets
    Structuring test breakdowns
    Determining what load to target
    Contingency in your estimations
    Estimate the mix of browsers for your web application
    What data do we measure?
    Time to First Byte
        Total page response time
        What about average response time?
        Sweet spots and operational ceilings
    Conclusion
Chapter 3: Performance and Load Test Metrics
    What metrics do we need?
    Basic metrics
Web application basic metrics
What to look for
CPU utilization
Memory utilization
Response time
Creating a baseline
Using Visual Studio to analyze the results
Using the Test Results management window
Using the Open and Manage Test Results dialog
Filtering performance test result selection
Sweet spots and operational ceilings
Detailed performance metrics
Performance metrics
What do I do with all this information?
Conclusion
Chapter 4: Implementing Your Test Rig
Creating the performance test rig
Architecture and structure of a performance test rig
Role breakdown
Setting up and configuration
Port setup and firewall considerations
Network segmentation/isolation
Controller setup
Creating the load test database
Guest policy on Windows XP in workgroup mode
Agent setup
Workstation setup
Troubleshooting the controller and agents
Setting up performance counter collection
Conclusion
Chapter 5: Creating Performance Tests
Basic solution structure
Recording the web tests
Test replay
Data binding web tests
Creating a data source for data binding
Test deployment considerations
Web test code generation
Extensibility through plug-ins
Alternative ways of recording web tests
Considerations for load balancing / load balanced hardware
Test automation
Creating a performance test scenario
Putting automation in place
Executing the load test
Collecting performance monitor data
Collecting SQL Server usage statistics
Clean up tasks
Conclusion
Chapter 6: Application Profiling
Types of profiling
Performance profiling
Memory profiling
When to start profiling
Reactive debugging
Proactive analysis
Technique validation
Tools used for profiling
CLRProfiler
Red Gate's ANTS Memory and Performance Profilers
Microfocus DevPartner Studio Professional 9.1
Microsoft Visual Studio 2008 profiling tools
What to look for
Performance analysis
Memory analysis
Production / load test clues
General performance counters
Managing profiling results
Comparing analysis runs
Pre-check-in requirements
Continuous integrated testing
Summary
Chapter 7: Performance Profiling
A caveat
What the load test will tell you (and profilers can't)
Load testing 
Where is it slow?
When to start testing
Competing resources
Types of profiler
Sampling profiler
Event-based profiling
Concurrency (thread contention) profiling
Instrumenting profilers
Choosing a profiler
What profilers can measure
What to look for
Using the tools
ANTS Performance Profiler 5
DevPartner Studio Professional 9.1
Performance timing profiler
Visual Studio Professional 2008/2010
Visual Studio 2010 Team Edition
SQL Profiler 2005/2008
Summary
Chapter 8: Memory Profiling
Why memory matters
The managed heap(s)
Small Object Heap
Optimizing garbage collection
Large Object Heap
Finalizable objects
Profiling memory
Memory issues
Using tools to uncover memory problems
Test plans
ANTS Memory Profiler 5 
Visual Studio 2008 Memory Profiler
DevPartner Studio Professional 9 
CLRProfiler
Summary
Chapter 9: The Performance Testing Process
Development processes and scheduling tests
An ideal world
Methodology
The reality
A word about best practice
Managing and monitoring performance changes
The entire performance picture
Chapter 10: Common Areas for Performance Improvement
Every application is different
Database access
The best and most efficient form of data access
What to cache?
Indexing
Database access abstractions
Reflection
String manipulation
Cryptographic functions
Network call latency
Key considerations when calling external resources
Synchronous vs  asynchronous
Asynchronous web pages
Web application specific
Data binding
Output caching
web.config
Conclusion
Chapter 11: Load Balancing
What is load balancing and how does it help?
Infrastructure considerations
Application considerations
Performance testing and load balancing
Servers of different specifications in a farm
Windows Azure
Conclusion
Chapter 12: Internet Information Server
Background
IIS6 and the application pool
Under the hood
Request listening (HTTP.sys)
Request processing (user mode)
IIS common considerations
Worker process recycling
Bitness (32- or 64-bit application pools)
Queue length
Pipeline mode
CPU limiting
Processor affinity
Health monitoring
Rapid failure detection
SSL server affinity and hardware acceleration
How it works
Load balancing and SSL
Optimizing performance with SSL
HTTP compression
TCP effect
CPU effect
Static and dynamic content compression
Static content
HTTP headers
Freshness and validation
Content expiration
Controlling content expiration in IIS
Tools
Caching tip
Reverse proxy
IIS6 considerations
IIS7 considerations
Content Delivery Networks
CDN service providers
CDN and IIS7 Application Request Routing
Browser limitations
Script CDNs
Summary
Chapter 13: HTTP Optimization
Tools
Firebug
Fiddler
YSlow
Internet Explorer Dev toolbar
JavaScript considerations
Use compression
Minify scripts
Adopt a caching policy
Place JavaScript files at the end of pages
Reduce the number of scripts
Use a Content Delivery Network (again)
JavaScript performance analysis
CSS optimization
Externalize your style definitions
Design your CSS for reuse
Keep your CSS concise
Use CSS instead of JavaScript if possible
Avoid CSS expressions
Use CSS Sprites to improve HTTP performance
Remove white space and comments before publishing
HTTP efficiency
HTTP 404 responses
HTTP 301/302 redirect responses
Image optimization
Page weight
Reducing ViewState overhead
Control ID page bloat
HTML white space
Layouts using tables
AJAX considerations
Problems with AJAX
Summary
A call to action
