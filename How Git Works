How Git Works

Module 01: Git Is Not What You Think
Introduction
  How does Git internals work?
  Porcelain commands:
     git add
     git commit
     git push
     git pull
     git branch
     git checkout
     git merge
     git rebase
     ...
  Plumbling Commands - the basic building blocks:
    git cat-file
    git hash-object
    git count-objects
    ...
  To master Git, don't worry about learning the commands 
    - Learn The Model
    - Then comes deeper understanding of commands 

Git Is an Onion - layered
  Wikipedia: Git is a Distributed Revision Control System
  ... a simpler way to see Git - a Revision Control System
  ... a even simpler way to see Git - a Stupid Content Tracker for contensts, file and directories 
  ... at its core, Git is a Persistent Map that maps keys to values
  Following will deal with the layers from inside out
  
Meet SHA1
  At the core Git is a Map 
    - a table with keys and values
    values: any sequence of bytes, like text file or binary file
    Given a value, Git can calculate a key for it, a hash
    SHA1 is the algorithm for the calculation
    Every content has its own unique string SHA1 value
    SHA1s are 20 bytes in hexadecimal format (20 X 2 ^8) -> 40 hex digits
    These values will be the keys to store content in map
  
  Every object in Git has its own SHA1 
    so do directories and commits 
  
  What happen when SHA1 collide? Data over-write can happen, but unlikely 
    SHA1s are unique in the universe
  
Storing Things
  Git as "persistent" map:
  To make a content persistent, add "-w" to following command under Git Bash
    > echo "Apple Pie" | git hash-object --stdin -w 
  
  However, since there is no repository specified, the content cannot be saved
    thus following is displayed on console: 
    fatal: Not a git repository (or any of the parent directories): .git
  
  To create a repository, use a high level procelain command: git init
    > git init
    Initialized empty Git repository in {current working directory}/.git/
  This command creates a new hidden subdirectory called .git 

  With a repo ready, re-execute following command 
    > echo "Apple Pie" | git hash-object --stdin -w 
    23991897e13e47ed0adb91a0082c31c82fe0cbe5
  Content is now saved without issue 
  
  Inside the hidden folder .git, there is a directory named "objects"
  This is "object database" - stores objects that represents content 
  Inside "objects" directory, a directory "23" 
    "23" is the first two hexadecimal digits of the SHA1 of the fist saved content ("23"991897e13e47ed0adb91a0082c31c82fe0cbe5)    
    Inside folder 23 is a file named with the remaining digits of the SHA1 (23"991897e13e47ed0adb91a0082c31c82fe0cbe5")    
    - 991897e13e47ed0adb91a0082c31c82fe0cbe5
    This scheme prevents one single huge cluttered directory 

    The file is a "blob" of data 
      blob is a generic piece of content 
    
    However, the original content cannot be read directly 
    Git add a small header and compress content to save space

  Another plumbling command can be used to look at the content of blob directly
    > git cat-file
  git cat-file takes SHA1 as argument 
    with option -t 
      $ git cat-file 23991897e13e47ed0adb91a0082c31c82fe0cbe5 -t
      blob
    Git returns the type of file, "blob"

    with option -p 
      $ git cat-file 23991897e13e47ed0adb91a0082c31c82fe0cbe5 -p
      Apple Pie
    
    Git returns the readable content of file ("Apple Pie")
  This is the core of Git
  
First Commit!
  Git as "content tracker":
  A sample project:
    menu.txt
    recipe
      README.txt
      apple_pie.txt
  
  execute command at directory root 
    > git init
    Initialized empty Git repository in c:/cookbook/.git/
  
  For a new project, the ".git/objects" folder holds nothing but "info" and "pack" folder

  Execute command "git status" at project root 
    c:\cookbook>git status
    On branch master

    No commits yet

    Untracked files:
      (use "git add <file>..." to include in what will be committed)

            menu.txt
            recipes/

    nothing added to commit but untracked files present (use "git add" to track) 
  
  To commit a file, it needs to be placed in "staging" area via "add" command
    c:\cookbook>git add menu.txt
    c:\cookbook>git add recipes/
  
  Then verify status again
    c:\cookbook>git status
    On branch master

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)

            new file:   menu.txt
            new file:   recipes/README.txt
            new file:   recipes/apple_pie.txt
  
  Execute the first commit:
    c:\cookbook>git commit -m "First commit!" 
    [master (root-commit) daac1a7] First commit!
      3 files changed, 3 insertions(+)
      create mode 100644 menu.txt
      create mode 100644 recipes/README.txt
      create mode 100644 recipes/apple_pie.txt

  Verify staging area now has nothing to commit
    c:\cookbook>git status
    On branch master
    nothing to commit, working tree clean  

  To verify existing commits, run "git log"
    c:\cookbook>git log
    commit daac1a720653a95c427071fc251b69a6d0f46ec6 (HEAD -> master)
    Author: Charles Kuo <chao.kuo@gmail.com>
    Date:   Thu Apr 11 18:53:20 2019 -0700

        First commit!  

  Observe that the SHA1 starts with "daac"
  Open .git/objects/
  locate a folder starts with "da" - it stores the content of the first commit 
  
  To view content of the commit directly 
    c:\cookbook>git cat-file -p daac1a720653a95c427071fc251b69a6d0f46ec6
    tree 46624f2d142b3a74e3aac65f691cdfdbb42ce022
    author Charles Kuo <CharlesK@ashn.com> 1555034000 -0700
    committer Charles Kuo <CharlesK@ashn.com> 1555034000 -0700

    First commit!
  
  A commit is but the text displayed above, generated by Git, stored like a blob
  Git generated content's SHA1, then add a small header to the commit 
  The commit is then compressed, stored as a file in object database  

  The commit is made of the following:
    author Charles Kuo <CharlesK@ashn.com>        - the name of the author 
    committer Charles Kuo <CharlesK@ashn.com>     - the name of the committer
    1555034000 -0700                              - the date of commit
    First commit!                                 - the message
    tree 46624f2d142b3a74e3aac65f691cdfdbb42ce022 - the SHA1 of a tree
  
  tree:
    blob is a file stored in Git
    tree is a directory stored in Git, like blob, generated by Git, then hashed and stored in object database 
  
  In object database, locate the folder that starts with "46", with file that holds the remaining of the SHA1
  To view content of the tree directly 
    c:\cookbook>git cat-file -p 46624f2d142b3a74e3aac65f691cdfdbb42ce022
    100644 blob 9eed377bbdeb4aa5d14f8df9cd50fed042f41023    menu.txt
    040000 tree 5458b1e1046e66dd8dbb249fc4ff64ab29ff90a9    recipes

  The extra data before data type (100644, 040000) are for access permission
  To view content of the blob directly 
    c:\cookbook>git cat-file -p 9eed377bbdeb4aa5d14f8df9cd50fed042f41023
    Apple Pie

  Drill deeper into another tree:
    c:\cookbook>git cat-file -p 5458b1e1046e66dd8dbb249fc4ff64ab29ff90a9
    100644 blob 37c0180c056cc7bf91b1046c4990ec5ee71668f2    README.txt
    100644 blob 9eed377bbdeb4aa5d14f8df9cd50fed042f41023    apple_pie.txt
    
    c:\cookbook>git cat-file -p 37c0180c056cc7bf91b1046c4990ec5ee71668f2
    Put your recipes in this directory, one recipe per file.

    Notice "100644 blob 9eed377bbdeb4aa5d14f8df9cd50fed042f41023    apple_pie.txt"
    holds the same SHA1 as menu.txt - because both have exactly same content 
    - Git reuse existing object in onject database

    blob is not exactly a file, it's file name and permission are stored in the tree that points to the blob

    The Object Database
    The commit "daac" points to a tree "4662"
    tree "4662" points to:
      a blob "9eed", menu.txt -  a content "Apple Pie"
      another tree "5458", recipes
  
Versioning Made Easy
One More Thing: Annotated Tags
What Git Really Is

Module 02: Branches Demystified
Introduction
What Branches Really Are
The Mechanics of the Current Branch
Let's Merge!
Time Travel for Developers
Merging Without Merging
Losing Your HEAD
Objects and References

Module 03: Rebasing Made Simple
Introduction
What a Rebase Looks Like
An Illusion of Movement
Taking out the Garbage
The Trade-offs of Merges
The Trade-offs of Rebases
Tags in Brief
A Version Control System

Module 04: Distributed Version Control
Introduction
A World of Peers
Local and Remote
The Joy of Pushing
The Chore of Pulling
Rebase Revisited
Getting Social
The Whole Onion